/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
pub type std_basic_string__Char_alloc_type = u8;
pub type std_basic_string__Alloc_traits = u8;
pub type std_basic_string_traits_type = u8;
pub type std_basic_string_value_type = u8;
pub type std_basic_string_allocator_type = u8;
pub type std_basic_string_size_type = u8;
pub type std_basic_string_difference_type = u8;
pub type std_basic_string_reference = u8;
pub type std_basic_string_const_reference = u8;
pub type std_basic_string_pointer = u8;
pub type std_basic_string_const_pointer = u8;
pub type std_basic_string_iterator = u8;
pub type std_basic_string_const_iterator = u8;
pub type std_basic_string_const_reverse_iterator = u8;
pub type std_basic_string_reverse_iterator = u8;
pub type std_basic_string___const_iterator = u8;
pub type std_basic_string___sv_type = u8;
pub type std_basic_string__If_sv = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___sv_wrapper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string__Alloc_hider {
    pub _address: u8,
}
pub const std_basic_string__S_local_capacity: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union std_basic_string__bindgen_ty_2 {
    pub _bindgen_opaque_blob: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair {
    pub _address: u8,
}
pub type std_pair_first_type = u8;
pub type std_pair_second_type = u8;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_exception {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_exception>(),
        8usize,
        concat!("Size of: ", stringify!(std_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(std_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9exceptionD1Ev"]
    pub fn std_exception_exception_destructor(this: *mut std_exception);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
    pub fn std_exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_value_type = u8;
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Base = u8;
pub type std_vector__Tp_alloc_type = u8;
pub type std_vector__Alloc_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_size_type = u64;
pub type std_vector_difference_type = u64;
pub type std_vector_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector__Temporary_value {
    pub _address: u8,
}
pub type std_string = [u64; 4usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
pub type std_ostream = [u64; 34usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr {
    pub _address: u8,
}
pub type std_unique_ptr__DeleterConstraint = u8;
pub type std_unique_ptr_pointer = u8;
pub type std_unique_ptr_element_type = u8;
pub type std_unique_ptr_deleter_type = u8;
pub type std_unique_ptr___safe_conversion_up = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_shared_ptr {
    pub _address: u8,
}
pub type std_shared_ptr__Constructible = u8;
pub type std_shared_ptr__Assignable = u8;
pub type std_shared_ptr_element_type = u8;
pub type std_shared_ptr_weak_type = u8;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_any {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union std_any__Storage {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std_any__Storage() {
    assert_eq!(
        ::std::mem::size_of::<std_any__Storage>(),
        8usize,
        concat!("Size of: ", stringify!(std_any__Storage))
    );
    assert_eq!(
        ::std::mem::align_of::<std_any__Storage>(),
        8usize,
        concat!("Alignment of ", stringify!(std_any__Storage))
    );
}
pub type std_any__Internal = u8;
pub type std_any__Manager = u8;
pub type std_any__Decay_if_not_any = u8;
pub type std_any___any_constructible = u8;
pub type std_any___any_constructible_t = u8;
pub type std_any___emplace_t = u8;
pub const std_any__Op__Op_access: std_any__Op = 0;
pub const std_any__Op__Op_get_type_info: std_any__Op = 1;
pub const std_any__Op__Op_clone: std_any__Op = 2;
pub const std_any__Op__Op_destroy: std_any__Op = 3;
pub const std_any__Op__Op_xfer: std_any__Op = 4;
pub type std_any__Op = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union std_any__Arg {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_std_any__Arg() {
    assert_eq!(
        ::std::mem::size_of::<std_any__Arg>(),
        8usize,
        concat!("Size of: ", stringify!(std_any__Arg))
    );
    assert_eq!(
        ::std::mem::align_of::<std_any__Arg>(),
        8usize,
        concat!("Alignment of ", stringify!(std_any__Arg))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_any__Manager_internal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_any__Manager_external {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_any() {
    assert_eq!(
        ::std::mem::size_of::<std_any>(),
        16usize,
        concat!("Size of: ", stringify!(std_any))
    );
    assert_eq!(
        ::std::mem::align_of::<std_any>(),
        8usize,
        concat!("Alignment of ", stringify!(std_any))
    );
}
pub type std_chrono_milliseconds = u64;
pub const std_cv_status_no_timeout: std_cv_status = 0;
pub const std_cv_status_timeout: std_cv_status = 1;
pub type std_cv_status = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_map {
    pub _address: u8,
}
pub type std_map_key_type = u8;
pub type std_map_mapped_type = u8;
pub type std_map_value_type = u8;
pub type std_map_key_compare = u8;
pub type std_map_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_map_value_compare {
    pub _address: u8,
}
pub type std_map__Pair_alloc_type = u8;
pub type std_map__Rep_type = u8;
pub type std_map__Alloc_traits = u8;
pub type std_map_pointer = u8;
pub type std_map_const_pointer = u8;
pub type std_map_reference = u8;
pub type std_map_const_reference = u8;
pub type std_map_iterator = u8;
pub type std_map_const_iterator = u8;
pub type std_map_size_type = u8;
pub type std_map_difference_type = u8;
pub type std_map_reverse_iterator = u8;
pub type std_map_const_reverse_iterator = u8;
pub type std_map_node_type = u8;
pub type std_map_insert_return_type = u8;
pub type __pid_t = ::std::os::raw::c_int;
pub type pid_t = __pid_t;
pub type uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type xuid_t = uuid_t;
pub const axlf_section_kind_BITSTREAM: axlf_section_kind = 0;
pub const axlf_section_kind_CLEARING_BITSTREAM: axlf_section_kind = 1;
pub const axlf_section_kind_EMBEDDED_METADATA: axlf_section_kind = 2;
pub const axlf_section_kind_FIRMWARE: axlf_section_kind = 3;
pub const axlf_section_kind_DEBUG_DATA: axlf_section_kind = 4;
pub const axlf_section_kind_SCHED_FIRMWARE: axlf_section_kind = 5;
pub const axlf_section_kind_MEM_TOPOLOGY: axlf_section_kind = 6;
pub const axlf_section_kind_CONNECTIVITY: axlf_section_kind = 7;
pub const axlf_section_kind_IP_LAYOUT: axlf_section_kind = 8;
pub const axlf_section_kind_DEBUG_IP_LAYOUT: axlf_section_kind = 9;
pub const axlf_section_kind_DESIGN_CHECK_POINT: axlf_section_kind = 10;
pub const axlf_section_kind_CLOCK_FREQ_TOPOLOGY: axlf_section_kind = 11;
pub const axlf_section_kind_MCS: axlf_section_kind = 12;
pub const axlf_section_kind_BMC: axlf_section_kind = 13;
pub const axlf_section_kind_BUILD_METADATA: axlf_section_kind = 14;
pub const axlf_section_kind_KEYVALUE_METADATA: axlf_section_kind = 15;
pub const axlf_section_kind_USER_METADATA: axlf_section_kind = 16;
pub const axlf_section_kind_DNA_CERTIFICATE: axlf_section_kind = 17;
pub const axlf_section_kind_PDI: axlf_section_kind = 18;
pub const axlf_section_kind_BITSTREAM_PARTIAL_PDI: axlf_section_kind = 19;
pub const axlf_section_kind_PARTITION_METADATA: axlf_section_kind = 20;
pub const axlf_section_kind_EMULATION_DATA: axlf_section_kind = 21;
pub const axlf_section_kind_SYSTEM_METADATA: axlf_section_kind = 22;
pub const axlf_section_kind_SOFT_KERNEL: axlf_section_kind = 23;
pub const axlf_section_kind_ASK_FLASH: axlf_section_kind = 24;
pub const axlf_section_kind_AIE_METADATA: axlf_section_kind = 25;
pub const axlf_section_kind_ASK_GROUP_TOPOLOGY: axlf_section_kind = 26;
pub const axlf_section_kind_ASK_GROUP_CONNECTIVITY: axlf_section_kind = 27;
pub const axlf_section_kind_SMARTNIC: axlf_section_kind = 28;
pub const axlf_section_kind_AIE_RESOURCES: axlf_section_kind = 29;
pub const axlf_section_kind_OVERLAY: axlf_section_kind = 30;
pub const axlf_section_kind_VENDER_METADATA: axlf_section_kind = 31;
pub const axlf_section_kind_AIE_PARTITION: axlf_section_kind = 32;
pub const axlf_section_kind_IP_METADATA: axlf_section_kind = 33;
pub type axlf_section_kind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct axlf_section_header {
    pub m_sectionKind: u32,
    pub m_sectionName: [::std::os::raw::c_char; 16usize],
    pub m_sectionOffset: u64,
    pub m_sectionSize: u64,
}
#[test]
fn bindgen_test_layout_axlf_section_header() {
    const UNINIT: ::std::mem::MaybeUninit<axlf_section_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<axlf_section_header>(),
        40usize,
        concat!("Size of: ", stringify!(axlf_section_header))
    );
    assert_eq!(
        ::std::mem::align_of::<axlf_section_header>(),
        8usize,
        concat!("Alignment of ", stringify!(axlf_section_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sectionKind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_section_header),
            "::",
            stringify!(m_sectionKind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sectionName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_section_header),
            "::",
            stringify!(m_sectionName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sectionOffset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_section_header),
            "::",
            stringify!(m_sectionOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sectionSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_section_header),
            "::",
            stringify!(m_sectionSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct axlf_header {
    pub m_length: u64,
    pub m_timeStamp: u64,
    pub m_featureRomTimeStamp: u64,
    pub m_versionPatch: u16,
    pub m_versionMajor: u8,
    pub m_versionMinor: u8,
    pub m_mode: u16,
    pub m_actionMask: u16,
    pub m_interface_uuid: [::std::os::raw::c_uchar; 16usize],
    pub m_platformVBNV: [::std::os::raw::c_uchar; 64usize],
    pub __bindgen_anon_1: axlf_header__bindgen_ty_1,
    pub m_debug_bin: [::std::os::raw::c_char; 16usize],
    pub m_numSections: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union axlf_header__bindgen_ty_1 {
    pub m_next_axlf: [::std::os::raw::c_char; 16usize],
    pub uuid: xuid_t,
}
#[test]
fn bindgen_test_layout_axlf_header__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<axlf_header__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<axlf_header__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(axlf_header__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<axlf_header__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(axlf_header__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_next_axlf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header__bindgen_ty_1),
            "::",
            stringify!(m_next_axlf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header__bindgen_ty_1),
            "::",
            stringify!(uuid)
        )
    );
}
#[test]
fn bindgen_test_layout_axlf_header() {
    const UNINIT: ::std::mem::MaybeUninit<axlf_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<axlf_header>(),
        152usize,
        concat!("Size of: ", stringify!(axlf_header))
    );
    assert_eq!(
        ::std::mem::align_of::<axlf_header>(),
        8usize,
        concat!("Alignment of ", stringify!(axlf_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_timeStamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_featureRomTimeStamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_featureRomTimeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_versionPatch) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_versionPatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_versionMajor) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_versionMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_versionMinor) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_versionMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mode) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_actionMask) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_actionMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_interface_uuid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_interface_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_platformVBNV) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_platformVBNV)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_debug_bin) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_debug_bin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numSections) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_numSections)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct axlf {
    pub m_magic: [::std::os::raw::c_char; 8usize],
    pub m_signature_length: i32,
    pub reserved: [::std::os::raw::c_uchar; 28usize],
    pub m_keyBlock: [::std::os::raw::c_uchar; 256usize],
    pub m_uniqueId: u64,
    pub m_header: axlf_header,
    pub m_sections: [axlf_section_header; 1usize],
}
#[test]
fn bindgen_test_layout_axlf() {
    const UNINIT: ::std::mem::MaybeUninit<axlf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<axlf>(),
        496usize,
        concat!("Size of: ", stringify!(axlf))
    );
    assert_eq!(
        ::std::mem::align_of::<axlf>(),
        8usize,
        concat!("Alignment of ", stringify!(axlf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(m_magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_signature_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(m_signature_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_keyBlock) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(m_keyBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uniqueId) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(m_uniqueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sections) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(m_sections)
        )
    );
}
pub type xclDeviceHandle = *mut ::std::os::raw::c_void;
pub type xclBufferHandle = ::std::os::raw::c_uint;
pub type xclBufferExportHandle = i32;
pub const xclBOSyncDirection_XCL_BO_SYNC_BO_TO_DEVICE: xclBOSyncDirection = 0;
pub const xclBOSyncDirection_XCL_BO_SYNC_BO_FROM_DEVICE: xclBOSyncDirection = 1;
pub const xclBOSyncDirection_XCL_BO_SYNC_BO_GMIO_TO_AIE: xclBOSyncDirection = 2;
pub const xclBOSyncDirection_XCL_BO_SYNC_BO_AIE_TO_GMIO: xclBOSyncDirection = 3;
pub type xclBOSyncDirection = ::std::os::raw::c_uint;
#[doc = " @class uuid\n\n @brief\n Wrapper class to treat uuid_t as a value type supporting copying\n\n @details\n xrt::uuid is used by many XRT APIs to match an expected xclbin\n against current device xclbin, or to get the uuid of current loaded\n shell on the device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_uuid {
    pub m_uuid: xuid_t,
}
#[test]
fn bindgen_test_layout_xrt_uuid() {
    const UNINIT: ::std::mem::MaybeUninit<xrt_uuid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xrt_uuid>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_uuid))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_uuid>(),
        1usize,
        concat!("Alignment of ", stringify!(xrt_uuid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xrt_uuid),
            "::",
            stringify!(m_uuid)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_detail_pimpl {
    pub handle: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_detail_abi {
    pub major: ::std::os::raw::c_uint,
    pub minor: ::std::os::raw::c_uint,
    pub code: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xrt_detail_abi() {
    const UNINIT: ::std::mem::MaybeUninit<xrt_detail_abi> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_abi>(),
        12usize,
        concat!("Size of: ", stringify!(xrt_detail_abi))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_abi>(),
        4usize,
        concat!("Alignment of ", stringify!(xrt_detail_abi))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xrt_detail_abi),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xrt_detail_abi),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xrt_detail_abi),
            "::",
            stringify!(code)
        )
    );
}
pub type xrt_detail_any = std_any;
#[doc = " @class xclbin\n\n @brief\n xrt::xclbin represents an xclbin and provides APIs to access meta data.\n\n @details\n The xclbin object is constructed by the user from a file.\n\n When the xclbin object is constructed from a complete xclbin, then it\n can be used by xrt::device to program the xclbin onto the device.\n\n **First-class objects and class navigation**\n\n All meta data is rooted at xrt::xclbin.\n\n \\image{inline} html xclbin_navigation.png \"xclbin navigation\"\n\n From the xclbin object\n xrt::xclbin::kernel or xrt::xclbin::ip objects can be constructed.\n\n The xrt:xclbin::kernel is a concept modelled only in the xclbin XML\n metadata, it corresponds to a function that can be executed by one\n or more compute units modelled by xrt::xclbin::ip objects.  An\n xrt::xclbin::ip object corresponds to an entry in the xclbin\n IP_LAYOUT section, so the xrt::xclbin::kernel object is just a\n grouping of one or more of these.\n\n In some cases the kernel concept is not needed, thus\n xrt::xclbin::ip objects corresponding to entries in the xclbin\n IP_LAYOUT sections can be accessed directly.\n\n An xrt::xclbin::arg object corresponds to one or more entries in\n the xclbin CONNECTIVITY section decorated with additional meta data\n (offset, size, type, etc) from the XML section if available.  An\n argument object represents a specific kernel or ip argument. If\n the argument is a global buffer, then it may connect to one or more\n memory objects.\n\n Finally the xrt::xclbin::mem object corresponds to an entry in the\n MEM_TOPOLOGY section of the xclbin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_xclbin {
    pub _base: xrt_detail_pimpl,
}
pub const xrt_xclbin_target_type_hw: xrt_xclbin_target_type = 0;
pub const xrt_xclbin_target_type_sw_emu: xrt_xclbin_target_type = 1;
pub const xrt_xclbin_target_type_hw_emu: xrt_xclbin_target_type = 2;
#[doc = " @enum target_type\n\n @brief\n Type of xclbin\n\n @details\n See `xclbin.h`"]
pub type xrt_xclbin_target_type = ::std::os::raw::c_int;
#[doc = " @class mem\n\n @brief\n xrt::xclbin::mem represents a physical device memory bank\n\n @details\n A memory object is constructed from an entry in the MEM_TOPOLOGY\n section of an xclbin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_mem_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_xclbin_mem {
    pub _base: xrt_detail_pimpl,
}
pub const xrt_xclbin_mem_memory_type_ddr3: xrt_xclbin_mem_memory_type = 0;
pub const xrt_xclbin_mem_memory_type_ddr4: xrt_xclbin_mem_memory_type = 1;
pub const xrt_xclbin_mem_memory_type_dram: xrt_xclbin_mem_memory_type = 2;
pub const xrt_xclbin_mem_memory_type_streaming: xrt_xclbin_mem_memory_type = 3;
pub const xrt_xclbin_mem_memory_type_preallocated_global: xrt_xclbin_mem_memory_type = 4;
pub const xrt_xclbin_mem_memory_type_are: xrt_xclbin_mem_memory_type = 5;
pub const xrt_xclbin_mem_memory_type_hbm: xrt_xclbin_mem_memory_type = 6;
pub const xrt_xclbin_mem_memory_type_bram: xrt_xclbin_mem_memory_type = 7;
pub const xrt_xclbin_mem_memory_type_uram: xrt_xclbin_mem_memory_type = 8;
pub const xrt_xclbin_mem_memory_type_streaming_connection: xrt_xclbin_mem_memory_type = 9;
pub const xrt_xclbin_mem_memory_type_host: xrt_xclbin_mem_memory_type = 10;
#[doc = " @enum memory_type - type of memory\n\n @details\n See `xclbin.h`"]
pub type xrt_xclbin_mem_memory_type = u8;
#[test]
fn bindgen_test_layout_xrt_xclbin_mem() {
    assert_eq!(
        ::std::mem::size_of::<xrt_xclbin_mem>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_xclbin_mem))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_xclbin_mem>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_xclbin_mem))
    );
}
extern "C" {
    #[doc = " get_name() - Get tag name\n\n @return\n   Memory tag name"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3mem7get_tagB5cxx11Ev"]
    pub fn xrt_xclbin_mem_get_tag(this: *const xrt_xclbin_mem) -> std_string;
}
extern "C" {
    #[doc = " get_base_address() - Get the base address of the memory bank\n\n @return\n  Base address of the memory bank, or -1 for invalid base address"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3mem16get_base_addressEv"]
    pub fn xrt_xclbin_mem_get_base_address(this: *const xrt_xclbin_mem) -> u64;
}
extern "C" {
    #[doc = " get_size() - Get the size of the memory in KB\n\n @return\n  Size of memory in KB, or -1 for invalid size"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3mem11get_size_kbEv"]
    pub fn xrt_xclbin_mem_get_size_kb(this: *const xrt_xclbin_mem) -> u64;
}
extern "C" {
    #[doc = " get_used() - Get used status of the memory\n\n @return\n  True of this memory bank is used by kernels in the xclbin\n  or false otherwise.\n\n A value of false indicates that no buffer can be allocated\n in this memory bank."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3mem8get_usedEv"]
    pub fn xrt_xclbin_mem_get_used(this: *const xrt_xclbin_mem) -> bool;
}
extern "C" {
    #[doc = " get_type() - Get the type of the memory\n\n @return\n  Memory type\n"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3mem8get_typeEv"]
    pub fn xrt_xclbin_mem_get_type(this: *const xrt_xclbin_mem) -> xrt_xclbin_mem_memory_type;
}
extern "C" {
    #[doc = " get_index() - Get the index of the memory\n\n @return\n  Index of the memory within the memory topology\n\n The returned index can be used when allocating buffers using\n \\ref xrt::bo provided the memory bank is connected / used."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3mem9get_indexEv"]
    pub fn xrt_xclbin_mem_get_index(this: *const xrt_xclbin_mem) -> i32;
}
impl xrt_xclbin_mem {
    #[inline]
    pub unsafe fn get_tag(&self) -> std_string {
        xrt_xclbin_mem_get_tag(self)
    }
    #[inline]
    pub unsafe fn get_base_address(&self) -> u64 {
        xrt_xclbin_mem_get_base_address(self)
    }
    #[inline]
    pub unsafe fn get_size_kb(&self) -> u64 {
        xrt_xclbin_mem_get_size_kb(self)
    }
    #[inline]
    pub unsafe fn get_used(&self) -> bool {
        xrt_xclbin_mem_get_used(self)
    }
    #[inline]
    pub unsafe fn get_type(&self) -> xrt_xclbin_mem_memory_type {
        xrt_xclbin_mem_get_type(self)
    }
    #[inline]
    pub unsafe fn get_index(&self) -> i32 {
        xrt_xclbin_mem_get_index(self)
    }
}
#[doc = " @class arg\n\n @brief\n class arg - xrt::xclbin::arg represents a compute unit argument\n\n @details\n The argument object constructed from the xclbin connectivity\n section.  An argument is connected to a memory bank or a memory\n group, which dictates where in device memory a global buffer\n used with this kernel argument must be allocated."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_arg_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_xclbin_arg {
    pub _base: xrt_detail_pimpl,
}
#[test]
fn bindgen_test_layout_xrt_xclbin_arg() {
    assert_eq!(
        ::std::mem::size_of::<xrt_xclbin_arg>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_xclbin_arg))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_xclbin_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_xclbin_arg))
    );
}
extern "C" {
    #[doc = " get_name() - Get argument name\n\n @return\n  Name of argument.\n"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg8get_nameB5cxx11Ev"]
    pub fn xrt_xclbin_arg_get_name(this: *const xrt_xclbin_arg) -> std_string;
}
extern "C" {
    #[doc = " get_mems() - Get list of device memories from xclbin.\n\n @return\n  A list of xrt::xclbin::mem objects to which this argument\n  is connected."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg8get_memsEv"]
    pub fn xrt_xclbin_arg_get_mems(this: *const xrt_xclbin_arg) -> u8;
}
extern "C" {
    #[doc = " get_port() - Get port name of this argument\n\n @return\n  Port name"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg8get_portB5cxx11Ev"]
    pub fn xrt_xclbin_arg_get_port(this: *const xrt_xclbin_arg) -> std_string;
}
extern "C" {
    #[doc = " get_size() - Argument size in bytes\n\n @return\n   Argument size"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg8get_sizeEv"]
    pub fn xrt_xclbin_arg_get_size(this: *const xrt_xclbin_arg) -> u64;
}
extern "C" {
    #[doc = " get_offset() - Argument offset\n\n @return\n   Argument offset"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg10get_offsetEv"]
    pub fn xrt_xclbin_arg_get_offset(this: *const xrt_xclbin_arg) -> u64;
}
extern "C" {
    #[doc = " get_host_type() - Get the argument host type\n\n @return\n   Argument host type"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg13get_host_typeB5cxx11Ev"]
    pub fn xrt_xclbin_arg_get_host_type(this: *const xrt_xclbin_arg) -> std_string;
}
extern "C" {
    #[doc = " get_index() - Get the index of this argument\n\n @return\n   Argument index"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg9get_indexEv"]
    pub fn xrt_xclbin_arg_get_index(this: *const xrt_xclbin_arg) -> usize;
}
impl xrt_xclbin_arg {
    #[inline]
    pub unsafe fn get_name(&self) -> std_string {
        xrt_xclbin_arg_get_name(self)
    }
    #[inline]
    pub unsafe fn get_mems(&self) -> u8 {
        xrt_xclbin_arg_get_mems(self)
    }
    #[inline]
    pub unsafe fn get_port(&self) -> std_string {
        xrt_xclbin_arg_get_port(self)
    }
    #[inline]
    pub unsafe fn get_size(&self) -> u64 {
        xrt_xclbin_arg_get_size(self)
    }
    #[inline]
    pub unsafe fn get_offset(&self) -> u64 {
        xrt_xclbin_arg_get_offset(self)
    }
    #[inline]
    pub unsafe fn get_host_type(&self) -> std_string {
        xrt_xclbin_arg_get_host_type(self)
    }
    #[inline]
    pub unsafe fn get_index(&self) -> usize {
        xrt_xclbin_arg_get_index(self)
    }
}
#[doc = " @class ip\n\n @brief\n xrt::xclbin::ip represents a IP in an xclbin.\n\n @details\n The ip corresponds to an entry in the IP_LAYOUT section of the\n xclbin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_ip_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_xclbin_ip {
    pub _base: xrt_detail_pimpl,
}
pub const xrt_xclbin_ip_control_type_hs: xrt_xclbin_ip_control_type = 0;
pub const xrt_xclbin_ip_control_type_chain: xrt_xclbin_ip_control_type = 1;
pub const xrt_xclbin_ip_control_type_none: xrt_xclbin_ip_control_type = 2;
pub const xrt_xclbin_ip_control_type_fa: xrt_xclbin_ip_control_type = 5;
#[doc = " @enum control_type -\n\n @details\n See `xclbin.h`"]
pub type xrt_xclbin_ip_control_type = u8;
pub const xrt_xclbin_ip_ip_type_pl: xrt_xclbin_ip_ip_type = 1;
pub const xrt_xclbin_ip_ip_type_ps: xrt_xclbin_ip_ip_type = 7;
#[doc = " @enum ip_type\n\n @details\n See `xclbin.h`"]
pub type xrt_xclbin_ip_ip_type = u8;
#[test]
fn bindgen_test_layout_xrt_xclbin_ip() {
    assert_eq!(
        ::std::mem::size_of::<xrt_xclbin_ip>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_xclbin_ip))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_xclbin_ip>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_xclbin_ip))
    );
}
extern "C" {
    #[doc = " get_name() - Get name of IP\n\n @return\n  IP name."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip8get_nameB5cxx11Ev"]
    pub fn xrt_xclbin_ip_get_name(this: *const xrt_xclbin_ip) -> std_string;
}
extern "C" {
    #[doc = " get_type() - Get the IP type\n\n @return\n  IP type"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip8get_typeEv"]
    pub fn xrt_xclbin_ip_get_type(this: *const xrt_xclbin_ip) -> xrt_xclbin_ip_ip_type;
}
extern "C" {
    #[doc = " get_control_type() - Get the IP control protocol\n\n @return\n  Control type"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip16get_control_typeEv"]
    pub fn xrt_xclbin_ip_get_control_type(this: *const xrt_xclbin_ip)
        -> xrt_xclbin_ip_control_type;
}
extern "C" {
    #[doc = " get_num_args() - Number of arguments\n\n @return\n  Number of arguments for this IP per CONNECTIVITY section"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip12get_num_argsEv"]
    pub fn xrt_xclbin_ip_get_num_args(this: *const xrt_xclbin_ip) -> usize;
}
extern "C" {
    #[doc = " get_args() - Get list of IP arguments\n\n @return\n  A list sorted of xclbin::arg sorted by argument indices\n\n An argument may have multiple memory connections"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip8get_argsEv"]
    pub fn xrt_xclbin_ip_get_args(this: *const xrt_xclbin_ip) -> u8;
}
extern "C" {
    #[doc = " get_arg() - Get argument at index.\n\n @param index\n  Index of argument\n @return\n  The argument a specified index\n\n The argument may have multiple memory connections"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip7get_argEi"]
    pub fn xrt_xclbin_ip_get_arg(this: *const xrt_xclbin_ip, index: i32) -> xrt_xclbin_arg;
}
extern "C" {
    #[doc = " get_base_address() - Get the base address of the cu\n\n @return\n  The base address of the IP"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip16get_base_addressEv"]
    pub fn xrt_xclbin_ip_get_base_address(this: *const xrt_xclbin_ip) -> u64;
}
extern "C" {
    #[doc = " get_size() - Get the address range size of this IP.\n\n @return\n  The size of this IP\n\n The address range is a property of the kernel and\n as such only valid for for kernel compute units.\n\n For IPs that are not associated with a kernel, the\n size return is 0."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip8get_sizeEv"]
    pub fn xrt_xclbin_ip_get_size(this: *const xrt_xclbin_ip) -> usize;
}
impl xrt_xclbin_ip {
    #[inline]
    pub unsafe fn get_name(&self) -> std_string {
        xrt_xclbin_ip_get_name(self)
    }
    #[inline]
    pub unsafe fn get_type(&self) -> xrt_xclbin_ip_ip_type {
        xrt_xclbin_ip_get_type(self)
    }
    #[inline]
    pub unsafe fn get_control_type(&self) -> xrt_xclbin_ip_control_type {
        xrt_xclbin_ip_get_control_type(self)
    }
    #[inline]
    pub unsafe fn get_num_args(&self) -> usize {
        xrt_xclbin_ip_get_num_args(self)
    }
    #[inline]
    pub unsafe fn get_args(&self) -> u8 {
        xrt_xclbin_ip_get_args(self)
    }
    #[inline]
    pub unsafe fn get_arg(&self, index: i32) -> xrt_xclbin_arg {
        xrt_xclbin_ip_get_arg(self, index)
    }
    #[inline]
    pub unsafe fn get_base_address(&self) -> u64 {
        xrt_xclbin_ip_get_base_address(self)
    }
    #[inline]
    pub unsafe fn get_size(&self) -> usize {
        xrt_xclbin_ip_get_size(self)
    }
}
#[doc = " class kernel\n\n @brief\n xrt::xclbin::kernel represents a kernel in an xclbin.\n\n @details\n The kernel corresponds to an entry in the XML meta data section\n of the xclbin combined with meta data from other xclbin sections.\n The kernel object is implicitly constructed from the xclbin\n object via APIs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_kernel_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_xclbin_kernel {
    pub _base: xrt_detail_pimpl,
}
pub const xrt_xclbin_kernel_kernel_type_none: xrt_xclbin_kernel_kernel_type = 0;
pub const xrt_xclbin_kernel_kernel_type_pl: xrt_xclbin_kernel_kernel_type = 1;
pub const xrt_xclbin_kernel_kernel_type_ps: xrt_xclbin_kernel_kernel_type = 2;
pub const xrt_xclbin_kernel_kernel_type_dpu: xrt_xclbin_kernel_kernel_type = 3;
#[doc = " @enum kernel_type\n\n The kernel type is extracted from the XML kernel meta data section"]
pub type xrt_xclbin_kernel_kernel_type = u8;
#[test]
fn bindgen_test_layout_xrt_xclbin_kernel() {
    assert_eq!(
        ::std::mem::size_of::<xrt_xclbin_kernel>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_xclbin_kernel))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_xclbin_kernel>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_xclbin_kernel))
    );
}
extern "C" {
    #[doc = " get_name() - Get kernel name\n\n @return\n  The name of the kernel"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel8get_nameB5cxx11Ev"]
    pub fn xrt_xclbin_kernel_get_name(this: *const xrt_xclbin_kernel) -> std_string;
}
extern "C" {
    #[doc = " get_type() - Get kernel type\n\n @return\n  The type of the kernel"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel8get_typeEv"]
    pub fn xrt_xclbin_kernel_get_type(
        this: *const xrt_xclbin_kernel,
    ) -> xrt_xclbin_kernel_kernel_type;
}
extern "C" {
    #[doc = " get_cus() - Get list of cu from kernel.\n\n @return\n  A list of xrt::xclbin::ip objects corresponding the compute units\n  for this kernel object."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel7get_cusEv"]
    pub fn xrt_xclbin_kernel_get_cus(this: *const xrt_xclbin_kernel) -> u8;
}
extern "C" {
    #[doc = " get_cus() - Get list of compute units that matches name\n\n @param name\n  Name to match against, prefixed with kernel name\n @return\n  A list of xrt::xclbin::ip objects that are compute units\n  of this kernel object and matches the specified name.\n\n The kernel name can optionally specify which kernel instance(s) to\n match \"kernel:{cu1,cu2,...} syntax."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel7get_cusERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_xclbin_kernel_get_cus1(
        this: *const xrt_xclbin_kernel,
        name: *const std_string,
    ) -> u8;
}
extern "C" {
    #[doc = " get_cu() - Get compute unit by name\n\n @return\n  The xct::xclbin::ip object matching the specified name, or error if\n  not present."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel6get_cuERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_xclbin_kernel_get_cu(
        this: *const xrt_xclbin_kernel,
        name: *const std_string,
    ) -> xrt_xclbin_ip;
}
extern "C" {
    #[doc = " get_num_args() - Number of arguments\n\n @return\n  Number of arguments for this kernel."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel12get_num_argsEv"]
    pub fn xrt_xclbin_kernel_get_num_args(this: *const xrt_xclbin_kernel) -> usize;
}
extern "C" {
    #[doc = " get_args() - Get list of kernel arguments\n\n @return\n  A list sorted of xclbin::arg sorted by argument indices\n\n An argument may have multiple memory connections"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel8get_argsEv"]
    pub fn xrt_xclbin_kernel_get_args(this: *const xrt_xclbin_kernel) -> u8;
}
extern "C" {
    #[doc = " get_arg() - Get kernel argument at index.\n\n @return\n  The xrt::xclbin::arg object at specified argument index.\n\n The memory connections of an argument is the union of the\n connections for each compute unit for that particular argument.\n In other words, for each connection of the argument returned\n by ``get_arg()`` there is at least one compute unit that has\n that connection."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel7get_argEi"]
    pub fn xrt_xclbin_kernel_get_arg(this: *const xrt_xclbin_kernel, index: i32) -> xrt_xclbin_arg;
}
impl xrt_xclbin_kernel {
    #[inline]
    pub unsafe fn get_name(&self) -> std_string {
        xrt_xclbin_kernel_get_name(self)
    }
    #[inline]
    pub unsafe fn get_type(&self) -> xrt_xclbin_kernel_kernel_type {
        xrt_xclbin_kernel_get_type(self)
    }
    #[inline]
    pub unsafe fn get_cus(&self) -> u8 {
        xrt_xclbin_kernel_get_cus(self)
    }
    #[inline]
    pub unsafe fn get_cus1(&self, name: *const std_string) -> u8 {
        xrt_xclbin_kernel_get_cus1(self, name)
    }
    #[inline]
    pub unsafe fn get_cu(&self, name: *const std_string) -> xrt_xclbin_ip {
        xrt_xclbin_kernel_get_cu(self, name)
    }
    #[inline]
    pub unsafe fn get_num_args(&self) -> usize {
        xrt_xclbin_kernel_get_num_args(self)
    }
    #[inline]
    pub unsafe fn get_args(&self) -> u8 {
        xrt_xclbin_kernel_get_args(self)
    }
    #[inline]
    pub unsafe fn get_arg(&self, index: i32) -> xrt_xclbin_arg {
        xrt_xclbin_kernel_get_arg(self, index)
    }
}
#[doc = " @cond\n** undocumented access to aie metadata, subject to change **/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_aie_partition_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_xclbin_aie_partition {
    pub _base: xrt_detail_pimpl,
}
#[test]
fn bindgen_test_layout_xrt_xclbin_aie_partition() {
    assert_eq!(
        ::std::mem::size_of::<xrt_xclbin_aie_partition>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_xclbin_aie_partition))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_xclbin_aie_partition>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_xclbin_aie_partition))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3xrt6xclbin13aie_partition25get_inference_fingerprintEv"]
    pub fn xrt_xclbin_aie_partition_get_inference_fingerprint(
        this: *const xrt_xclbin_aie_partition,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3xrt6xclbin13aie_partition24get_pre_post_fingerprintEv"]
    pub fn xrt_xclbin_aie_partition_get_pre_post_fingerprint(
        this: *const xrt_xclbin_aie_partition,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3xrt6xclbin13aie_partition24get_operations_per_cycleEv"]
    pub fn xrt_xclbin_aie_partition_get_operations_per_cycle(
        this: *const xrt_xclbin_aie_partition,
    ) -> u32;
}
impl xrt_xclbin_aie_partition {
    #[inline]
    pub unsafe fn get_inference_fingerprint(&self) -> u64 {
        xrt_xclbin_aie_partition_get_inference_fingerprint(self)
    }
    #[inline]
    pub unsafe fn get_pre_post_fingerprint(&self) -> u64 {
        xrt_xclbin_aie_partition_get_pre_post_fingerprint(self)
    }
    #[inline]
    pub unsafe fn get_operations_per_cycle(&self) -> u32 {
        xrt_xclbin_aie_partition_get_operations_per_cycle(self)
    }
}
#[test]
fn bindgen_test_layout_xrt_xclbin() {
    assert_eq!(
        ::std::mem::size_of::<xrt_xclbin>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_xclbin))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_xclbin>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_xclbin))
    );
}
extern "C" {
    #[doc = " get_kernels() - Get list of kernels from xclbin.\n\n @return\n  A list of xrt::xclbin::kernel from xclbin.\n\n Kernels are extracted from embedded XML metadata in the xclbin.\n A kernel groups one or more compute units. A kernel has arguments\n from which offset, type, etc can be retrived."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin11get_kernelsEv"]
    pub fn xrt_xclbin_get_kernels(this: *const xrt_xclbin) -> u8;
}
extern "C" {
    #[doc = " get_kernel() - Get a kernel by name from xclbin\n\n @param name\n  Name of kernel to get.\n @return\n  The matching kernel from the xclbin or error\n  if no matching kernel is found.\n\n A matching kernel is extracted from embedded XML metadata in the\n xclbin.  A kernel groups one or more compute units. A kernel has\n arguments from which offset, type, etc can be retrived."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin10get_kernelERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_xclbin_get_kernel(
        this: *const xrt_xclbin,
        name: *const std_string,
    ) -> xrt_xclbin_kernel;
}
extern "C" {
    #[doc = " get_ips() - Get a list of IPs from the xclbin\n\n @return\n  A list of xrt::xclbin::ip objects from xclbin.\n\n The returned xrt::xclbin::ip objects are extracted from the\n IP_LAYOUT section of the xclbin."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin7get_ipsEv"]
    pub fn xrt_xclbin_get_ips(this: *const xrt_xclbin) -> u8;
}
extern "C" {
    #[doc = " get_ips() - Get list of ips that matches name\n\n @param name\n  Name to match against, prefixed with kernel name\n @return\n  A list of xrt::xclbin::ip objects that are compute units\n  of this kernel object and matches the specified name.\n\n The kernel name can optionally specify which kernel instance(s) to\n match \"kernel:{ip1,ip2,...} syntax."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin7get_ipsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_xclbin_get_ips1(this: *const xrt_xclbin, name: *const std_string) -> u8;
}
extern "C" {
    #[doc = " get_ip() - Get a specific IP from the xclbin\n\n @return\n  A list of xrt::xclbin::ip objects from xclbin.\n\n The returned xrt::xclbin::ip object is extracted from the\n IP_LAYOUT section of the xclbin."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6get_ipERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_xclbin_get_ip(this: *const xrt_xclbin, name: *const std_string) -> xrt_xclbin_ip;
}
extern "C" {
    #[doc = " get_mems() - Get list of memory objects\n\n @return\n A list of xrt::xclbin::mem objects from xclbin\n\n The returned xrt::xclbin::mem objects are extracted from\n the xclbin."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin8get_memsEv"]
    pub fn xrt_xclbin_get_mems(this: *const xrt_xclbin) -> u8;
}
extern "C" {
    #[doc = " @cond"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin18get_aie_partitionsEv"]
    pub fn xrt_xclbin_get_aie_partitions(this: *const xrt_xclbin) -> u8;
}
extern "C" {
    #[doc = " get_xsa_name() - Get Xilinx Support Archive (XSA) name of xclbin\n\n @return\n  Name of XSA (vbnv name).\n\n An exception is thrown if the data is missing."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin12get_xsa_nameB5cxx11Ev"]
    pub fn xrt_xclbin_get_xsa_name(this: *const xrt_xclbin) -> std_string;
}
extern "C" {
    #[doc = " get_fpga_device_name() - Get FPGA device name\n\n @return\n  Name of fpga device per XML metadata."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin20get_fpga_device_nameB5cxx11Ev"]
    pub fn xrt_xclbin_get_fpga_device_name(this: *const xrt_xclbin) -> std_string;
}
extern "C" {
    #[doc = " get_uuid() - Get the uuid of the xclbin\n\n @return\n  UUID of xclbin\n\n An exception is thrown if the data is missing."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin8get_uuidEv"]
    pub fn xrt_xclbin_get_uuid(this: *const xrt_xclbin) -> xrt_uuid;
}
extern "C" {
    #[doc = " get_interface_uuid() - Get the interface uuid of the xclbin\n\n @return\n  Interface uuid of the xclbin\n\n An exception is thrown if the data is missing."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin18get_interface_uuidEv"]
    pub fn xrt_xclbin_get_interface_uuid(this: *const xrt_xclbin) -> xrt_uuid;
}
extern "C" {
    #[doc = " get_target_type() - Get the type of this xclbin\n\n @return\n  Target type, which can be hw, sw_emu, or hw_emu"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin15get_target_typeEv"]
    pub fn xrt_xclbin_get_target_type(this: *const xrt_xclbin) -> xrt_xclbin_target_type;
}
extern "C" {
    #[doc = " @cond\n**\n* get_axlf() - Get the axlf data of the xclbin\n*\n* @return\n*  The axlf data of the xclbin object\n*\n* An exception is thrown if the data is missing.\n*/"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin8get_axlfEv"]
    pub fn xrt_xclbin_get_axlf(this: *const xrt_xclbin) -> *const axlf;
}
extern "C" {
    #[doc = " xclbin() - Constructor from an xclbin filename\n\n\n @param filename : A path relative or absolute to an xclbin file\n\n If the specified path is an absolute path then the function\n returns this path or throws if file does not exist.  If the path\n is relative, or just a plain file name, then the function check\n first in current directory, then in the platform specific xclbin\n repository.\n\n Throws if file could not be found."]
    #[link_name = "\u{1}_ZN3xrt6xclbinC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_xclbin_xclbin(this: *mut xrt_xclbin, filename: *const std_string);
}
extern "C" {
    #[doc = " xclbin() - Constructor from raw data\n\n @param data\n  Raw data of xclbin\n\n The raw data of the xclbin can be deleted after calling the\n constructor."]
    #[link_name = "\u{1}_ZN3xrt6xclbinC1ERKSt6vectorIcSaIcEE"]
    pub fn xrt_xclbin_xclbin1(this: *mut xrt_xclbin, data: *const u8);
}
extern "C" {
    #[doc = " xclbin() - Constructor from raw data\n\n @param top\n  Raw data of xclbin file as axlf*\n\n The argument axlf is copied by the constructor."]
    #[link_name = "\u{1}_ZN3xrt6xclbinC1EPK4axlf"]
    pub fn xrt_xclbin_xclbin2(this: *mut xrt_xclbin, top: *const axlf);
}
impl xrt_xclbin {
    #[inline]
    pub unsafe fn get_kernels(&self) -> u8 {
        xrt_xclbin_get_kernels(self)
    }
    #[inline]
    pub unsafe fn get_kernel(&self, name: *const std_string) -> xrt_xclbin_kernel {
        xrt_xclbin_get_kernel(self, name)
    }
    #[inline]
    pub unsafe fn get_ips(&self) -> u8 {
        xrt_xclbin_get_ips(self)
    }
    #[inline]
    pub unsafe fn get_ips1(&self, name: *const std_string) -> u8 {
        xrt_xclbin_get_ips1(self, name)
    }
    #[inline]
    pub unsafe fn get_ip(&self, name: *const std_string) -> xrt_xclbin_ip {
        xrt_xclbin_get_ip(self, name)
    }
    #[inline]
    pub unsafe fn get_mems(&self) -> u8 {
        xrt_xclbin_get_mems(self)
    }
    #[inline]
    pub unsafe fn get_aie_partitions(&self) -> u8 {
        xrt_xclbin_get_aie_partitions(self)
    }
    #[inline]
    pub unsafe fn get_xsa_name(&self) -> std_string {
        xrt_xclbin_get_xsa_name(self)
    }
    #[inline]
    pub unsafe fn get_fpga_device_name(&self) -> std_string {
        xrt_xclbin_get_fpga_device_name(self)
    }
    #[inline]
    pub unsafe fn get_uuid(&self) -> xrt_uuid {
        xrt_xclbin_get_uuid(self)
    }
    #[inline]
    pub unsafe fn get_interface_uuid(&self) -> xrt_uuid {
        xrt_xclbin_get_interface_uuid(self)
    }
    #[inline]
    pub unsafe fn get_target_type(&self) -> xrt_xclbin_target_type {
        xrt_xclbin_get_target_type(self)
    }
    #[inline]
    pub unsafe fn get_axlf(&self) -> *const axlf {
        xrt_xclbin_get_axlf(self)
    }
    #[inline]
    pub unsafe fn new(filename: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_xclbin_xclbin(__bindgen_tmp.as_mut_ptr(), filename);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(data: *const u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_xclbin_xclbin1(__bindgen_tmp.as_mut_ptr(), data);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(top: *const axlf) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_xclbin_xclbin2(__bindgen_tmp.as_mut_ptr(), top);
        __bindgen_tmp.assume_init()
    }
}
pub const xrt_info_device_bdf: xrt_info_device = 0;
pub const xrt_info_device_interface_uuid: xrt_info_device = 1;
pub const xrt_info_device_kdma: xrt_info_device = 2;
pub const xrt_info_device_max_clock_frequency_mhz: xrt_info_device = 3;
pub const xrt_info_device_m2m: xrt_info_device = 4;
pub const xrt_info_device_name: xrt_info_device = 5;
pub const xrt_info_device_nodma: xrt_info_device = 6;
pub const xrt_info_device_offline: xrt_info_device = 7;
pub const xrt_info_device_electrical: xrt_info_device = 8;
pub const xrt_info_device_thermal: xrt_info_device = 9;
pub const xrt_info_device_mechanical: xrt_info_device = 10;
pub const xrt_info_device_memory: xrt_info_device = 11;
pub const xrt_info_device_platform: xrt_info_device = 12;
pub const xrt_info_device_pcie_info: xrt_info_device = 13;
pub const xrt_info_device_host: xrt_info_device = 14;
pub const xrt_info_device_aie: xrt_info_device = 15;
pub const xrt_info_device_aie_shim: xrt_info_device = 16;
pub const xrt_info_device_dynamic_regions: xrt_info_device = 17;
pub const xrt_info_device_vmr: xrt_info_device = 18;
pub const xrt_info_device_aie_mem: xrt_info_device = 19;
#[doc = " @enum device\n\n @brief\n Device information parameters\n\n @details\n Use with `xrt::device::get_info()` to retrieve properties of the\n device.  The type of the device properties is compile time defined\n with param traits.\n\n @var bdf\n  BDF for device (std::string)\n @var interface_uuid\n  Interface UUID when device is programmed with 2RP shell (`xrt::uuid`)\n @var kdma\n  Number of KDMA engines (std::uint32_t)\n @var max_clock_frequency_mhz\n  Max clock frequency (unsigned long)\n @var m2m\n  True if device contains m2m (bool)\n @var name\n  Name (VBNV) of device (std::string)\n @var nodma\n  True if device is a NoDMA device (bool)\n @var offline\n  True if device is offline and in process of being reset (bool)\n @var electrical\n  Electrical and power sensors present on the device (std::string)\n @var thermal\n  Thermal sensors present on the device (std::string)\n @var mechanical\n  Mechanical sensors on and surrounding the device (std::string)\n @var memory\n  Memory information present on the device (std::string)\n @var platform\n  Platforms flashed on the device (std::string)\n @var pcie_info\n  Pcie information of the device (std::string)\n @var host\n  Host information (std::string)\n @var aie\n  AIE core information of the device (std::string)\n @var aie_shim\n  AIE shim information of the device (std::string)\n @var dynamic_regions\n  Information about xclbin on the device (std::string)\n @var vmr\n  Information about vmr on the device (std::string)\n @var aie_mem\n  AIE memory information of the device (std::string)"]
pub type xrt_info_device = ::std::os::raw::c_uint;
#[doc = " @class device\n\n @brief\n xrt::device represents used for acceleration."]
#[repr(C)]
#[derive(Debug)]
pub struct xrt_device {
    pub handle: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_xrt_device() {
    const UNINIT: ::std::mem::MaybeUninit<xrt_device> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xrt_device>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_device))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_device>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_device))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xrt_device),
            "::",
            stringify!(handle)
        )
    );
}
extern "C" {
    #[doc = " @cond\n Experimental 2022.2\n**\n* register_xclbin() - Register an xclbin with the device\n*\n* @param xclbin\n*  xrt::xclbin object\n* @return\n*  UUID of argument xclbin\n*\n* This function registers an xclbin with the device, but\n* does not associate the xclbin with hardware resources.\n*/"]
    #[link_name = "\u{1}_ZN3xrt6device15register_xclbinERKNS_6xclbinE"]
    pub fn xrt_device_register_xclbin(this: *mut xrt_device, xclbin: *const xrt_xclbin)
        -> xrt_uuid;
}
extern "C" {
    #[doc = " load_xclbin() - Load an xclbin\n\n @param xclbin\n  Pointer to xclbin in memory image\n @return\n  UUID of argument xclbin"]
    #[link_name = "\u{1}_ZN3xrt6device11load_xclbinEPK4axlf"]
    pub fn xrt_device_load_xclbin(this: *mut xrt_device, xclbin: *const axlf) -> xrt_uuid;
}
extern "C" {
    #[doc = " load_xclbin() - Read and load an xclbin file\n\n @param xclbin_fnm\n  Full path to xclbin file\n @return\n  UUID of argument xclbin\n\n This function reads the file from disk and loads\n the xclbin.   Using this function allows one time\n allocation of data that needs to be kept in memory."]
    #[link_name = "\u{1}_ZN3xrt6device11load_xclbinERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_device_load_xclbin1(
        this: *mut xrt_device,
        xclbin_fnm: *const std_string,
    ) -> xrt_uuid;
}
extern "C" {
    #[doc = " load_xclbin() - load an xclin from an xclbin object\n\n @param xclbin\n  xrt::xclbin object\n @return\n  UUID of argument xclbin\n\n This function uses the specified xrt::xclbin object created by\n caller.  The xrt::xclbin object must contain the complete axlf\n structure."]
    #[link_name = "\u{1}_ZN3xrt6device11load_xclbinERKNS_6xclbinE"]
    pub fn xrt_device_load_xclbin2(this: *mut xrt_device, xclbin: *const xrt_xclbin) -> xrt_uuid;
}
extern "C" {
    #[doc = " get_xclbin_uuid() - Get UUID of xclbin image loaded on device\n\n @return\n  UUID of currently loaded xclbin\n\n Note that current UUID can be different from the UUID of\n the xclbin loaded by this process using load_xclbin()"]
    #[link_name = "\u{1}_ZNK3xrt6device15get_xclbin_uuidEv"]
    pub fn xrt_device_get_xclbin_uuid(this: *const xrt_device) -> xrt_uuid;
}
extern "C" {
    #[link_name = "\u{1}_ZN3xrt6device5resetEv"]
    pub fn xrt_device_reset(this: *mut xrt_device);
}
extern "C" {
    #[doc = " device() - Constructor from device index\n\n @param didx\n  Device index\n\n Throws if no device is found matching the specified index."]
    #[link_name = "\u{1}_ZN3xrt6deviceC1Ej"]
    pub fn xrt_device_device(this: *mut xrt_device, didx: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " device() - Constructor from string\n\n @param bdf\n  String identifying the device to open.\n\n If the string is in BDF format it matched against devices\n installed on the system.  Otherwise the string is assumed\n to be a device index.\n\n Throws if string format is invalid or no matching device is\n found."]
    #[link_name = "\u{1}_ZN3xrt6deviceC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_device_device1(this: *mut xrt_device, bdf: *const std_string);
}
extern "C" {
    #[doc = " device() - Create a managed device object from a shim xclDeviceHandle\n\n @param dhdl\n  Shim xclDeviceHandle\n @return\n  xrt::device object epresenting the opened device, or exception on error"]
    #[link_name = "\u{1}_ZN3xrt6deviceC1EPv"]
    pub fn xrt_device_device2(this: *mut xrt_device, dhdl: xclDeviceHandle);
}
impl xrt_device {
    #[inline]
    pub unsafe fn register_xclbin(&mut self, xclbin: *const xrt_xclbin) -> xrt_uuid {
        xrt_device_register_xclbin(self, xclbin)
    }
    #[inline]
    pub unsafe fn load_xclbin(&mut self, xclbin: *const axlf) -> xrt_uuid {
        xrt_device_load_xclbin(self, xclbin)
    }
    #[inline]
    pub unsafe fn load_xclbin1(&mut self, xclbin_fnm: *const std_string) -> xrt_uuid {
        xrt_device_load_xclbin1(self, xclbin_fnm)
    }
    #[inline]
    pub unsafe fn load_xclbin2(&mut self, xclbin: *const xrt_xclbin) -> xrt_uuid {
        xrt_device_load_xclbin2(self, xclbin)
    }
    #[inline]
    pub unsafe fn get_xclbin_uuid(&self) -> xrt_uuid {
        xrt_device_get_xclbin_uuid(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        xrt_device_reset(self)
    }
    #[inline]
    pub unsafe fn new(didx: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_device_device(__bindgen_tmp.as_mut_ptr(), didx);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(bdf: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_device_device1(__bindgen_tmp.as_mut_ptr(), bdf);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(dhdl: xclDeviceHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_device_device2(__bindgen_tmp.as_mut_ptr(), dhdl);
        __bindgen_tmp.assume_init()
    }
}
pub type xrt_memory_group = xrtMemoryGroup;
#[doc = " @struct pid_type\n\n @brief\n Typed pid_t used to prevent ambiguity when contructing\n bo with a process id.\n\n @details\n Use xrt::bo bo{..., pid_type{pid}, ...};"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_pid_type {
    pub pid: pid_t,
}
#[test]
fn bindgen_test_layout_xrt_pid_type() {
    const UNINIT: ::std::mem::MaybeUninit<xrt_pid_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xrt_pid_type>(),
        4usize,
        concat!("Size of: ", stringify!(xrt_pid_type))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_pid_type>(),
        4usize,
        concat!("Alignment of ", stringify!(xrt_pid_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xrt_pid_type),
            "::",
            stringify!(pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_bo_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_bo {
    #[doc = " @endcond"]
    pub handle: [u64; 2usize],
}
#[doc = " @class async_handle\n\n @brief\n xrt::bo::async_handle represents an asynchronously operation\n\n @details\n A handle object is returned from asynchronous buffer object\n operations.  It can be used to wait for the operation to\n complete."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_bo_async_handle_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_bo_async_handle {
    pub _base: xrt_detail_pimpl,
}
#[test]
fn bindgen_test_layout_xrt_bo_async_handle() {
    assert_eq!(
        ::std::mem::size_of::<xrt_bo_async_handle>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_bo_async_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_bo_async_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_bo_async_handle))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3xrt2bo12async_handle4waitEv"]
    pub fn xrt_bo_async_handle_wait(this: *mut xrt_bo_async_handle);
}
impl xrt_bo_async_handle {
    #[inline]
    pub unsafe fn wait(&mut self) {
        xrt_bo_async_handle_wait(self)
    }
}
pub const xrt_bo_flags_normal: xrt_bo_flags = 0;
pub const xrt_bo_flags_cacheable: xrt_bo_flags = 16777216;
pub const xrt_bo_flags_device_only: xrt_bo_flags = 268435456;
pub const xrt_bo_flags_host_only: xrt_bo_flags = 536870912;
pub const xrt_bo_flags_p2p: xrt_bo_flags = 1073741824;
pub const xrt_bo_flags_svm: xrt_bo_flags = 134217728;
#[doc = " @enum flags - buffer object flags\n\n @var normal\n  Create normal BO with host side and device side buffers\n @var cacheable\n  Create cacheable BO.  Only effective on embedded platforms.\n @var device_only\n  Create a BO with a device side buffer only\n @var host_only\n  Create a BO with a host side buffer only\n @var p2p\n  Create a BO for peer-to-peer use\n @var svm\n  Create a BO for SVM (supported on specific platforms only)\n\n The flags used by xrt::bo are compatible with XCL style\n flags as define in ``xrt_mem.h``"]
pub type xrt_bo_flags = u32;
#[test]
fn bindgen_test_layout_xrt_bo() {
    const UNINIT: ::std::mem::MaybeUninit<xrt_bo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xrt_bo>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_bo))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_bo>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_bo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xrt_bo),
            "::",
            stringify!(handle)
        )
    );
}
extern "C" {
    #[doc = " size() - Get the size of this buffer\n\n @return\n  Size of buffer in bytes"]
    #[link_name = "\u{1}_ZNK3xrt2bo4sizeEv"]
    pub fn xrt_bo_size(this: *const xrt_bo) -> usize;
}
extern "C" {
    #[doc = " address() - Get the device address of this buffer\n\n @return\n  Device address of buffer"]
    #[link_name = "\u{1}_ZNK3xrt2bo7addressEv"]
    pub fn xrt_bo_address(this: *const xrt_bo) -> u64;
}
extern "C" {
    #[doc = " get_memory_group() - Get the memory group in which this buffer is allocated\n\n @return\n  Memory group index with which the buffer was constructed"]
    #[link_name = "\u{1}_ZNK3xrt2bo16get_memory_groupEv"]
    pub fn xrt_bo_get_memory_group(this: *const xrt_bo) -> xrt_memory_group;
}
extern "C" {
    #[doc = " get_flags() - Get the flags with which this buffer was constructed\n\n @return\n  The xrt::bo::Flgas used when the buffer was contructed"]
    #[link_name = "\u{1}_ZNK3xrt2bo9get_flagsEv"]
    pub fn xrt_bo_get_flags(this: *const xrt_bo) -> xrt_bo_flags;
}
extern "C" {
    #[doc = " buffer_export() - Export this buffer\n\n @return\n  Exported buffer handle\n\n An exported buffer can be imported on another device by this\n process or another process. For multiprocess transfer, the exported\n buffer must be transferred through a proper IPC facility to translate\n the underlying file-descriptor properly into another process.\n\n The lifetime of the exported buffer handle is associated with the\n exporting buffer (this).  The handle is disposed of when the\n exporting buffer is destructed.\n\n It is undefined behavior to use the export handle after the\n exporting buffer object has gone out of scope."]
    #[link_name = "\u{1}_ZN3xrt2bo13export_bufferEv"]
    pub fn xrt_bo_export_buffer(this: *mut xrt_bo) -> xclBufferExportHandle;
}
extern "C" {
    #[doc = " async() - Start buffer content txfer with device side\n\n @param dir\n  To device or from device\n @param sz\n  Size of data to synchronize\n @param offset\n  Offset within the BO\n\n Asynchronously transfer specified size bytes of buffer\n starting at specified offset."]
    #[link_name = "\u{1}_ZN3xrt2bo5asyncE18xclBOSyncDirectionmm"]
    pub fn xrt_bo_async(
        this: *mut xrt_bo,
        dir: xclBOSyncDirection,
        sz: usize,
        offset: usize,
    ) -> xrt_bo_async_handle;
}
extern "C" {
    #[doc = " sync() - Synchronize buffer content with device side\n\n @param dir\n  To device or from device\n @param sz\n  Size of data to synchronize\n @param offset\n  Offset within the BO\n\n Sync specified size bytes of buffer starting at specified offset."]
    #[link_name = "\u{1}_ZN3xrt2bo4syncE18xclBOSyncDirectionmm"]
    pub fn xrt_bo_sync(this: *mut xrt_bo, dir: xclBOSyncDirection, sz: usize, offset: usize);
}
extern "C" {
    #[doc = " map() - Map the host side buffer into application\n\n @return\n  Memory mapped buffer\n\n Map the contents of the buffer object into host memory"]
    #[link_name = "\u{1}_ZN3xrt2bo3mapEv"]
    pub fn xrt_bo_map(this: *mut xrt_bo) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " write() - Copy-in user data to host backing storage of BO\n\n @param src\n  Source data pointer\n @param size\n  Size of data to copy\n @param seek\n  Offset within the BO\n\n Copy source data to host buffer of this buffer object.\n ``seek`` specifies how many bytes to skip at the beginning\n of the BO before copying-in ``size`` bytes to host buffer.\n\n If BO has no host backing storage, e.g. a device only buffer,\n then write is directly to the device buffer."]
    #[link_name = "\u{1}_ZN3xrt2bo5writeEPKvmm"]
    pub fn xrt_bo_write(
        this: *mut xrt_bo,
        src: *const ::std::os::raw::c_void,
        size: usize,
        seek: usize,
    );
}
extern "C" {
    #[doc = " read() - Copy-out user data from host backing storage of BO\n\n @param dst\n  Destination data pointer\n @param size\n  Size of data to copy\n @param skip\n  Offset within the BO\n\n Copy content of host buffer of this buffer object to specified\n destination.  ``skip`` specifies how many bytes to skip from the\n beginning of the BO before copying-out ``size`` bytes of host\n buffer.\n\n If BO has no host backing storage, e.g. a device only buffer,\n then read is directly from the device buffer."]
    #[link_name = "\u{1}_ZN3xrt2bo4readEPvmm"]
    pub fn xrt_bo_read(
        this: *mut xrt_bo,
        dst: *mut ::std::os::raw::c_void,
        size: usize,
        skip: usize,
    );
}
extern "C" {
    #[doc = " copy() - Deep copy BO content from another buffer\n\n @param src\n  Source BO to copy from\n @param sz\n  Size of data to copy\n @param src_offset\n  Offset into src buffer copy from\n @param dst_offset\n  Offset into this buffer to copy to\n\n Throws if copy size is 0 or sz + src/dst_offset is out of bounds."]
    #[link_name = "\u{1}_ZN3xrt2bo4copyERKS0_mmm"]
    pub fn xrt_bo_copy(
        this: *mut xrt_bo,
        src: *const xrt_bo,
        sz: usize,
        src_offset: usize,
        dst_offset: usize,
    );
}
extern "C" {
    #[doc = " bo() - Constructor with user host buffer and flags\n\n @param device\n  The device on which to allocate this buffer\n @param userptr\n  Pointer to aligned user memory\n @param sz\n  Size of buffer\n @param flags\n  Specify type of buffer\n @param grp\n  Device memory group to allocate buffer in\n\n The device memory group depends on connectivity.  If the buffer\n as a kernel argument, then the memory group can be obtained from\n the xrt::kernel object."]
    #[link_name = "\u{1}_ZN3xrt2boC1ERKNS_6deviceEPvmNS0_5flagsEj"]
    pub fn xrt_bo_bo(
        this: *mut xrt_bo,
        device: *const xrt_device,
        userptr: *mut ::std::os::raw::c_void,
        sz: usize,
        flags: xrt_bo_flags,
        grp: xrt_memory_group,
    );
}
extern "C" {
    #[doc = " bo() - Constructor with user host buffer and default flags\n\n @param device\n  The device on which to allocate this buffer\n @param userptr\n  Pointer to aligned user memory\n @param sz\n  Size of buffer\n @param grp\n  Device memory group to allocate buffer in\n\n The device memory group depends on connectivity.  If the buffer\n as a kernel argument, then the memory group can be obtained from\n the xrt::kernel object."]
    #[link_name = "\u{1}_ZN3xrt2boC1ERKNS_6deviceEPvmj"]
    pub fn xrt_bo_bo1(
        this: *mut xrt_bo,
        device: *const xrt_device,
        userptr: *mut ::std::os::raw::c_void,
        sz: usize,
        grp: xrt_memory_group,
    );
}
extern "C" {
    #[doc = " bo() - Constructor where XRT manages host buffer if needed\n\n @param device\n  The device on which to allocate this buffer\n @param sz\n  Size of buffer\n @param flags\n  Specify type of buffer\n @param grp\n  Device memory group to allocate buffer in\n\n The device memory group depends on connectivity.  If the buffer\n as a kernel argument, then the memory group can be obtained from\n the xrt::kernel object."]
    #[link_name = "\u{1}_ZN3xrt2boC1ERKNS_6deviceEmNS0_5flagsEj"]
    pub fn xrt_bo_bo2(
        this: *mut xrt_bo,
        device: *const xrt_device,
        sz: usize,
        flags: xrt_bo_flags,
        grp: xrt_memory_group,
    );
}
extern "C" {
    #[doc = " bo() - Constructor, default flags, where XRT manages host buffer if any\n\n @param device\n  The device on which to allocate this buffer\n @param sz\n  Size of buffer\n @param flags\n  Specify type of buffer\n @param grp\n  Device memory group to allocate buffer in\n\n The device memory group depends on connectivity.  If the buffer\n as a kernel argument, then the memory group can be obtained from\n the xrt::kernel object."]
    #[link_name = "\u{1}_ZN3xrt2boC1ERKNS_6deviceEmj"]
    pub fn xrt_bo_bo3(
        this: *mut xrt_bo,
        device: *const xrt_device,
        sz: usize,
        grp: xrt_memory_group,
    );
}
extern "C" {
    #[doc = " bo() - Constructor with user host buffer and flags\n\n @param hwctx\n  The hardware context in which to allocate this buffer\n @param userptr\n  Pointer to aligned user memory\n @param sz\n  Size of buffer\n @param flags\n  Specify type of buffer\n @param grp\n  Device memory group to allocate buffer in\n\n The device memory group depends on connectivity.  If the buffer\n as a kernel argument, then the memory group can be obtained from\n the xrt::kernel object."]
    #[link_name = "\u{1}_ZN3xrt2boC1ERKNS_10hw_contextEPvmNS0_5flagsEj"]
    pub fn xrt_bo_bo4(
        this: *mut xrt_bo,
        hwctx: *const xrt_hw_context,
        userptr: *mut ::std::os::raw::c_void,
        sz: usize,
        flags: xrt_bo_flags,
        grp: xrt_memory_group,
    );
}
extern "C" {
    #[doc = " bo() - Constructor with user host buffer and default flags\n\n @param hwctx\n  The hardware context in which to allocate this buffer\n @param userptr\n  Pointer to aligned user memory\n @param sz\n  Size of buffer\n @param grp\n  Device memory group to allocate buffer in\n\n The device memory group depends on connectivity.  If the buffer\n as a kernel argument, then the memory group can be obtained from\n the xrt::kernel object."]
    #[link_name = "\u{1}_ZN3xrt2boC1ERKNS_10hw_contextEPvmj"]
    pub fn xrt_bo_bo5(
        this: *mut xrt_bo,
        hwctx: *const xrt_hw_context,
        userptr: *mut ::std::os::raw::c_void,
        sz: usize,
        grp: xrt_memory_group,
    );
}
extern "C" {
    #[doc = " bo() - Constructor where XRT manages host buffer if needed\n\n @param hwctx\n  The hardware context in which to allocate this buffer\n @param sz\n  Size of buffer\n @param flags\n  Specify type of buffer\n @param grp\n  Device memory group to allocate buffer in\n\n The device memory group depends on connectivity.  If the buffer\n as a kernel argument, then the memory group can be obtained from\n the xrt::kernel object."]
    #[link_name = "\u{1}_ZN3xrt2boC1ERKNS_10hw_contextEmNS0_5flagsEj"]
    pub fn xrt_bo_bo6(
        this: *mut xrt_bo,
        hwctx: *const xrt_hw_context,
        sz: usize,
        flags: xrt_bo_flags,
        grp: xrt_memory_group,
    );
}
extern "C" {
    #[doc = " bo() - Constructor, default flags, where XRT manages host buffer if any\n\n @param hwctx\n  The hardware context in which to allocate this buffer\n @param sz\n  Size of buffer\n @param flags\n  Specify type of buffer\n @param grp\n  Device memory group to allocate buffer in\n\n The device memory group depends on connectivity.  If the buffer\n as a kernel argument, then the memory group can be obtained from\n the xrt::kernel object."]
    #[link_name = "\u{1}_ZN3xrt2boC1ERKNS_10hw_contextEmj"]
    pub fn xrt_bo_bo7(
        this: *mut xrt_bo,
        hwctx: *const xrt_hw_context,
        sz: usize,
        grp: xrt_memory_group,
    );
}
extern "C" {
    #[doc = " @cond"]
    #[link_name = "\u{1}_ZN3xrt2boC1EPvS1_mNS0_5flagsEj"]
    pub fn xrt_bo_bo8(
        this: *mut xrt_bo,
        dhdl: xclDeviceHandle,
        userptr: *mut ::std::os::raw::c_void,
        sz: usize,
        flags: xrt_bo_flags,
        grp: xrt_memory_group,
    );
}
extern "C" {
    #[doc = " @cond"]
    #[link_name = "\u{1}_ZN3xrt2boC1EPvmNS0_5flagsEj"]
    pub fn xrt_bo_bo9(
        this: *mut xrt_bo,
        dhdl: xclDeviceHandle,
        size: usize,
        flags: xrt_bo_flags,
        grp: xrt_memory_group,
    );
}
extern "C" {
    #[doc = " bo() - Constructor to import an exported buffer\n\n @param dhdl\n  Device that imports the exported buffer\n @param ehdl\n  Exported buffer handle, implementation specific type\n\n If the exported buffer handle acquired by using the export() method is\n from another process, then it must be transferred through proper IPC\n mechanism translating the underlying file-descriptor asscociated with\n the buffer, see also constructor taking process id as argument."]
    #[link_name = "\u{1}_ZN3xrt2boC1EPvi"]
    pub fn xrt_bo_bo10(this: *mut xrt_bo, dhdl: xclDeviceHandle, ehdl: xclBufferExportHandle);
}
extern "C" {
    #[doc = " bo() - Constructor to import an exported buffer from another process\n\n @param dhdl\n  Device that imports the exported buffer\n @param pid\n  Process id of exporting process\n @param ehdl\n  Exported buffer handle, implementation specific type\n\n The exported buffer handle is obtained from exporting process by\n calling `export()`. This contructor requires that XRT is built on\n and running on a system with pidfd support.  Also the importing\n process must have permission to duplicate the exporting process'\n file descriptor.  This permission is controlled by ptrace access\n mode PTRACE_MODE_ATTACH_REALCREDS check (see ptrace(2))."]
    #[link_name = "\u{1}_ZN3xrt2boC1EPvNS_8pid_typeEi"]
    pub fn xrt_bo_bo11(
        this: *mut xrt_bo,
        dhdl: xclDeviceHandle,
        pid: xrt_pid_type,
        ehdl: xclBufferExportHandle,
    );
}
extern "C" {
    #[doc = " bo() - Constructor for sub-buffer\n\n @param parent\n  Parent buffer\n @param size\n  Size of sub-buffer\n @param offset\n  Offset into parent buffer"]
    #[link_name = "\u{1}_ZN3xrt2boC1ERKS0_mm"]
    pub fn xrt_bo_bo12(this: *mut xrt_bo, parent: *const xrt_bo, size: usize, offset: usize);
}
extern "C" {
    #[doc = " @cond\n**\n* bo() - Constructor from xclBufferHandle\n*\n* @param dhdl\n*  Device on which the buffer handle was created\n* @param xhdl\n*  Typified shim buffer handle created with xclAllocBO variants\n*\n* This function allows construction of xrt::bo object from an\n* xclBufferHandle supposedly allocated using deprecated xcl APIs.\n* The buffer handle is allocated with xclAllocBO and must be\n* freed with xclFreeBO.\n*\n* Note that argument xclBufferHandle must be wrapped as\n* an xcl_buffer_handle in order to disambiguate the untyped\n* xclBufferHandle.\n*\n* Mixing xcl style APIs and xrt APIs is discouraged and\n* as such this documentation is not included in doxygen.\n*/"]
    #[link_name = "\u{1}_ZN3xrt2boC1EPv17xcl_buffer_handle"]
    pub fn xrt_bo_bo13(this: *mut xrt_bo, dhdl: xclDeviceHandle, xhdl: xcl_buffer_handle);
}
extern "C" {
    #[link_name = "\u{1}_ZN3xrt2boC1EPv"]
    pub fn xrt_bo_bo14(this: *mut xrt_bo, arg1: xrtBufferHandle);
}
impl xrt_bo {
    #[inline]
    pub unsafe fn size(&self) -> usize {
        xrt_bo_size(self)
    }
    #[inline]
    pub unsafe fn address(&self) -> u64 {
        xrt_bo_address(self)
    }
    #[inline]
    pub unsafe fn get_memory_group(&self) -> xrt_memory_group {
        xrt_bo_get_memory_group(self)
    }
    #[inline]
    pub unsafe fn get_flags(&self) -> xrt_bo_flags {
        xrt_bo_get_flags(self)
    }
    #[inline]
    pub unsafe fn export_buffer(&mut self) -> xclBufferExportHandle {
        xrt_bo_export_buffer(self)
    }
    #[inline]
    pub unsafe fn async_(
        &mut self,
        dir: xclBOSyncDirection,
        sz: usize,
        offset: usize,
    ) -> xrt_bo_async_handle {
        xrt_bo_async(self, dir, sz, offset)
    }
    #[inline]
    pub unsafe fn sync(&mut self, dir: xclBOSyncDirection, sz: usize, offset: usize) {
        xrt_bo_sync(self, dir, sz, offset)
    }
    #[inline]
    pub unsafe fn map(&mut self) -> *mut ::std::os::raw::c_void {
        xrt_bo_map(self)
    }
    #[inline]
    pub unsafe fn write(&mut self, src: *const ::std::os::raw::c_void, size: usize, seek: usize) {
        xrt_bo_write(self, src, size, seek)
    }
    #[inline]
    pub unsafe fn read(&mut self, dst: *mut ::std::os::raw::c_void, size: usize, skip: usize) {
        xrt_bo_read(self, dst, size, skip)
    }
    #[inline]
    pub unsafe fn copy(
        &mut self,
        src: *const xrt_bo,
        sz: usize,
        src_offset: usize,
        dst_offset: usize,
    ) {
        xrt_bo_copy(self, src, sz, src_offset, dst_offset)
    }
    #[inline]
    pub unsafe fn new(
        device: *const xrt_device,
        userptr: *mut ::std::os::raw::c_void,
        sz: usize,
        flags: xrt_bo_flags,
        grp: xrt_memory_group,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo(__bindgen_tmp.as_mut_ptr(), device, userptr, sz, flags, grp);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        device: *const xrt_device,
        userptr: *mut ::std::os::raw::c_void,
        sz: usize,
        grp: xrt_memory_group,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo1(__bindgen_tmp.as_mut_ptr(), device, userptr, sz, grp);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        device: *const xrt_device,
        sz: usize,
        flags: xrt_bo_flags,
        grp: xrt_memory_group,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo2(__bindgen_tmp.as_mut_ptr(), device, sz, flags, grp);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(device: *const xrt_device, sz: usize, grp: xrt_memory_group) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo3(__bindgen_tmp.as_mut_ptr(), device, sz, grp);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(
        hwctx: *const xrt_hw_context,
        userptr: *mut ::std::os::raw::c_void,
        sz: usize,
        flags: xrt_bo_flags,
        grp: xrt_memory_group,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo4(__bindgen_tmp.as_mut_ptr(), hwctx, userptr, sz, flags, grp);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(
        hwctx: *const xrt_hw_context,
        userptr: *mut ::std::os::raw::c_void,
        sz: usize,
        grp: xrt_memory_group,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo5(__bindgen_tmp.as_mut_ptr(), hwctx, userptr, sz, grp);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(
        hwctx: *const xrt_hw_context,
        sz: usize,
        flags: xrt_bo_flags,
        grp: xrt_memory_group,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo6(__bindgen_tmp.as_mut_ptr(), hwctx, sz, flags, grp);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new7(hwctx: *const xrt_hw_context, sz: usize, grp: xrt_memory_group) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo7(__bindgen_tmp.as_mut_ptr(), hwctx, sz, grp);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new8(
        dhdl: xclDeviceHandle,
        userptr: *mut ::std::os::raw::c_void,
        sz: usize,
        flags: xrt_bo_flags,
        grp: xrt_memory_group,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo8(__bindgen_tmp.as_mut_ptr(), dhdl, userptr, sz, flags, grp);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new9(
        dhdl: xclDeviceHandle,
        size: usize,
        flags: xrt_bo_flags,
        grp: xrt_memory_group,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo9(__bindgen_tmp.as_mut_ptr(), dhdl, size, flags, grp);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new10(dhdl: xclDeviceHandle, ehdl: xclBufferExportHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo10(__bindgen_tmp.as_mut_ptr(), dhdl, ehdl);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new11(
        dhdl: xclDeviceHandle,
        pid: xrt_pid_type,
        ehdl: xclBufferExportHandle,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo11(__bindgen_tmp.as_mut_ptr(), dhdl, pid, ehdl);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new12(parent: *const xrt_bo, size: usize, offset: usize) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo12(__bindgen_tmp.as_mut_ptr(), parent, size, offset);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new13(dhdl: xclDeviceHandle, xhdl: xcl_buffer_handle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo13(__bindgen_tmp.as_mut_ptr(), dhdl, xhdl);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new14(arg1: xrtBufferHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_bo_bo14(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " class exception -- XRT specific exceptions\n\n In most APIs errors are propagated as std::exception or\n mostly as std::system_error with error codes corresponding to\n POSIX error codes.\n\n Specific non standard system errors are defined as a specific\n xrt::exception, which in turn is derived from a std::exception."]
#[repr(C)]
#[derive(Debug)]
pub struct xrt_exception {
    pub _base: std_exception,
}
#[test]
fn bindgen_test_layout_xrt_exception() {
    assert_eq!(
        ::std::mem::size_of::<xrt_exception>(),
        8usize,
        concat!("Size of: ", stringify!(xrt_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_exception))
    );
}
#[doc = " @class fence\n\n @brief\n Fence object for synchronization of operations\n\n @details\n A fence object is used to synchronize operations between\n run objects.\n\n A fence object should be signaled by one run object and waited on\n by other run objects.  The fence represents the expected next state\n of a run object, it is enqueued as a wait for one or more run\n objects, and it is signaled upon completion of the run on which is\n was enqueued.\n\n The fence object has state that represents the next value (fence\n id) of an enqueued operation and is has state that represents the\n corresponding value to wait for. Both the next and the expected\n value is incremented when the fence is signaled or waited upon, and\n therefore a fence should be copied if more than one operation is\n dependent on it.  A fence should never be signaled by more than one\n run object.\n\n A fence object can be exported for use by another process. This\n allows setting up a pipeline of operations between processes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_fence_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_fence {
    pub _base: xrt_detail_pimpl,
}
pub type xrt_fence_export_handle = ::std::os::raw::c_int;
pub const xrt_fence_access_mode_local: xrt_fence_access_mode = 0;
pub const xrt_fence_access_mode_shared: xrt_fence_access_mode = 1;
pub const xrt_fence_access_mode_process: xrt_fence_access_mode = 2;
#[doc = " @enum access_mode - buffer object accessibility\n\n @var local\n   Access is local to process and device on which it is allocated\n @var shared\n   Access is shared between devices within process\n @var process\n   Access is shared between processes and devices"]
pub type xrt_fence_access_mode = u8;
#[test]
fn bindgen_test_layout_xrt_fence() {
    assert_eq!(
        ::std::mem::size_of::<xrt_fence>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_fence))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_fence>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_fence))
    );
}
extern "C" {
    #[doc = " export_fence() - Export fence object to another process\n\n @return\n  Exported fence handle, implementation specific type.  This\n  exported handle can be imported by another process"]
    #[link_name = "\u{1}_ZN3xrt5fence12export_fenceEv"]
    pub fn xrt_fence_export_fence(this: *mut xrt_fence) -> xrt_fence_export_handle;
}
extern "C" {
    #[doc = " wait() - Wait for fence to be signaled\n\n @paramm timeout Timeout for wait.  A value of 0, implies block\n  until completes.\n @return std::cv_status::no_timeout when wait\n  completes succesfully.  std::cv_status::timeout when wait times\n  out.\n\n Throws on error (to-be-defined)\n\n Wait for fence to be signaled at its current value. This is\n CPU blocking operation."]
    #[link_name = "\u{1}_ZN3xrt5fence4waitERKNSt6chrono8durationIlSt5ratioILl1ELl1000EEEE"]
    pub fn xrt_fence_wait(
        this: *mut xrt_fence,
        timeout: *const std_chrono_milliseconds,
    ) -> std_cv_status;
}
extern "C" {
    #[doc = " get_access_mode() - Return the mode of access for the fence\n\n See access mode.  Only process level fence objects can be\n exported."]
    #[link_name = "\u{1}_ZNK3xrt5fence15get_access_modeEv"]
    pub fn xrt_fence_get_access_mode(this: *const xrt_fence) -> xrt_fence_access_mode;
}
extern "C" {
    #[doc = " get_next_state() - Return the next state of the fence\n\n The next state is the value that the fence will be set to when it\n is signaled and it is the value that will be waited on when the\n fence is submitted for wait.  The next state is incremented each\n time the fence is signaled or waited on."]
    #[link_name = "\u{1}_ZNK3xrt5fence14get_next_stateEv"]
    pub fn xrt_fence_get_next_state(this: *const xrt_fence) -> u64;
}
extern "C" {
    #[doc = " fence() - Constructor for fence object with specific access\n\n @param device\n  The device on which to allocate this fence\n @param access\n  Specific access mode for the buffer (see `enum access_mode`)\n\n The fence object should be signaled by one run object and waited\n on by other run objects.  The fence represents the expected next\n state of a run object, it is enqueued as a wait for one or\n more run objects, and it is signaled upon completion of the run\n on which is was enqueued.\n\n The fence object has state that represents the next value (fence\n id) of an enqueued operation and is has state that represents the\n corresponding value to wait for. Both the next and the expected\n value is incremented when the fence is signaled or waited upon,\n and therefore a fence should be copied if more than one operation\n is dependent on it.  A fence should never be signaled by more\n than one run object."]
    #[link_name = "\u{1}_ZN3xrt5fenceC1ERKNS_6deviceENS0_11access_modeE"]
    pub fn xrt_fence_fence(
        this: *mut xrt_fence,
        device: *const xrt_device,
        access: xrt_fence_access_mode,
    );
}
extern "C" {
    #[doc = " fence() - Constructor to import an exported fence\n\n @param pid\n  Process id of exporting process\n @param ehdl\n  Exported fence handle, implementation specific type\n\n The exported fence handle is obtained from exporting process by\n calling `export_fence()` on the fence to be exported."]
    #[link_name = "\u{1}_ZN3xrt5fenceC1ERKNS_6deviceENS_8pid_typeEi"]
    pub fn xrt_fence_fence1(
        this: *mut xrt_fence,
        device: *const xrt_device,
        pid: xrt_pid_type,
        ehdl: xrt_fence_export_handle,
    );
}
extern "C" {
    #[doc = " fence() - Copy constructor\n\n Creates a new fence object that is a copy of the other fence.\n There is no shared state between the two fence objects.\n\n The copy constructor is used when a fence is to be waited on by\n more than one consumer.  Since the fence has state that increments\n at each wait submission, the fence should be copied if more than\n one consumer is to wait on it."]
    #[link_name = "\u{1}_ZN3xrt5fenceC1ERKS0_"]
    pub fn xrt_fence_fence2(this: *mut xrt_fence, other: *const xrt_fence);
}
extern "C" {
    #[doc = " fence() - Move constructor\n\n Move constructor.  The other fence object is left in an\n unspecified state."]
    #[link_name = "\u{1}_ZN3xrt5fenceC1EOS0_"]
    pub fn xrt_fence_fence3(this: *mut xrt_fence, other: *mut xrt_fence);
}
extern "C" {
    #[doc = "@cond"]
    #[link_name = "\u{1}_ZN3xrt5fenceC1ESt10unique_ptrIN8xrt_core12fence_handleESt14default_deleteIS3_EE"]
    pub fn xrt_fence_fence4(this: *mut xrt_fence, handle: u8);
}
impl xrt_fence {
    #[inline]
    pub unsafe fn export_fence(&mut self) -> xrt_fence_export_handle {
        xrt_fence_export_fence(self)
    }
    #[inline]
    pub unsafe fn wait(&mut self, timeout: *const std_chrono_milliseconds) -> std_cv_status {
        xrt_fence_wait(self, timeout)
    }
    #[inline]
    pub unsafe fn get_access_mode(&self) -> xrt_fence_access_mode {
        xrt_fence_get_access_mode(self)
    }
    #[inline]
    pub unsafe fn get_next_state(&self) -> u64 {
        xrt_fence_get_next_state(self)
    }
    #[inline]
    pub unsafe fn new(device: *const xrt_device, access: xrt_fence_access_mode) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_fence_fence(__bindgen_tmp.as_mut_ptr(), device, access);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        device: *const xrt_device,
        pid: xrt_pid_type,
        ehdl: xrt_fence_export_handle,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_fence_fence1(__bindgen_tmp.as_mut_ptr(), device, pid, ehdl);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(other: *const xrt_fence) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_fence_fence2(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(other: *mut xrt_fence) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_fence_fence3(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(handle: u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_fence_fence4(__bindgen_tmp.as_mut_ptr(), handle);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " class hw_context -- manage hw resources\n\n A hardware context associates an xclbin with hardware\n resources.  Prior to creating a context, the xclbin\n must be registered with the device (`xrt::device::register_xclbin`)\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_hw_context_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_hw_context {
    pub _base: xrt_detail_pimpl,
}
#[doc = " Experimental specification of Configuration Parameters which contains QoS and Communication Channel requirements\n\n Free formed key-value entry.\n\n Supported keys are:\n  - gops                   // giga operations per second\n  - fps                    // frames per second\n  - dma_bandwidth          // gigabytes per second\n  - latency                // ??\n  - frame_execution_time   // ??\n  - priority               // ??\n  - enable_isp_channel     // toggle isp communication\n  - enable_acp_channel     // toggle acp communication\n\n Currently ignored for legacy platforms"]
pub type xrt_hw_context_cfg_param_type = [u64; 6usize];
pub type xrt_hw_context_qos_type = xrt_hw_context_cfg_param_type;
pub const xrt_hw_context_access_mode_exclusive: xrt_hw_context_access_mode = 0;
pub const xrt_hw_context_access_mode_shared: xrt_hw_context_access_mode = 1;
#[doc = " @enum access_mode - legacy access mode\n\n @var exclusive\n  Create a context for exclusive access to shareable resources.\n  Legacy compute unit access control.\n @var shared\n  Create a context for shared access to shareable resources\n  Legacy compute unit access control.\n\n Access mode is mutually exclusive with qos"]
pub type xrt_hw_context_access_mode = u8;
#[test]
fn bindgen_test_layout_xrt_hw_context() {
    assert_eq!(
        ::std::mem::size_of::<xrt_hw_context>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_hw_context))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_hw_context>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_hw_context))
    );
}
extern "C" {
    #[doc = "@cond"]
    #[link_name = "\u{1}_ZN3xrt10hw_context10update_qosERKSt3mapINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEjSt4lessIS7_ESaISt4pairIKS7_jEEE"]
    pub fn xrt_hw_context_update_qos(
        this: *mut xrt_hw_context,
        qos: *const xrt_hw_context_qos_type,
    );
}
extern "C" {
    #[doc = " get_device() - Device from which context was created"]
    #[link_name = "\u{1}_ZNK3xrt10hw_context10get_deviceEv"]
    pub fn xrt_hw_context_get_device(this: *const xrt_hw_context) -> xrt_device;
}
extern "C" {
    #[doc = " get_xclbin_uuid() - UUID of xclbin from which context was created"]
    #[link_name = "\u{1}_ZNK3xrt10hw_context15get_xclbin_uuidEv"]
    pub fn xrt_hw_context_get_xclbin_uuid(this: *const xrt_hw_context) -> xrt_uuid;
}
extern "C" {
    #[doc = " get_xclbin() - Retrieve underlying xclbin matching the UUID"]
    #[link_name = "\u{1}_ZNK3xrt10hw_context10get_xclbinEv"]
    pub fn xrt_hw_context_get_xclbin(this: *const xrt_hw_context) -> xrt_xclbin;
}
extern "C" {
    #[doc = " get_mode() - Get the context access mode"]
    #[link_name = "\u{1}_ZNK3xrt10hw_context8get_modeEv"]
    pub fn xrt_hw_context_get_mode(this: *const xrt_hw_context) -> xrt_hw_context_access_mode;
}
extern "C" {
    #[doc = " hw_context() - Constructor with QoS control\n\n @param device\n  Device where context is created\n @param xclbin_id\n  UUID of xclbin that should be assigned to HW resources\n @cfg_param\n  Configuration Parameters (incl. Quality of Service)\n\n The QoS definition is subject to change, so this API is not guaranteed\n to be ABI compatible in future releases."]
    #[link_name = "\u{1}_ZN3xrt10hw_contextC1ERKNS_6deviceERKNS_4uuidERKSt3mapINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEjSt4lessISD_ESaISt4pairIKSD_jEEE"]
    pub fn xrt_hw_context_hw_context(
        this: *mut xrt_hw_context,
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        cfg_param: *const xrt_hw_context_cfg_param_type,
    );
}
extern "C" {
    #[doc = " hw_context() - Construct with specific access control\n\n @param device\n  Device where context is created\n @param xclbin_id\n  UUID of xclbin that should be assigned to HW resources\n @param mode\n  Access control for the context"]
    #[link_name = "\u{1}_ZN3xrt10hw_contextC1ERKNS_6deviceERKNS_4uuidENS0_11access_modeE"]
    pub fn xrt_hw_context_hw_context1(
        this: *mut xrt_hw_context,
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        mode: xrt_hw_context_access_mode,
    );
}
impl xrt_hw_context {
    #[inline]
    pub unsafe fn update_qos(&mut self, qos: *const xrt_hw_context_qos_type) {
        xrt_hw_context_update_qos(self, qos)
    }
    #[inline]
    pub unsafe fn get_device(&self) -> xrt_device {
        xrt_hw_context_get_device(self)
    }
    #[inline]
    pub unsafe fn get_xclbin_uuid(&self) -> xrt_uuid {
        xrt_hw_context_get_xclbin_uuid(self)
    }
    #[inline]
    pub unsafe fn get_xclbin(&self) -> xrt_xclbin {
        xrt_hw_context_get_xclbin(self)
    }
    #[inline]
    pub unsafe fn get_mode(&self) -> xrt_hw_context_access_mode {
        xrt_hw_context_get_mode(self)
    }
    #[inline]
    pub unsafe fn new(
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        cfg_param: *const xrt_hw_context_cfg_param_type,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_hw_context_hw_context(__bindgen_tmp.as_mut_ptr(), device, xclbin_id, cfg_param);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        mode: xrt_hw_context_access_mode,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_hw_context_hw_context1(__bindgen_tmp.as_mut_ptr(), device, xclbin_id, mode);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @class autostart\n\n @brief\n xrt::autostart is a specific type used as template argument.\n\n @details\n When implicitly starting a kernel through templated operator, the\n first argument can be specified as xrt::autostart indicating the\n number of iterations the kernel run should perform.\n\n The default iterations, or xrt::autostart constructed with the\n value 0, represents a for-ever running kernel.\n\n When a kernel is auto-started, the running kernel can be manipulated\n through a \\ref xrt::mailbox object provided the kernel is synthesized\n with mailbox.\n\n The counted auto-restart feature is supported only for kernels that\n are specifically synthesized with counted auto restart.  The\n default value of xrt::autostart is supported default for AP_CTRL_HS\n and AP_CTRL_CHAIN.\n\n Currently autostart is only supported for kernels with one compute\n unit which must be opened in exclusive mode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_autostart {
    pub iterations: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xrt_autostart() {
    const UNINIT: ::std::mem::MaybeUninit<xrt_autostart> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xrt_autostart>(),
        4usize,
        concat!("Size of: ", stringify!(xrt_autostart))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_autostart>(),
        4usize,
        concat!("Alignment of ", stringify!(xrt_autostart))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iterations) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xrt_autostart),
            "::",
            stringify!(iterations)
        )
    );
}
#[doc = " @class run\n\n @brief\n xrt::run represents one execution of a kernel\n\n @details\n The run handle can be explicitly constructed from a kernel object\n or implicitly constructed from starting a kernel execution.\n\n A run handle can be re-used to execute the same kernel again."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_run_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_run {
    pub handle: [u64; 2usize],
}
#[doc = " command_error - exception for abnormal command execution\n\n Used by ``wait2()`` when command completes unsuccessfully."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_run_command_error_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_run_command_error {
    pub _base: xrt_detail_pimpl,
    pub _base_1: std_exception,
    pub m_impl: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_xrt_run_command_error() {
    const UNINIT: ::std::mem::MaybeUninit<xrt_run_command_error> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xrt_run_command_error>(),
        40usize,
        concat!("Size of: ", stringify!(xrt_run_command_error))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_run_command_error>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_run_command_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_impl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xrt_run_command_error),
            "::",
            stringify!(m_impl)
        )
    );
}
extern "C" {
    #[doc = " get_command_state() - command state upon completion"]
    #[link_name = "\u{1}_ZNK3xrt3run13command_error17get_command_stateEv"]
    pub fn xrt_run_command_error_get_command_state(
        this: *const xrt_run_command_error,
    ) -> ert_cmd_state;
}
extern "C" {
    #[link_name = "\u{1}_ZN3xrt3run13command_errorC1E13ert_cmd_stateRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_run_command_error_command_error(
        this: *mut xrt_run_command_error,
        state: ert_cmd_state,
        what: *const std_string,
    );
}
impl xrt_run_command_error {
    #[inline]
    pub unsafe fn get_command_state(&self) -> ert_cmd_state {
        xrt_run_command_error_get_command_state(self)
    }
    #[inline]
    pub unsafe fn new(state: ert_cmd_state, what: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_run_command_error_command_error(__bindgen_tmp.as_mut_ptr(), state, what);
        __bindgen_tmp.assume_init()
    }
}
#[test]
fn bindgen_test_layout_xrt_run() {
    const UNINIT: ::std::mem::MaybeUninit<xrt_run> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xrt_run>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_run))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_run>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_run))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xrt_run),
            "::",
            stringify!(handle)
        )
    );
}
extern "C" {
    #[doc = " start() - Start one execution of a run.\n\n This function is asynchronous, run status must be expclicit checked\n or ``wait()`` must be used to wait for the run to complete."]
    #[link_name = "\u{1}_ZN3xrt3run5startEv"]
    pub fn xrt_run_start(this: *mut xrt_run);
}
extern "C" {
    #[doc = " start() - Start auto-restart execution of a run\n\n @param iterations\n   Number of times to iterate the same run.\n\n An iteration count of zero means that the kernel should run\n forever, or until explicitly stopped using ``stop()``.\n\n This function is asynchronous, run status must be expclicit\n checked or ``wait()`` must be used to wait for the run to\n complete.\n\n The kernel run object is complete only after all iterations have\n completed, or until run object has been explicitly stopped.\n\n Changing kernel arguments ``set_arg()`` while the kernel is running\n has undefined behavior.  To synchronize change of arguments, please\n use \\ref xrt::mailbox.\n\n Currently autostart is only supported for kernels with one\n compute unit which must be opened in exclusive mode."]
    #[link_name = "\u{1}_ZN3xrt3run5startERKNS_9autostartE"]
    pub fn xrt_run_start1(this: *mut xrt_run, iterations: *const xrt_autostart);
}
extern "C" {
    #[doc = " stop() - Stop kernel run object at next safe iteration\n\n If the kernel run object has been started by specifying\n an iteration count or by specifying default iteration count,\n then this function can be used to stop the iteration early.\n\n The function is synchronous and waits for the kernel\n run object to complete.\n\n If the kernel is not iterating, then calling this funciton\n is the same as calling ``wait()``."]
    #[link_name = "\u{1}_ZN3xrt3run4stopEv"]
    pub fn xrt_run_stop(this: *mut xrt_run);
}
extern "C" {
    #[doc = " abort() - Abort a run object that has been started\n\n @return\n  State of aborted command\n\n If the run object has been sent to scheduler for execution, then\n this function can be used to abort the scheduled command.\n\n The function is synchronous and will wait for abort to complete.\n The return value is the state of the aborted command."]
    #[link_name = "\u{1}_ZN3xrt3run5abortEv"]
    pub fn xrt_run_abort(this: *mut xrt_run) -> ert_cmd_state;
}
extern "C" {
    #[doc = " wait() - Wait for a run to complete execution\n\n @param timeout\n  Timeout for wait (default block till run completes)\n @return\n  Command state upon return of wait, or ERT_CMD_STATE_TIMEOUT\n  if timeout exceeded.\n\n The default timeout of 0ms indicates blocking until run completes.\n\n The current thread will block until the run completes or timeout\n expires. Completion does not guarantee success, the run status\n should be checked by using ``state``.\n\n If specified time out is exceeded, the function returns with\n ERT_CMD_STATE_TIMEOUT, it is the callers responsibility to abort\n the run if it continues to time out.\n\n The current implementation of this API can mask out the timeout\n of this run so that the call either never returns or doesn't\n return until the run completes by itself. This can happen if\n other runs are continuosly completing within the specified\n timeout for this run.  If the device is otherwise idle, or if the\n time between run completion exceeds the specified timeout, then\n this function will identify the timeout."]
    #[link_name = "\u{1}_ZNK3xrt3run4waitERKNSt6chrono8durationIlSt5ratioILl1ELl1000EEEE"]
    pub fn xrt_run_wait(
        this: *const xrt_run,
        timeout: *const std_chrono_milliseconds,
    ) -> ert_cmd_state;
}
extern "C" {
    #[doc = " wait2() - Wait for specified milliseconds for run to complete\n\n @param timeout\n  Timeout for wait (default block until run completes)\n @return\n  std::cv_status::no_timeout when command completes successfully.\n  std::cv_status::timeout when wait timed out without command\n  completing.\n\n Successful command completion means that the command state is\n ERT_CMD_STATE_COMPLETED.  All other command states result in this\n function throwing ``command_error`` exception with the command\n state embedded in the exception.\n\n Throws ``xrt::run::command_error`` on abnormal command termination.\n\n The current thread blocks until the run successfully completes or\n timeout expires. A return code of std::cv_state::no_timeout\n guarantees that the command completed successfully.\n\n If specified time out is exceeded, the function returns with\n std::cv_status::timeout, it is the callers responsibility to abort\n the run if it continues to time out.\n\n The current implementation of this API can mask out the timeout\n of this run so that the call either never returns or doesn't\n return until the run completes by itself. This can happen if\n other runs are continuosly completing within the specified\n timeout for this run.  If the device is otherwise idle, or if the\n time between run completion exceeds the specified timeout, then\n this function will identify the timeout."]
    #[link_name = "\u{1}_ZNK3xrt3run5wait2ERKNSt6chrono8durationIlSt5ratioILl1ELl1000EEEE"]
    pub fn xrt_run_wait2(
        this: *const xrt_run,
        timeout: *const std_chrono_milliseconds,
    ) -> std_cv_status;
}
extern "C" {
    #[doc = " state() - Check the current state of a run object\n\n @return\n  Current state of this run object\n\n The state values are defined in ``include/ert.h``"]
    #[link_name = "\u{1}_ZNK3xrt3run5stateEv"]
    pub fn xrt_run_state(this: *const xrt_run) -> ert_cmd_state;
}
extern "C" {
    #[doc = " return_code() - Get the return code from PS kernel\n\n @return\n  Return code from PS kernel run"]
    #[link_name = "\u{1}_ZNK3xrt3run11return_codeEv"]
    pub fn xrt_run_return_code(this: *const xrt_run) -> u32;
}
extern "C" {
    #[doc = " add_callback() - Add a callback function for run state\n\n @param state       State to invoke callback on\n @param callback    Callback function\n @param data        User data to pass to callback function\n\n The function is called when the run object changes state to\n argument state or any error state.  Only\n ``ERT_CMD_STATE_COMPLETED`` is supported currently.\n\n The function object's first parameter is a unique 'key'\n for this xrt::run object implmentation on which the callback\n was added. This 'key' can be used to identify an actual run\n object that refers to the implementaion that is maybe shared\n by multiple xrt::run objects.\n\n Any number of callbacks are supported."]
    #[link_name = "\u{1}_ZN3xrt3run12add_callbackE13ert_cmd_stateSt8functionIFvPKvS1_PvEES5_"]
    pub fn xrt_run_add_callback(
        this: *mut xrt_run,
        state: ert_cmd_state,
        callback: u8,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@cond\n Experimental in 2023.2"]
    #[link_name = "\u{1}_ZN3xrt3run11submit_waitERKNS_5fenceE"]
    pub fn xrt_run_submit_wait(this: *mut xrt_run, fence: *const xrt_fence);
}
extern "C" {
    #[link_name = "\u{1}_ZN3xrt3run13submit_signalERKNS_5fenceE"]
    pub fn xrt_run_submit_signal(this: *mut xrt_run, fence: *const xrt_fence);
}
extern "C" {
    #[link_name = "\u{1}_ZNK3xrt3run14get_ert_packetEv"]
    pub fn xrt_run_get_ert_packet(this: *const xrt_run) -> *mut ert_packet;
}
extern "C" {
    #[doc = " run() - Construct run object from a kernel object\n\n @param krnl: Kernel object representing the kernel to execute"]
    #[link_name = "\u{1}_ZN3xrt3runC1ERKNS_6kernelE"]
    pub fn xrt_run_run(this: *mut xrt_run, krnl: *const xrt_kernel);
}
impl xrt_run {
    #[inline]
    pub unsafe fn start(&mut self) {
        xrt_run_start(self)
    }
    #[inline]
    pub unsafe fn start1(&mut self, iterations: *const xrt_autostart) {
        xrt_run_start1(self, iterations)
    }
    #[inline]
    pub unsafe fn stop(&mut self) {
        xrt_run_stop(self)
    }
    #[inline]
    pub unsafe fn abort(&mut self) -> ert_cmd_state {
        xrt_run_abort(self)
    }
    #[inline]
    pub unsafe fn wait(&self, timeout: *const std_chrono_milliseconds) -> ert_cmd_state {
        xrt_run_wait(self, timeout)
    }
    #[inline]
    pub unsafe fn wait2(&self, timeout: *const std_chrono_milliseconds) -> std_cv_status {
        xrt_run_wait2(self, timeout)
    }
    #[inline]
    pub unsafe fn state(&self) -> ert_cmd_state {
        xrt_run_state(self)
    }
    #[inline]
    pub unsafe fn return_code(&self) -> u32 {
        xrt_run_return_code(self)
    }
    #[inline]
    pub unsafe fn add_callback(
        &mut self,
        state: ert_cmd_state,
        callback: u8,
        data: *mut ::std::os::raw::c_void,
    ) {
        xrt_run_add_callback(self, state, callback, data)
    }
    #[inline]
    pub unsafe fn submit_wait(&mut self, fence: *const xrt_fence) {
        xrt_run_submit_wait(self, fence)
    }
    #[inline]
    pub unsafe fn submit_signal(&mut self, fence: *const xrt_fence) {
        xrt_run_submit_signal(self, fence)
    }
    #[inline]
    pub unsafe fn get_ert_packet(&self) -> *mut ert_packet {
        xrt_run_get_ert_packet(self)
    }
    #[inline]
    pub unsafe fn new(krnl: *const xrt_kernel) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_run_run(__bindgen_tmp.as_mut_ptr(), krnl);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK3xrt3run13command_error4whatEv"]
    pub fn xrt_run_command_error_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " @class kernel\n\n A kernel object represents a set of instances matching a specified name.\n The kernel is created by finding matching kernel instances in the\n currently loaded xclbin.\n\n Most interaction with kernel objects are through \\ref xrt::run objects created\n from the kernel object to represent an execution of the kernel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_kernel_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_kernel {
    #[doc = " @endcond"]
    pub handle: [u64; 2usize],
}
pub const xrt_kernel_cu_access_mode_exclusive: xrt_kernel_cu_access_mode = 0;
pub const xrt_kernel_cu_access_mode_shared: xrt_kernel_cu_access_mode = 1;
pub const xrt_kernel_cu_access_mode_none: xrt_kernel_cu_access_mode = 2;
#[doc = " cu_access_mode - compute unit access mode\n\n @var shared\n  CUs can be shared between processes\n @var exclusive\n  CUs are owned exclusively by this process"]
pub type xrt_kernel_cu_access_mode = u8;
#[test]
fn bindgen_test_layout_xrt_kernel() {
    const UNINIT: ::std::mem::MaybeUninit<xrt_kernel> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xrt_kernel>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_kernel))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_kernel>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_kernel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xrt_kernel),
            "::",
            stringify!(handle)
        )
    );
}
extern "C" {
    #[doc = " group_id() - Get the memory bank group id of an kernel argument\n\n @param argno\n  The argument index\n @return\n  The memory group id to use when allocating buffers (see xrt::bo)\n\n The function throws if the group id is ambigious."]
    #[link_name = "\u{1}_ZNK3xrt6kernel8group_idEi"]
    pub fn xrt_kernel_group_id(
        this: *const xrt_kernel,
        argno: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " offset() - Get the offset of kernel argument\n\n @param argno\n  The argument index\n @return\n  The kernel register offset of the argument with specified index\n\n Use with ``read_register()`` and ``write_register()`` if manually\n reading or writing kernel registers for explicit arguments."]
    #[link_name = "\u{1}_ZNK3xrt6kernel6offsetEi"]
    pub fn xrt_kernel_offset(this: *const xrt_kernel, argno: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3xrt6kernel14write_registerEjj"]
    pub fn xrt_kernel_write_register(this: *mut xrt_kernel, offset: u32, data: u32);
}
extern "C" {
    #[link_name = "\u{1}_ZNK3xrt6kernel13read_registerEj"]
    pub fn xrt_kernel_read_register(this: *const xrt_kernel, offset: u32) -> u32;
}
extern "C" {
    #[doc = " get_name() - Return the name of the kernel"]
    #[link_name = "\u{1}_ZNK3xrt6kernel8get_nameB5cxx11Ev"]
    pub fn xrt_kernel_get_name(this: *const xrt_kernel) -> std_string;
}
extern "C" {
    #[doc = " get_xclbin() - Return the xclbin containing the kernel"]
    #[link_name = "\u{1}_ZNK3xrt6kernel10get_xclbinEv"]
    pub fn xrt_kernel_get_xclbin(this: *const xrt_kernel) -> xrt_xclbin;
}
extern "C" {
    #[doc = " kernel() - Constructor from a device and xclbin\n\n @param device\n  Device on which the kernel should execute\n @param xclbin_id\n  UUID of the xclbin with the kernel\n @param name\n  Name of kernel to construct\n @param mode\n  Open the kernel instances with specified access (default shared)\n\n The kernel name must uniquely identify compatible kernel\n instances (compute units).  Optionally specify which kernel\n instance(s) to open using\n \"kernelname:{instancename1,instancename2,...}\" syntax.  The\n compute units are default opened with shared access, meaning that\n other kernels and other process will have shared access to same\n compute units."]
    #[link_name = "\u{1}_ZN3xrt6kernelC1ERKNS_6deviceERKNS_4uuidERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_14cu_access_modeE"]
    pub fn xrt_kernel_kernel(
        this: *mut xrt_kernel,
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        name: *const std_string,
        mode: xrt_kernel_cu_access_mode,
    );
}
extern "C" {
    #[doc = " @cond\n Experimental in 2022.2, 2023.1, 2023.3"]
    #[link_name = "\u{1}_ZN3xrt6kernelC1ERKNS_10hw_contextERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_kernel_kernel1(
        this: *mut xrt_kernel,
        ctx: *const xrt_hw_context,
        name: *const std_string,
    );
}
extern "C" {
    #[doc = " Obsoleted construction from xclDeviceHandle"]
    #[link_name = "\u{1}_ZN3xrt6kernelC1EPvRKNS_4uuidERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_14cu_access_modeE"]
    pub fn xrt_kernel_kernel2(
        this: *mut xrt_kernel,
        dhdl: xclDeviceHandle,
        xclbin_id: *const xrt_uuid,
        name: *const std_string,
        mode: xrt_kernel_cu_access_mode,
    );
}
impl xrt_kernel {
    #[inline]
    pub unsafe fn group_id(&self, argno: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        xrt_kernel_group_id(self, argno)
    }
    #[inline]
    pub unsafe fn offset(&self, argno: ::std::os::raw::c_int) -> u32 {
        xrt_kernel_offset(self, argno)
    }
    #[inline]
    pub unsafe fn write_register(&mut self, offset: u32, data: u32) {
        xrt_kernel_write_register(self, offset, data)
    }
    #[inline]
    pub unsafe fn read_register(&self, offset: u32) -> u32 {
        xrt_kernel_read_register(self, offset)
    }
    #[inline]
    pub unsafe fn get_name(&self) -> std_string {
        xrt_kernel_get_name(self)
    }
    #[inline]
    pub unsafe fn get_xclbin(&self) -> xrt_xclbin {
        xrt_kernel_get_xclbin(self)
    }
    #[inline]
    pub unsafe fn new(
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        name: *const std_string,
        mode: xrt_kernel_cu_access_mode,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_kernel_kernel(__bindgen_tmp.as_mut_ptr(), device, xclbin_id, name, mode);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(ctx: *const xrt_hw_context, name: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_kernel_kernel1(__bindgen_tmp.as_mut_ptr(), ctx, name);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        dhdl: xclDeviceHandle,
        xclbin_id: *const xrt_uuid,
        name: *const std_string,
        mode: xrt_kernel_cu_access_mode,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_kernel_kernel2(__bindgen_tmp.as_mut_ptr(), dhdl, xclbin_id, name, mode);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @cond"]
    #[link_name = "\u{1}_ZN3xrt14set_read_rangeERKNS_6kernelEjj"]
    pub fn xrt_set_read_range(kernel: *const xrt_kernel, start: u32, size: u32);
}
#[doc = " @class ip\n\n @brief\n xrt::ip represent the custom IP\n\n @details The ip can be controlled through read- and write register\n only.  If the IP supports interrupt notification, then xrt::ip\n objects supports enabling and control of underlying IP interrupt.\n\n In order to construct an ip object, the following requirements must be met:\n\n   - The custom IP must appear in IP_LAYOUT section of xclbin.\n   - The custom IP must have a base address such that it can be controlled\n     through register access at offsets from base address.\n   - The custom IP must have an address range so that write and read access\n     to base address offset can be validated.\n   - XRT supports exclusive access only for the custom IP, this is to other\n     processes from accessing the same IP at the same time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_ip_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_ip {
    pub _base: xrt_detail_pimpl,
}
#[doc = " @class interrupt\n\n @brief\n xrt::ip::interrupt represents an IP interrupt event.\n\n This class represents an IP interrupt event.  The interrupt\n object is contructed via `xrt::ip::create_interrupt_notify()`.\n The object can be used to enable and disable IP interrupts\n and to wait for an interrupt to occur.\n\n Upon construction, the IP interrupt is automatically enabled."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_ip_interrupt_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_ip_interrupt {
    pub _base: xrt_detail_pimpl,
}
#[test]
fn bindgen_test_layout_xrt_ip_interrupt() {
    assert_eq!(
        ::std::mem::size_of::<xrt_ip_interrupt>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_ip_interrupt))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_ip_interrupt>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_ip_interrupt))
    );
}
extern "C" {
    #[doc = " enable() - Enable interrupt\n\n Enables the IP interrupt if not already enabled.  The\n IP interrupt is automatically enabled when the interrupt\n object is created."]
    #[link_name = "\u{1}_ZN3xrt2ip9interrupt6enableEv"]
    pub fn xrt_ip_interrupt_enable(this: *mut xrt_ip_interrupt);
}
extern "C" {
    #[doc = " disable() - Disable interrupt\n\n Disables the IP interrupt notification from IP."]
    #[link_name = "\u{1}_ZN3xrt2ip9interrupt7disableEv"]
    pub fn xrt_ip_interrupt_disable(this: *mut xrt_ip_interrupt);
}
extern "C" {
    #[doc = " wait() - Wait for interrupt\n\n Wait for interrupt from IP. Upon return, interrupt is\n re-enabled."]
    #[link_name = "\u{1}_ZN3xrt2ip9interrupt4waitEv"]
    pub fn xrt_ip_interrupt_wait(this: *mut xrt_ip_interrupt);
}
extern "C" {
    #[doc = " wait() - Wait for interrupt or timeout to occur\n\n @param timeout\n   Timout in milliseconds.\n @return\n   std::cv_status::timeout if the timeout specified expired,\n   std::cv_status::no_timeout otherwise.\n\n Blocks the current thread until an interrupt is received from the IP,  or\n until after the specified timeout duration"]
    #[link_name = "\u{1}_ZNK3xrt2ip9interrupt4waitERKNSt6chrono8durationIlSt5ratioILl1ELl1000EEEE"]
    pub fn xrt_ip_interrupt_wait1(
        this: *const xrt_ip_interrupt,
        timeout: *const std_chrono_milliseconds,
    ) -> std_cv_status;
}
impl xrt_ip_interrupt {
    #[inline]
    pub unsafe fn enable(&mut self) {
        xrt_ip_interrupt_enable(self)
    }
    #[inline]
    pub unsafe fn disable(&mut self) {
        xrt_ip_interrupt_disable(self)
    }
    #[inline]
    pub unsafe fn wait(&mut self) {
        xrt_ip_interrupt_wait(self)
    }
    #[inline]
    pub unsafe fn wait1(&self, timeout: *const std_chrono_milliseconds) -> std_cv_status {
        xrt_ip_interrupt_wait1(self, timeout)
    }
}
#[test]
fn bindgen_test_layout_xrt_ip() {
    assert_eq!(
        ::std::mem::size_of::<xrt_ip>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_ip))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_ip>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_ip))
    );
}
extern "C" {
    #[doc = " write_register() - Write to the address range of an ip\n\n @param offset\n  Offset in register space to write to\n @param data\n  Data to write\n\n Throws std::out_or_range if offset is outside the\n ip address space"]
    #[link_name = "\u{1}_ZN3xrt2ip14write_registerEjj"]
    pub fn xrt_ip_write_register(this: *mut xrt_ip, offset: u32, data: u32);
}
extern "C" {
    #[doc = " read_register() - Read data from ip address range\n\n @param offset\n  Offset in register space to read from\n @return\n  Value read from offset\n\n Throws std::out_or_range if offset is outside the\n ip address space"]
    #[link_name = "\u{1}_ZNK3xrt2ip13read_registerEj"]
    pub fn xrt_ip_read_register(this: *const xrt_ip, offset: u32) -> u32;
}
extern "C" {
    #[doc = " create_interrupt_notify() - Create xrt::ip::interrupt object\n\n @return\n  xrt::ip::interrupt object can be used to control IP interrupt.\n\n This function creates an xrt::ip::interrupt object that can be\n used to control and wait for IP interrupt.   On successful\n return the IP has interrupt enabled.\n\n Throws if the custom IP doesn't support interrupts."]
    #[link_name = "\u{1}_ZN3xrt2ip23create_interrupt_notifyEv"]
    pub fn xrt_ip_create_interrupt_notify(this: *mut xrt_ip) -> xrt_ip_interrupt;
}
extern "C" {
    #[doc = " ip() - Constructor from a device and xclbin\n\n @param device\n  Device programmed with the IP\n @param xclbin_id\n  UUID of the xclbin with the IP\n @param name\n  Name of IP to construct\n\n The IP is opened with exclusive access meaning that no other\n xrt::ip objects can use the same IP, nor will another process be\n able to use the IP while one process has been granted access.\n\n Constructor throws on error."]
    #[link_name = "\u{1}_ZN3xrt2ipC1ERKNS_6deviceERKNS_4uuidERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_ip_ip(
        this: *mut xrt_ip,
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        name: *const std_string,
    );
}
extern "C" {
    #[doc = " @cond\n Experimental in 2022.2"]
    #[link_name = "\u{1}_ZN3xrt2ipC1ERKNS_10hw_contextERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_ip_ip1(this: *mut xrt_ip, ctx: *const xrt_hw_context, name: *const std_string);
}
impl xrt_ip {
    #[inline]
    pub unsafe fn write_register(&mut self, offset: u32, data: u32) {
        xrt_ip_write_register(self, offset, data)
    }
    #[inline]
    pub unsafe fn read_register(&self, offset: u32) -> u32 {
        xrt_ip_read_register(self, offset)
    }
    #[inline]
    pub unsafe fn create_interrupt_notify(&mut self) -> xrt_ip_interrupt {
        xrt_ip_create_interrupt_notify(self)
    }
    #[inline]
    pub unsafe fn new(
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        name: *const std_string,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_ip_ip(__bindgen_tmp.as_mut_ptr(), device, xclbin_id, name);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(ctx: *const xrt_hw_context, name: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_ip_ip1(__bindgen_tmp.as_mut_ptr(), ctx, name);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct boost_any {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_core_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_core_fence_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_core_hwctx_handle {
    _unused: [u8; 0],
}
#[doc = " typedef xrtBufferHandle - opaque buffer handle"]
pub type xrtBufferHandle = *mut ::std::os::raw::c_void;
#[doc = " typedef xrtBufferFlags - flags for BO\n\n See ``xrt_mem.h`` for available flags"]
pub type xrtBufferFlags = u64;
#[doc = " typedef xrtMemoryGroup - Memory bank group for buffer"]
pub type xrtMemoryGroup = u32;
#[doc = " @struct xcl_buffer_handle\n\n @brief\n Typed xclBufferHandle used to prevent ambiguity\n\n @details\n Use when constructing xrt::bo from xclBufferHandle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcl_buffer_handle {
    pub bhdl: xclBufferHandle,
}
#[test]
fn bindgen_test_layout_xcl_buffer_handle() {
    const UNINIT: ::std::mem::MaybeUninit<xcl_buffer_handle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcl_buffer_handle>(),
        4usize,
        concat!("Size of: ", stringify!(xcl_buffer_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<xcl_buffer_handle>(),
        4usize,
        concat!("Alignment of ", stringify!(xcl_buffer_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bhdl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcl_buffer_handle),
            "::",
            stringify!(bhdl)
        )
    );
}
#[doc = " struct ert_packet: ERT generic packet format\n\n @state:   [3-0] current state of a command\n @custom:  [11-4] custom per specific commands\n @count:   [22-12] number of words in payload (data)\n @opcode:  [27-23] opcode identifying specific command\n @type:    [31-28] type of command (currently 0)\n @data:    count number of words representing packet payload"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ert_packet {
    pub __bindgen_anon_1: ert_packet__bindgen_ty_1,
    pub data: [u32; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ert_packet__bindgen_ty_1 {
    pub __bindgen_anon_1: ert_packet__bindgen_ty_1__bindgen_ty_1,
    pub header: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ert_packet__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ert_packet__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ert_packet__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ert_packet__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ert_packet__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_packet__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl ert_packet__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn custom(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_custom(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn opcode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: u32,
        custom: u32,
        count: u32,
        opcode: u32,
        type_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let custom: u32 = unsafe { ::std::mem::transmute(custom) };
            custom as u64
        });
        __bindgen_bitfield_unit.set(12usize, 11u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let opcode: u32 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ert_packet__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ert_packet__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_packet__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ert_packet__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_packet__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_packet__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_packet__bindgen_ty_1),
            "::",
            stringify!(header)
        )
    );
}
#[test]
fn bindgen_test_layout_ert_packet() {
    const UNINIT: ::std::mem::MaybeUninit<ert_packet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_packet>(),
        8usize,
        concat!("Size of: ", stringify!(ert_packet))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_packet>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_packet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_packet),
            "::",
            stringify!(data)
        )
    );
}
pub const ert_cmd_state_ERT_CMD_STATE_NEW: ert_cmd_state = 1;
pub const ert_cmd_state_ERT_CMD_STATE_QUEUED: ert_cmd_state = 2;
pub const ert_cmd_state_ERT_CMD_STATE_RUNNING: ert_cmd_state = 3;
pub const ert_cmd_state_ERT_CMD_STATE_COMPLETED: ert_cmd_state = 4;
pub const ert_cmd_state_ERT_CMD_STATE_ERROR: ert_cmd_state = 5;
pub const ert_cmd_state_ERT_CMD_STATE_ABORT: ert_cmd_state = 6;
pub const ert_cmd_state_ERT_CMD_STATE_SUBMITTED: ert_cmd_state = 7;
pub const ert_cmd_state_ERT_CMD_STATE_TIMEOUT: ert_cmd_state = 8;
pub const ert_cmd_state_ERT_CMD_STATE_NORESPONSE: ert_cmd_state = 9;
pub const ert_cmd_state_ERT_CMD_STATE_SKERROR: ert_cmd_state = 10;
pub const ert_cmd_state_ERT_CMD_STATE_SKCRASHED: ert_cmd_state = 11;
pub const ert_cmd_state_ERT_CMD_STATE_MAX: ert_cmd_state = 12;
#[doc = " ERT command state\n\n @ERT_CMD_STATE_NEW:         Set by host before submitting a command to\n                             scheduler\n @ERT_CMD_STATE_QUEUED:      Internal scheduler state\n @ERT_CMD_STATE_SUBMITTED:   Internal scheduler state\n @ERT_CMD_STATE_RUNNING:     Internal scheduler state\n @ERT_CMD_STATE_COMPLETED:   Set by scheduler when command completes\n @ERT_CMD_STATE_ERROR:       Set by scheduler if command failed\n @ERT_CMD_STATE_ABORT:       Set by scheduler if command abort\n @ERT_CMD_STATE_TIMEOUT:     Set by scheduler if command timeout and reset\n @ERT_CMD_STATE_NORESPONSE:  Set by scheduler if command timeout and fail to\n                             reset"]
pub type ert_cmd_state = ::std::os::raw::c_uint;
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_xclbin_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_xclbin_mem_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_xclbin_arg_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_xclbin_ip_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_xclbin_kernel_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_xclbin_aie_partition_impl_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_bo_async_handle_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_fence_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_hw_context_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_run_command_error_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_ip_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_ip_interrupt_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
