/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
pub type std_basic_string__Char_alloc_type = u8;
pub type std_basic_string__Alloc_traits = u8;
pub type std_basic_string_traits_type = u8;
pub type std_basic_string_value_type = u8;
pub type std_basic_string_allocator_type = u8;
pub type std_basic_string_size_type = u8;
pub type std_basic_string_difference_type = u8;
pub type std_basic_string_reference = u8;
pub type std_basic_string_const_reference = u8;
pub type std_basic_string_pointer = u8;
pub type std_basic_string_const_pointer = u8;
pub type std_basic_string_iterator = u8;
pub type std_basic_string_const_iterator = u8;
pub type std_basic_string_const_reverse_iterator = u8;
pub type std_basic_string_reverse_iterator = u8;
pub type std_basic_string___const_iterator = u8;
pub type std_basic_string___sv_type = u8;
pub type std_basic_string__If_sv = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___sv_wrapper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string__Alloc_hider {
    pub _address: u8,
}
pub const std_basic_string__S_local_capacity: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union std_basic_string__bindgen_ty_2 {
    pub _bindgen_opaque_blob: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair {
    pub _address: u8,
}
pub type std_pair_first_type = u8;
pub type std_pair_second_type = u8;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair___zero_as_null_pointer_constant {
    pub _address: u8,
}
pub type std_string = [u64; 4usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_value_type = u8;
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_shared_ptr {
    pub _address: u8,
}
pub type std_shared_ptr__Constructible = u8;
pub type std_shared_ptr__Assignable = u8;
pub type std_shared_ptr_element_type = u8;
pub type std_shared_ptr_weak_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Base = u8;
pub type std_vector__Tp_alloc_type = u8;
pub type std_vector__Alloc_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_size_type = u64;
pub type std_vector_difference_type = u64;
pub type std_vector_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector__Temporary_value {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Copy, Clone)]
pub union std_vector__Temporary_value__Storage {
    pub _bindgen_opaque_blob: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_map {
    pub _address: u8,
}
pub type std_map_key_type = u8;
pub type std_map_mapped_type = u8;
pub type std_map_value_type = u8;
pub type std_map_key_compare = u8;
pub type std_map_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_map_value_compare {
    pub _address: u8,
}
pub type std_map__Pair_alloc_type = u8;
pub type std_map__Rep_type = u8;
pub type std_map__Alloc_traits = u8;
pub type std_map_pointer = u8;
pub type std_map_const_pointer = u8;
pub type std_map_reference = u8;
pub type std_map_const_reference = u8;
pub type std_map_iterator = u8;
pub type std_map_const_iterator = u8;
pub type std_map_size_type = u8;
pub type std_map_difference_type = u8;
pub type std_map_reverse_iterator = u8;
pub type std_map_const_reverse_iterator = u8;
pub type std_map_node_type = u8;
pub type std_map_insert_return_type = u8;
pub type std_chrono_milliseconds = u64;
pub const std_cv_status_no_timeout: std_cv_status = 0;
pub const std_cv_status_timeout: std_cv_status = 1;
pub type std_cv_status = ::std::os::raw::c_int;
#[doc = " @class uuid\n\n @brief\n Wrapper class to treat uuid_t as a value type supporting copying\n\n @details\n xrt::uuid is used by many XRT APIs to match an expected xclbin\n against current device xclbin, or to get the uuid of current loaded\n shell on the device."]
#[repr(C)]
pub struct xrt_uuid {
    pub m_uuid: xuid_t,
}
#[test]
fn bindgen_test_layout_xrt_uuid() {
    const UNINIT: ::std::mem::MaybeUninit<xrt_uuid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xrt_uuid>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_uuid))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_uuid>(),
        1usize,
        concat!("Alignment of ", stringify!(xrt_uuid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xrt_uuid),
            "::",
            stringify!(m_uuid)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_detail_pimpl {
    pub handle: u8,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub const xrt_xclbin_target_type_hw: xrt_xclbin_target_type = 0;
pub const xrt_xclbin_target_type_sw_emu: xrt_xclbin_target_type = 1;
pub const xrt_xclbin_target_type_hw_emu: xrt_xclbin_target_type = 2;
#[doc = " @enum target_type\n\n @brief\n Type of xclbin\n\n @details\n See `xclbin.h`"]
pub type xrt_xclbin_target_type = ::std::os::raw::c_int;
#[doc = " @class mem\n\n @brief\n xrt::xclbin::mem represents a physical device memory bank\n\n @details\n A memory object is constructed from an entry in the MEM_TOPOLOGY\n section of an xclbin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_mem_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_mem {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub const xrt_xclbin_mem_memory_type_ddr3: xrt_xclbin_mem_memory_type = 0;
pub const xrt_xclbin_mem_memory_type_ddr4: xrt_xclbin_mem_memory_type = 1;
pub const xrt_xclbin_mem_memory_type_dram: xrt_xclbin_mem_memory_type = 2;
pub const xrt_xclbin_mem_memory_type_streaming: xrt_xclbin_mem_memory_type = 3;
pub const xrt_xclbin_mem_memory_type_preallocated_global: xrt_xclbin_mem_memory_type = 4;
pub const xrt_xclbin_mem_memory_type_are: xrt_xclbin_mem_memory_type = 5;
pub const xrt_xclbin_mem_memory_type_hbm: xrt_xclbin_mem_memory_type = 6;
pub const xrt_xclbin_mem_memory_type_bram: xrt_xclbin_mem_memory_type = 7;
pub const xrt_xclbin_mem_memory_type_uram: xrt_xclbin_mem_memory_type = 8;
pub const xrt_xclbin_mem_memory_type_streaming_connection: xrt_xclbin_mem_memory_type = 9;
pub const xrt_xclbin_mem_memory_type_host: xrt_xclbin_mem_memory_type = 10;
#[doc = " @enum memory_type - type of memory\n\n @details\n See `xclbin.h`"]
pub type xrt_xclbin_mem_memory_type = u8;
#[test]
fn bindgen_test_layout_xrt_xclbin_mem() {
    assert_eq!(
        ::std::mem::size_of::<xrt_xclbin_mem>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_xclbin_mem))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_xclbin_mem>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_xclbin_mem))
    );
}
extern "C" {
    #[doc = " get_name() - Get tag name\n\n @return\n   Memory tag name"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3mem7get_tagB5cxx11Ev"]
    pub fn xrt_xclbin_mem_get_tag(this: *const xrt_xclbin_mem) -> std_string;
}
extern "C" {
    #[doc = " get_base_address() - Get the base address of the memory bank\n\n @return\n  Base address of the memory bank, or -1 for invalid base address"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3mem16get_base_addressEv"]
    pub fn xrt_xclbin_mem_get_base_address(this: *const xrt_xclbin_mem) -> u64;
}
extern "C" {
    #[doc = " get_size() - Get the size of the memory in KB\n\n @return\n  Size of memory in KB, or -1 for invalid size"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3mem11get_size_kbEv"]
    pub fn xrt_xclbin_mem_get_size_kb(this: *const xrt_xclbin_mem) -> u64;
}
extern "C" {
    #[doc = " get_used() - Get used status of the memory\n\n @return\n  True of this memory bank is used by kernels in the xclbin\n  or false otherwise.\n\n A value of false indicates that no buffer can be allocated\n in this memory bank."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3mem8get_usedEv"]
    pub fn xrt_xclbin_mem_get_used(this: *const xrt_xclbin_mem) -> bool;
}
extern "C" {
    #[doc = " get_type() - Get the type of the memory\n\n @return\n  Memory type\n"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3mem8get_typeEv"]
    pub fn xrt_xclbin_mem_get_type(this: *const xrt_xclbin_mem) -> xrt_xclbin_mem_memory_type;
}
extern "C" {
    #[doc = " get_index() - Get the index of the memory\n\n @return\n  Index of the memory within the memory topology\n\n The returned index can be used when allocating buffers using\n \\ref xrt::bo provided the memory bank is connected / used."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3mem9get_indexEv"]
    pub fn xrt_xclbin_mem_get_index(this: *const xrt_xclbin_mem) -> i32;
}
impl xrt_xclbin_mem {
    #[inline]
    pub unsafe fn get_tag(&self) -> std_string {
        xrt_xclbin_mem_get_tag(self)
    }
    #[inline]
    pub unsafe fn get_base_address(&self) -> u64 {
        xrt_xclbin_mem_get_base_address(self)
    }
    #[inline]
    pub unsafe fn get_size_kb(&self) -> u64 {
        xrt_xclbin_mem_get_size_kb(self)
    }
    #[inline]
    pub unsafe fn get_used(&self) -> bool {
        xrt_xclbin_mem_get_used(self)
    }
    #[inline]
    pub unsafe fn get_type(&self) -> xrt_xclbin_mem_memory_type {
        xrt_xclbin_mem_get_type(self)
    }
    #[inline]
    pub unsafe fn get_index(&self) -> i32 {
        xrt_xclbin_mem_get_index(self)
    }
}
#[doc = " @class arg\n\n @brief\n class arg - xrt::xclbin::arg represents a compute unit argument\n\n @details\n The argument object constructed from the xclbin connectivity\n section.  An argument is connected to a memory bank or a memory\n group, which dictates where in device memory a global buffer\n used with this kernel argument must be allocated."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_arg_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_arg {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_xrt_xclbin_arg() {
    assert_eq!(
        ::std::mem::size_of::<xrt_xclbin_arg>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_xclbin_arg))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_xclbin_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_xclbin_arg))
    );
}
extern "C" {
    #[doc = " get_name() - Get argument name\n\n @return\n  Name of argument.\n"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg8get_nameB5cxx11Ev"]
    pub fn xrt_xclbin_arg_get_name(this: *const xrt_xclbin_arg) -> std_string;
}
extern "C" {
    #[doc = " get_mems() - Get list of device memories from xclbin.\n\n @return\n  A list of xrt::xclbin::mem objects to which this argument\n  is connected."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg8get_memsEv"]
    pub fn xrt_xclbin_arg_get_mems(this: *const xrt_xclbin_arg) -> u8;
}
extern "C" {
    #[doc = " get_port() - Get port name of this argument\n\n @return\n  Port name"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg8get_portB5cxx11Ev"]
    pub fn xrt_xclbin_arg_get_port(this: *const xrt_xclbin_arg) -> std_string;
}
extern "C" {
    #[doc = " get_size() - Argument size in bytes\n\n @return\n   Argument size"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg8get_sizeEv"]
    pub fn xrt_xclbin_arg_get_size(this: *const xrt_xclbin_arg) -> u64;
}
extern "C" {
    #[doc = " get_offset() - Argument offset\n\n @return\n   Argument offset"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg10get_offsetEv"]
    pub fn xrt_xclbin_arg_get_offset(this: *const xrt_xclbin_arg) -> u64;
}
extern "C" {
    #[doc = " get_host_type() - Get the argument host type\n\n @return\n   Argument host type"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg13get_host_typeB5cxx11Ev"]
    pub fn xrt_xclbin_arg_get_host_type(this: *const xrt_xclbin_arg) -> std_string;
}
extern "C" {
    #[doc = " get_index() - Get the index of this argument\n\n @return\n   Argument index"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin3arg9get_indexEv"]
    pub fn xrt_xclbin_arg_get_index(this: *const xrt_xclbin_arg) -> usize;
}
impl xrt_xclbin_arg {
    #[inline]
    pub unsafe fn get_name(&self) -> std_string {
        xrt_xclbin_arg_get_name(self)
    }
    #[inline]
    pub unsafe fn get_mems(&self) -> u8 {
        xrt_xclbin_arg_get_mems(self)
    }
    #[inline]
    pub unsafe fn get_port(&self) -> std_string {
        xrt_xclbin_arg_get_port(self)
    }
    #[inline]
    pub unsafe fn get_size(&self) -> u64 {
        xrt_xclbin_arg_get_size(self)
    }
    #[inline]
    pub unsafe fn get_offset(&self) -> u64 {
        xrt_xclbin_arg_get_offset(self)
    }
    #[inline]
    pub unsafe fn get_host_type(&self) -> std_string {
        xrt_xclbin_arg_get_host_type(self)
    }
    #[inline]
    pub unsafe fn get_index(&self) -> usize {
        xrt_xclbin_arg_get_index(self)
    }
}
#[doc = " @class ip\n\n @brief\n xrt::xclbin::ip represents a IP in an xclbin.\n\n @details\n The ip corresponds to an entry in the IP_LAYOUT section of the\n xclbin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_ip_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_ip {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub const xrt_xclbin_ip_control_type_hs: xrt_xclbin_ip_control_type = 0;
pub const xrt_xclbin_ip_control_type_chain: xrt_xclbin_ip_control_type = 1;
pub const xrt_xclbin_ip_control_type_none: xrt_xclbin_ip_control_type = 2;
pub const xrt_xclbin_ip_control_type_fa: xrt_xclbin_ip_control_type = 5;
#[doc = " @enum control_type -\n\n @details\n See `xclbin.h`"]
pub type xrt_xclbin_ip_control_type = u8;
pub const xrt_xclbin_ip_ip_type_pl: xrt_xclbin_ip_ip_type = 1;
pub const xrt_xclbin_ip_ip_type_ps: xrt_xclbin_ip_ip_type = 7;
#[doc = " @enum ip_type\n\n @details\n See `xclbin.h`"]
pub type xrt_xclbin_ip_ip_type = u8;
#[test]
fn bindgen_test_layout_xrt_xclbin_ip() {
    assert_eq!(
        ::std::mem::size_of::<xrt_xclbin_ip>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_xclbin_ip))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_xclbin_ip>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_xclbin_ip))
    );
}
extern "C" {
    #[doc = " get_name() - Get name of IP\n\n @return\n  IP name."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip8get_nameB5cxx11Ev"]
    pub fn xrt_xclbin_ip_get_name(this: *const xrt_xclbin_ip) -> std_string;
}
extern "C" {
    #[doc = " get_type() - Get the IP type\n\n @return\n  IP type"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip8get_typeEv"]
    pub fn xrt_xclbin_ip_get_type(this: *const xrt_xclbin_ip) -> xrt_xclbin_ip_ip_type;
}
extern "C" {
    #[doc = " get_control_type() - Get the IP control protocol\n\n @return\n  Control type"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip16get_control_typeEv"]
    pub fn xrt_xclbin_ip_get_control_type(this: *const xrt_xclbin_ip)
        -> xrt_xclbin_ip_control_type;
}
extern "C" {
    #[doc = " get_num_args() - Number of arguments\n\n @return\n  Number of arguments for this IP per CONNECTIVITY section"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip12get_num_argsEv"]
    pub fn xrt_xclbin_ip_get_num_args(this: *const xrt_xclbin_ip) -> usize;
}
extern "C" {
    #[doc = " get_args() - Get list of IP arguments\n\n @return\n  A list sorted of xclbin::arg sorted by argument indices\n\n An argument may have multiple memory connections"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip8get_argsEv"]
    pub fn xrt_xclbin_ip_get_args(this: *const xrt_xclbin_ip) -> u8;
}
extern "C" {
    #[doc = " get_arg() - Get argument at index.\n\n @param index\n  Index of argument\n @return\n  The argument a specified index\n\n The argument may have multiple memory connections"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip7get_argEi"]
    pub fn xrt_xclbin_ip_get_arg(this: *const xrt_xclbin_ip, index: i32) -> xrt_xclbin_arg;
}
extern "C" {
    #[doc = " get_base_address() - Get the base address of the cu\n\n @return\n  The base address of the IP"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip16get_base_addressEv"]
    pub fn xrt_xclbin_ip_get_base_address(this: *const xrt_xclbin_ip) -> u64;
}
extern "C" {
    #[doc = " get_size() - Get the address range size of this IP.\n\n @return\n  The size of this IP\n\n The address range is a property of the kernel and\n as such only valid for for kernel compute units.\n\n For IPs that are not associated with a kernel, the\n size return is 0."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin2ip8get_sizeEv"]
    pub fn xrt_xclbin_ip_get_size(this: *const xrt_xclbin_ip) -> usize;
}
impl xrt_xclbin_ip {
    #[inline]
    pub unsafe fn get_name(&self) -> std_string {
        xrt_xclbin_ip_get_name(self)
    }
    #[inline]
    pub unsafe fn get_type(&self) -> xrt_xclbin_ip_ip_type {
        xrt_xclbin_ip_get_type(self)
    }
    #[inline]
    pub unsafe fn get_control_type(&self) -> xrt_xclbin_ip_control_type {
        xrt_xclbin_ip_get_control_type(self)
    }
    #[inline]
    pub unsafe fn get_num_args(&self) -> usize {
        xrt_xclbin_ip_get_num_args(self)
    }
    #[inline]
    pub unsafe fn get_args(&self) -> u8 {
        xrt_xclbin_ip_get_args(self)
    }
    #[inline]
    pub unsafe fn get_arg(&self, index: i32) -> xrt_xclbin_arg {
        xrt_xclbin_ip_get_arg(self, index)
    }
    #[inline]
    pub unsafe fn get_base_address(&self) -> u64 {
        xrt_xclbin_ip_get_base_address(self)
    }
    #[inline]
    pub unsafe fn get_size(&self) -> usize {
        xrt_xclbin_ip_get_size(self)
    }
}
#[doc = " class kernel\n\n @brief\n xrt::xclbin::kernel represents a kernel in an xclbin.\n\n @details\n The kernel corresponds to an entry in the XML meta data section\n of the xclbin combined with meta data from other xclbin sections.\n The kernel object is implicitly constructed from the xclbin\n object via APIs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_kernel_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_kernel {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_xrt_xclbin_kernel() {
    assert_eq!(
        ::std::mem::size_of::<xrt_xclbin_kernel>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_xclbin_kernel))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_xclbin_kernel>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_xclbin_kernel))
    );
}
extern "C" {
    #[doc = " get_name() - Get kernel name\n\n @return\n  The name of the kernel"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel8get_nameB5cxx11Ev"]
    pub fn xrt_xclbin_kernel_get_name(this: *const xrt_xclbin_kernel) -> std_string;
}
extern "C" {
    #[doc = " get_cus() - Get list of cu from kernel.\n\n @return\n  A list of xrt::xclbin::ip objects corresponding the compute units\n  for this kernel object."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel7get_cusEv"]
    pub fn xrt_xclbin_kernel_get_cus(this: *const xrt_xclbin_kernel) -> u8;
}
extern "C" {
    #[doc = " get_cus() - Get list of compute units that matches name\n\n @param name\n  Name to match against, prefixed with kernel name\n @return\n  A list of xrt::xclbin::ip objects that are compute units\n  of this kernel object and matches the specified name.\n\n The kernel name can optionally specify which kernel instance(s) to\n match \"kernel:{cu1,cu2,...} syntax."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel7get_cusERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_xclbin_kernel_get_cus1(
        this: *const xrt_xclbin_kernel,
        name: *const std_string,
    ) -> u8;
}
extern "C" {
    #[doc = " get_cu() - Get compute unit by name\n\n @return\n  The xct::xclbin::ip object matching the specified name, or error if\n  not present."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel6get_cuERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_xclbin_kernel_get_cu(
        this: *const xrt_xclbin_kernel,
        name: *const std_string,
    ) -> xrt_xclbin_ip;
}
extern "C" {
    #[doc = " get_num_args() - Number of arguments\n\n @return\n  Number of arguments for this kernel."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel12get_num_argsEv"]
    pub fn xrt_xclbin_kernel_get_num_args(this: *const xrt_xclbin_kernel) -> usize;
}
extern "C" {
    #[doc = " get_args() - Get list of kernel arguments\n\n @return\n  A list sorted of xclbin::arg sorted by argument indices\n\n An argument may have multiple memory connections"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel8get_argsEv"]
    pub fn xrt_xclbin_kernel_get_args(this: *const xrt_xclbin_kernel) -> u8;
}
extern "C" {
    #[doc = " get_arg() - Get kernel argument at index.\n\n @return\n  The xrt::xclbin::arg object at specified argument index.\n\n The memory connections of an argument is the union of the\n connections for each compute unit for that particular argument.\n In other words, for each connection of the argument returned\n by ``get_arg()`` there is at least one compute unit that has\n that connection."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6kernel7get_argEi"]
    pub fn xrt_xclbin_kernel_get_arg(this: *const xrt_xclbin_kernel, index: i32) -> xrt_xclbin_arg;
}
impl xrt_xclbin_kernel {
    #[inline]
    pub unsafe fn get_name(&self) -> std_string {
        xrt_xclbin_kernel_get_name(self)
    }
    #[inline]
    pub unsafe fn get_cus(&self) -> u8 {
        xrt_xclbin_kernel_get_cus(self)
    }
    #[inline]
    pub unsafe fn get_cus1(&self, name: *const std_string) -> u8 {
        xrt_xclbin_kernel_get_cus1(self, name)
    }
    #[inline]
    pub unsafe fn get_cu(&self, name: *const std_string) -> xrt_xclbin_ip {
        xrt_xclbin_kernel_get_cu(self, name)
    }
    #[inline]
    pub unsafe fn get_num_args(&self) -> usize {
        xrt_xclbin_kernel_get_num_args(self)
    }
    #[inline]
    pub unsafe fn get_args(&self) -> u8 {
        xrt_xclbin_kernel_get_args(self)
    }
    #[inline]
    pub unsafe fn get_arg(&self, index: i32) -> xrt_xclbin_arg {
        xrt_xclbin_kernel_get_arg(self, index)
    }
}
#[doc = " @cond\n** undocumented access to aie metadata, subject to change **/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_aie_partition_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct xrt_xclbin_aie_partition {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_xrt_xclbin_aie_partition() {
    assert_eq!(
        ::std::mem::size_of::<xrt_xclbin_aie_partition>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_xclbin_aie_partition))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_xclbin_aie_partition>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_xclbin_aie_partition))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3xrt6xclbin13aie_partition25get_inference_fingerprintEv"]
    pub fn xrt_xclbin_aie_partition_get_inference_fingerprint(
        this: *const xrt_xclbin_aie_partition,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3xrt6xclbin13aie_partition24get_pre_post_fingerprintEv"]
    pub fn xrt_xclbin_aie_partition_get_pre_post_fingerprint(
        this: *const xrt_xclbin_aie_partition,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3xrt6xclbin13aie_partition24get_operations_per_cycleEv"]
    pub fn xrt_xclbin_aie_partition_get_operations_per_cycle(
        this: *const xrt_xclbin_aie_partition,
    ) -> u32;
}
impl xrt_xclbin_aie_partition {
    #[inline]
    pub unsafe fn get_inference_fingerprint(&self) -> u64 {
        xrt_xclbin_aie_partition_get_inference_fingerprint(self)
    }
    #[inline]
    pub unsafe fn get_pre_post_fingerprint(&self) -> u64 {
        xrt_xclbin_aie_partition_get_pre_post_fingerprint(self)
    }
    #[inline]
    pub unsafe fn get_operations_per_cycle(&self) -> u32 {
        xrt_xclbin_aie_partition_get_operations_per_cycle(self)
    }
}
#[test]
fn bindgen_test_layout_xrt_xclbin() {
    assert_eq!(
        ::std::mem::size_of::<xrt_xclbin>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_xclbin))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_xclbin>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_xclbin))
    );
}
extern "C" {
    #[doc = " get_kernels() - Get list of kernels from xclbin.\n\n @return\n  A list of xrt::xclbin::kernel from xclbin.\n\n Kernels are extracted from embedded XML metadata in the xclbin.\n A kernel groups one or more compute units. A kernel has arguments\n from which offset, type, etc can be retrived."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin11get_kernelsEv"]
    pub fn xrt_xclbin_get_kernels(this: *const xrt_xclbin) -> u8;
}
extern "C" {
    #[doc = " get_kernel() - Get a kernel by name from xclbin\n\n @param name\n  Name of kernel to get.\n @return\n  The matching kernel from the xclbin or error\n  if no matching kernel is found.\n\n A matching kernel is extracted from embedded XML metadata in the\n xclbin.  A kernel groups one or more compute units. A kernel has\n arguments from which offset, type, etc can be retrived."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin10get_kernelERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_xclbin_get_kernel(
        this: *const xrt_xclbin,
        name: *const std_string,
    ) -> xrt_xclbin_kernel;
}
extern "C" {
    #[doc = " get_ips() - Get a list of IPs from the xclbin\n\n @return\n  A list of xrt::xclbin::ip objects from xclbin.\n\n The returned xrt::xclbin::ip objects are extracted from the\n IP_LAYOUT section of the xclbin."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin7get_ipsEv"]
    pub fn xrt_xclbin_get_ips(this: *const xrt_xclbin) -> u8;
}
extern "C" {
    #[doc = " get_ips() - Get list of ips that matches name\n\n @param name\n  Name to match against, prefixed with kernel name\n @return\n  A list of xrt::xclbin::ip objects that are compute units\n  of this kernel object and matches the specified name.\n\n The kernel name can optionally specify which kernel instance(s) to\n match \"kernel:{ip1,ip2,...} syntax."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin7get_ipsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_xclbin_get_ips1(this: *const xrt_xclbin, name: *const std_string) -> u8;
}
extern "C" {
    #[doc = " get_ip() - Get a specific IP from the xclbin\n\n @return\n  A list of xrt::xclbin::ip objects from xclbin.\n\n The returned xrt::xclbin::ip object is extracted from the\n IP_LAYOUT section of the xclbin."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin6get_ipERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_xclbin_get_ip(this: *const xrt_xclbin, name: *const std_string) -> xrt_xclbin_ip;
}
extern "C" {
    #[doc = " get_mems() - Get list of memory objects\n\n @return\n A list of xrt::xclbin::mem objects from xclbin\n\n The returned xrt::xclbin::mem objects are extracted from\n the xclbin."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin8get_memsEv"]
    pub fn xrt_xclbin_get_mems(this: *const xrt_xclbin) -> u8;
}
extern "C" {
    #[doc = " @cond"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin18get_aie_partitionsEv"]
    pub fn xrt_xclbin_get_aie_partitions(this: *const xrt_xclbin) -> u8;
}
extern "C" {
    #[doc = " get_xsa_name() - Get Xilinx Support Archive (XSA) name of xclbin\n\n @return\n  Name of XSA (vbnv name).\n\n An exception is thrown if the data is missing."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin12get_xsa_nameB5cxx11Ev"]
    pub fn xrt_xclbin_get_xsa_name(this: *const xrt_xclbin) -> std_string;
}
extern "C" {
    #[doc = " get_fpga_device_name() - Get FPGA device name\n\n @return\n  Name of fpga device per XML metadata."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin20get_fpga_device_nameB5cxx11Ev"]
    pub fn xrt_xclbin_get_fpga_device_name(this: *const xrt_xclbin) -> std_string;
}
extern "C" {
    #[doc = " get_uuid() - Get the uuid of the xclbin\n\n @return\n  UUID of xclbin\n\n An exception is thrown if the data is missing."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin8get_uuidEv"]
    pub fn xrt_xclbin_get_uuid(this: *const xrt_xclbin) -> xrt_uuid;
}
extern "C" {
    #[doc = " get_interface_uuid() - Get the interface uuid of the xclbin\n\n @return\n  Interface uuid of the xclbin\n\n An exception is thrown if the data is missing."]
    #[link_name = "\u{1}_ZNK3xrt6xclbin18get_interface_uuidEv"]
    pub fn xrt_xclbin_get_interface_uuid(this: *const xrt_xclbin) -> xrt_uuid;
}
extern "C" {
    #[doc = " get_target_type() - Get the type of this xclbin\n\n @return\n  Target type, which can be hw, sw_emu, or hw_emu"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin15get_target_typeEv"]
    pub fn xrt_xclbin_get_target_type(this: *const xrt_xclbin) -> xrt_xclbin_target_type;
}
extern "C" {
    #[doc = " @cond\n**\n* get_axlf() - Get the axlf data of the xclbin\n*\n* @return\n*  The axlf data of the xclbin object\n*\n* An exception is thrown if the data is missing.\n*/"]
    #[link_name = "\u{1}_ZNK3xrt6xclbin8get_axlfEv"]
    pub fn xrt_xclbin_get_axlf(this: *const xrt_xclbin) -> *const axlf;
}
extern "C" {
    #[doc = " xclbin() - Constructor from an xclbin filename\n\n @param filename\n  Path to the xclbin file\n\n Throws if file not found."]
    #[link_name = "\u{1}_ZN3xrt6xclbinC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_xclbin_xclbin(this: *mut xrt_xclbin, filename: *const std_string);
}
extern "C" {
    #[doc = " xclbin() - Constructor from raw data\n\n @param data\n  Raw data of xclbin\n\n The raw data of the xclbin can be deleted after calling the\n constructor."]
    #[link_name = "\u{1}_ZN3xrt6xclbinC1ERKSt6vectorIcSaIcEE"]
    pub fn xrt_xclbin_xclbin1(this: *mut xrt_xclbin, data: *const u8);
}
extern "C" {
    #[doc = " xclbin() - Constructor from raw data\n\n @param top\n  Raw data of xclbin file as axlf*\n\n The argument axlf is copied by the constructor."]
    #[link_name = "\u{1}_ZN3xrt6xclbinC1EPK4axlf"]
    pub fn xrt_xclbin_xclbin2(this: *mut xrt_xclbin, top: *const axlf);
}
impl xrt_xclbin {
    #[inline]
    pub unsafe fn get_kernels(&self) -> u8 {
        xrt_xclbin_get_kernels(self)
    }
    #[inline]
    pub unsafe fn get_kernel(&self, name: *const std_string) -> xrt_xclbin_kernel {
        xrt_xclbin_get_kernel(self, name)
    }
    #[inline]
    pub unsafe fn get_ips(&self) -> u8 {
        xrt_xclbin_get_ips(self)
    }
    #[inline]
    pub unsafe fn get_ips1(&self, name: *const std_string) -> u8 {
        xrt_xclbin_get_ips1(self, name)
    }
    #[inline]
    pub unsafe fn get_ip(&self, name: *const std_string) -> xrt_xclbin_ip {
        xrt_xclbin_get_ip(self, name)
    }
    #[inline]
    pub unsafe fn get_mems(&self) -> u8 {
        xrt_xclbin_get_mems(self)
    }
    #[inline]
    pub unsafe fn get_aie_partitions(&self) -> u8 {
        xrt_xclbin_get_aie_partitions(self)
    }
    #[inline]
    pub unsafe fn get_xsa_name(&self) -> std_string {
        xrt_xclbin_get_xsa_name(self)
    }
    #[inline]
    pub unsafe fn get_fpga_device_name(&self) -> std_string {
        xrt_xclbin_get_fpga_device_name(self)
    }
    #[inline]
    pub unsafe fn get_uuid(&self) -> xrt_uuid {
        xrt_xclbin_get_uuid(self)
    }
    #[inline]
    pub unsafe fn get_interface_uuid(&self) -> xrt_uuid {
        xrt_xclbin_get_interface_uuid(self)
    }
    #[inline]
    pub unsafe fn get_target_type(&self) -> xrt_xclbin_target_type {
        xrt_xclbin_get_target_type(self)
    }
    #[inline]
    pub unsafe fn get_axlf(&self) -> *const axlf {
        xrt_xclbin_get_axlf(self)
    }
    #[inline]
    pub unsafe fn new(filename: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_xclbin_xclbin(__bindgen_tmp.as_mut_ptr(), filename);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(data: *const u8) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_xclbin_xclbin1(__bindgen_tmp.as_mut_ptr(), data);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(top: *const axlf) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_xclbin_xclbin2(__bindgen_tmp.as_mut_ptr(), top);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @class device\n\n @brief\n xrt::device represents used for acceleration."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct xrt_device {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_xrt_device() {
    assert_eq!(
        ::std::mem::size_of::<xrt_device>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_device))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_device>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_device))
    );
}
extern "C" {
    #[doc = " @cond\n Experimental 2022.2\n**\n* register_xclbin() - Register an xclbin with the device\n*\n* @param xclbin\n*  xrt::xclbin object\n* @return\n*  UUID of argument xclbin\n*\n* This function registers an xclbin with the device, but\n* does not associate the xclbin with hardware resources.\n*/"]
    #[link_name = "\u{1}_ZN3xrt6device15register_xclbinERKNS_6xclbinE"]
    pub fn xrt_device_register_xclbin(this: *mut xrt_device, xclbin: *const xrt_xclbin)
        -> xrt_uuid;
}
extern "C" {
    #[doc = " load_xclbin() - Load an xclbin\n\n @param xclbin\n  Pointer to xclbin in memory image\n @return\n  UUID of argument xclbin"]
    #[link_name = "\u{1}_ZN3xrt6device11load_xclbinEPK4axlf"]
    pub fn xrt_device_load_xclbin(this: *mut xrt_device, xclbin: *const axlf) -> xrt_uuid;
}
extern "C" {
    #[doc = " load_xclbin() - Read and load an xclbin file\n\n @param xclbin_fnm\n  Full path to xclbin file\n @return\n  UUID of argument xclbin\n\n This function reads the file from disk and loads\n the xclbin.   Using this function allows one time\n allocation of data that needs to be kept in memory."]
    #[link_name = "\u{1}_ZN3xrt6device11load_xclbinERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_device_load_xclbin1(
        this: *mut xrt_device,
        xclbin_fnm: *const std_string,
    ) -> xrt_uuid;
}
extern "C" {
    #[doc = " load_xclbin() - load an xclin from an xclbin object\n\n @param xclbin\n  xrt::xclbin object\n @return\n  UUID of argument xclbin\n\n This function uses the specified xrt::xclbin object created by\n caller.  The xrt::xclbin object must contain the complete axlf\n structure."]
    #[link_name = "\u{1}_ZN3xrt6device11load_xclbinERKNS_6xclbinE"]
    pub fn xrt_device_load_xclbin2(this: *mut xrt_device, xclbin: *const xrt_xclbin) -> xrt_uuid;
}
extern "C" {
    #[doc = " get_xclbin_uuid() - Get UUID of xclbin image loaded on device\n\n @return\n  UUID of currently loaded xclbin\n\n Note that current UUID can be different from the UUID of\n the xclbin loaded by this process using load_xclbin()"]
    #[link_name = "\u{1}_ZNK3xrt6device15get_xclbin_uuidEv"]
    pub fn xrt_device_get_xclbin_uuid(this: *const xrt_device) -> xrt_uuid;
}
extern "C" {
    #[link_name = "\u{1}_ZN3xrt6device5resetEv"]
    pub fn xrt_device_reset(this: *mut xrt_device);
}
extern "C" {
    #[doc = " device() - Constructor from device index\n\n @param didx\n  Device index\n\n Throws if no device is found matching the specified index."]
    #[link_name = "\u{1}_ZN3xrt6deviceC1Ej"]
    pub fn xrt_device_device(this: *mut xrt_device, didx: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " device() - Constructor from string\n\n @param bdf\n  String identifying the device to open.\n\n If the string is in BDF format it matched against devices\n installed on the system.  Otherwise the string is assumed\n to be a device index.\n\n Throws if string format is invalid or no matching device is\n found."]
    #[link_name = "\u{1}_ZN3xrt6deviceC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_device_device1(this: *mut xrt_device, bdf: *const std_string);
}
extern "C" {
    #[doc = " device() - Create a managed device object from a shim xclDeviceHandle\n\n @param dhdl\n  Shim xclDeviceHandle\n @return\n  xrt::device object epresenting the opened device, or exception on error"]
    #[link_name = "\u{1}_ZN3xrt6deviceC1EPv"]
    pub fn xrt_device_device2(this: *mut xrt_device, dhdl: xclDeviceHandle);
}
impl xrt_device {
    #[inline]
    pub unsafe fn register_xclbin(&mut self, xclbin: *const xrt_xclbin) -> xrt_uuid {
        xrt_device_register_xclbin(self, xclbin)
    }
    #[inline]
    pub unsafe fn load_xclbin(&mut self, xclbin: *const axlf) -> xrt_uuid {
        xrt_device_load_xclbin(self, xclbin)
    }
    #[inline]
    pub unsafe fn load_xclbin1(&mut self, xclbin_fnm: *const std_string) -> xrt_uuid {
        xrt_device_load_xclbin1(self, xclbin_fnm)
    }
    #[inline]
    pub unsafe fn load_xclbin2(&mut self, xclbin: *const xrt_xclbin) -> xrt_uuid {
        xrt_device_load_xclbin2(self, xclbin)
    }
    #[inline]
    pub unsafe fn get_xclbin_uuid(&self) -> xrt_uuid {
        xrt_device_get_xclbin_uuid(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        xrt_device_reset(self)
    }
    #[inline]
    pub unsafe fn new(didx: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_device_device(__bindgen_tmp.as_mut_ptr(), didx);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(bdf: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_device_device1(__bindgen_tmp.as_mut_ptr(), bdf);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(dhdl: xclDeviceHandle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_device_device2(__bindgen_tmp.as_mut_ptr(), dhdl);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " class hw_context -- manage hw resources\n\n A hardware context associates an xclbin with hardware\n resources.  Prior to creating a context, the xclbin\n must be registered with the device (`xrt::device::register_xclbin`)\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_hw_context_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_hw_context {
    pub _base: xrt_detail_pimpl,
}
#[doc = " Experimental specification of Configuration Parameters which contains QoS and Communication Channel requirements\n\n Free formed key-value entry.\n\n Supported keys are:\n  - gops                   // giga operations per second\n  - fps                    // frames per second\n  - dma_bandwidth          // gigabytes per second\n  - latency                // ??\n  - frame_execution_time   // ??\n  - priority               // ??\n  - enable_isp_channel     // toggle isp communication\n  - enable_acp_channel     // toggle acp communication\n\n Currently ignored for legacy platforms"]
pub type xrt_hw_context_cfg_param_type = [u64; 6usize];
pub type xrt_hw_context_qos_type = xrt_hw_context_cfg_param_type;
pub const xrt_hw_context_access_mode_exclusive: xrt_hw_context_access_mode = 0;
pub const xrt_hw_context_access_mode_shared: xrt_hw_context_access_mode = 1;
#[doc = " @enum access_mode - legacy access mode\n\n @var exclusive\n  Create a context for exclusive access to shareable resources.\n  Legacy compute unit access control.\n @var shared\n  Create a context for shared access to shareable resources\n  Legacy compute unit access control.\n\n Access mode is mutually exclusive with qos"]
pub type xrt_hw_context_access_mode = u8;
#[test]
fn bindgen_test_layout_xrt_hw_context() {
    assert_eq!(
        ::std::mem::size_of::<xrt_hw_context>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_hw_context))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_hw_context>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_hw_context))
    );
}
extern "C" {
    #[doc = "@cond"]
    #[link_name = "\u{1}_ZN3xrt10hw_context10update_qosERKSt3mapINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEjSt4lessIS7_ESaISt4pairIKS7_jEEE"]
    pub fn xrt_hw_context_update_qos(
        this: *mut xrt_hw_context,
        qos: *const xrt_hw_context_qos_type,
    );
}
extern "C" {
    #[doc = " get_device() - Device from which context was created"]
    #[link_name = "\u{1}_ZNK3xrt10hw_context10get_deviceEv"]
    pub fn xrt_hw_context_get_device(this: *const xrt_hw_context) -> xrt_device;
}
extern "C" {
    #[doc = " get_xclbin_uuid() - UUID of xclbin from which context was created"]
    #[link_name = "\u{1}_ZNK3xrt10hw_context15get_xclbin_uuidEv"]
    pub fn xrt_hw_context_get_xclbin_uuid(this: *const xrt_hw_context) -> xrt_uuid;
}
extern "C" {
    #[doc = " get_xclbin() - Retrieve underlying xclbin matching the UUID"]
    #[link_name = "\u{1}_ZNK3xrt10hw_context10get_xclbinEv"]
    pub fn xrt_hw_context_get_xclbin(this: *const xrt_hw_context) -> xrt_xclbin;
}
extern "C" {
    #[doc = " get_mode() - Get the context access mode"]
    #[link_name = "\u{1}_ZNK3xrt10hw_context8get_modeEv"]
    pub fn xrt_hw_context_get_mode(this: *const xrt_hw_context) -> xrt_hw_context_access_mode;
}
extern "C" {
    #[doc = " hw_context() - Constructor with QoS control\n\n @param device\n  Device where context is created\n @param xclbin_id\n  UUID of xclbin that should be assigned to HW resources\n @cfg_param\n  Configuration Parameters (incl. Quality of Service)\n\n The QoS definition is subject to change, so this API is not guaranteed\n to be ABI compatible in future releases."]
    #[link_name = "\u{1}_ZN3xrt10hw_contextC1ERKNS_6deviceERKNS_4uuidERKSt3mapINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEjSt4lessISD_ESaISt4pairIKSD_jEEE"]
    pub fn xrt_hw_context_hw_context(
        this: *mut xrt_hw_context,
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        cfg_param: *const xrt_hw_context_cfg_param_type,
    );
}
extern "C" {
    #[doc = " hw_context() - Construct with specific access control\n\n @param device\n  Device where context is created\n @param xclbin_id\n  UUID of xclbin that should be assigned to HW resources\n @param mode\n  Access control for the context"]
    #[link_name = "\u{1}_ZN3xrt10hw_contextC1ERKNS_6deviceERKNS_4uuidENS0_11access_modeE"]
    pub fn xrt_hw_context_hw_context1(
        this: *mut xrt_hw_context,
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        mode: xrt_hw_context_access_mode,
    );
}
impl xrt_hw_context {
    #[inline]
    pub unsafe fn update_qos(&mut self, qos: *const xrt_hw_context_qos_type) {
        xrt_hw_context_update_qos(self, qos)
    }
    #[inline]
    pub unsafe fn get_device(&self) -> xrt_device {
        xrt_hw_context_get_device(self)
    }
    #[inline]
    pub unsafe fn get_xclbin_uuid(&self) -> xrt_uuid {
        xrt_hw_context_get_xclbin_uuid(self)
    }
    #[inline]
    pub unsafe fn get_xclbin(&self) -> xrt_xclbin {
        xrt_hw_context_get_xclbin(self)
    }
    #[inline]
    pub unsafe fn get_mode(&self) -> xrt_hw_context_access_mode {
        xrt_hw_context_get_mode(self)
    }
    #[inline]
    pub unsafe fn new(
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        cfg_param: *const xrt_hw_context_cfg_param_type,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_hw_context_hw_context(__bindgen_tmp.as_mut_ptr(), device, xclbin_id, cfg_param);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        mode: xrt_hw_context_access_mode,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_hw_context_hw_context1(__bindgen_tmp.as_mut_ptr(), device, xclbin_id, mode);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @class ip\n\n @brief\n xrt::ip represent the custom IP\n\n @details The ip can be controlled through read- and write register\n only.  If the IP supports interrupt notification, then xrt::ip\n objects supports enabling and control of underlying IP interrupt.\n\n In order to construct an ip object, the following requirements must be met:\n\n   - The custom IP must appear in IP_LAYOUT section of xclbin.\n   - The custom IP must have a base address such that it can be controlled\n     through register access at offsets from base address.\n   - The custom IP must have an address range so that write and read access\n     to base address offset can be validated.\n   - XRT supports exclusive access only for the custom IP, this is to other\n     processes from accessing the same IP at the same time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_ip_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_ip {
    pub _base: xrt_detail_pimpl,
}
#[doc = " @class interrupt\n\n @brief\n xrt::ip::interrupt represents an IP interrupt event.\n\n This class represents an IP interrupt event.  The interrupt\n object is contructed via `xrt::ip::create_interrupt_notify()`.\n The object can be used to enable and disable IP interrupts\n and to wait for an interrupt to occur.\n\n Upon construction, the IP interrupt is automatically enabled."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xrt_ip_interrupt_impl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct xrt_ip_interrupt {
    pub _base: xrt_detail_pimpl,
}
#[test]
fn bindgen_test_layout_xrt_ip_interrupt() {
    assert_eq!(
        ::std::mem::size_of::<xrt_ip_interrupt>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_ip_interrupt))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_ip_interrupt>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_ip_interrupt))
    );
}
extern "C" {
    #[doc = " enable() - Enable interrupt\n\n Enables the IP interrupt if not already enabled.  The\n IP interrupt is automatically enabled when the interrupt\n object is created."]
    #[link_name = "\u{1}_ZN3xrt2ip9interrupt6enableEv"]
    pub fn xrt_ip_interrupt_enable(this: *mut xrt_ip_interrupt);
}
extern "C" {
    #[doc = " disable() - Disable interrupt\n\n Disables the IP interrupt notification from IP."]
    #[link_name = "\u{1}_ZN3xrt2ip9interrupt7disableEv"]
    pub fn xrt_ip_interrupt_disable(this: *mut xrt_ip_interrupt);
}
extern "C" {
    #[doc = " wait() - Wait for interrupt\n\n Wait for interrupt from IP. Upon return, interrupt is\n re-enabled."]
    #[link_name = "\u{1}_ZN3xrt2ip9interrupt4waitEv"]
    pub fn xrt_ip_interrupt_wait(this: *mut xrt_ip_interrupt);
}
extern "C" {
    #[doc = " wait() - Wait for interrupt or timeout to occur\n\n @param timeout\n   Timout in milliseconds.\n @return\n   std::cv_status::timeout if the timeout specified expired,\n   std::cv_status::no_timeout otherwise.\n\n Blocks the current thread until an interrupt is received from the IP,  or\n until after the specified timeout duration"]
    #[link_name = "\u{1}_ZNK3xrt2ip9interrupt4waitERKNSt6chrono8durationIlSt5ratioILl1ELl1000EEEE"]
    pub fn xrt_ip_interrupt_wait1(
        this: *const xrt_ip_interrupt,
        timeout: *const std_chrono_milliseconds,
    ) -> std_cv_status;
}
impl xrt_ip_interrupt {
    #[inline]
    pub unsafe fn enable(&mut self) {
        xrt_ip_interrupt_enable(self)
    }
    #[inline]
    pub unsafe fn disable(&mut self) {
        xrt_ip_interrupt_disable(self)
    }
    #[inline]
    pub unsafe fn wait(&mut self) {
        xrt_ip_interrupt_wait(self)
    }
    #[inline]
    pub unsafe fn wait1(&self, timeout: *const std_chrono_milliseconds) -> std_cv_status {
        xrt_ip_interrupt_wait1(self, timeout)
    }
}
#[test]
fn bindgen_test_layout_xrt_ip() {
    assert_eq!(
        ::std::mem::size_of::<xrt_ip>(),
        16usize,
        concat!("Size of: ", stringify!(xrt_ip))
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_ip>(),
        8usize,
        concat!("Alignment of ", stringify!(xrt_ip))
    );
}
extern "C" {
    #[doc = " write_register() - Write to the address range of an ip\n\n @param offset\n  Offset in register space to write to\n @param data\n  Data to write\n\n Throws std::out_or_range if offset is outside the\n ip address space"]
    #[link_name = "\u{1}_ZN3xrt2ip14write_registerEjj"]
    pub fn xrt_ip_write_register(this: *mut xrt_ip, offset: u32, data: u32);
}
extern "C" {
    #[doc = " read_register() - Read data from ip address range\n\n @param offset\n  Offset in register space to read from\n @return\n  Value read from offset\n\n Throws std::out_or_range if offset is outside the\n ip address space"]
    #[link_name = "\u{1}_ZNK3xrt2ip13read_registerEj"]
    pub fn xrt_ip_read_register(this: *const xrt_ip, offset: u32) -> u32;
}
extern "C" {
    #[doc = " create_interrupt_notify() - Create xrt::ip::interrupt object\n\n @return\n  xrt::ip::interrupt object can be used to control IP interrupt.\n\n This function creates an xrt::ip::interrupt object that can be\n used to control and wait for IP interrupt.   On successful\n return the IP has interrupt enabled.\n\n Throws if the custom IP doesn't support interrupts."]
    #[link_name = "\u{1}_ZN3xrt2ip23create_interrupt_notifyEv"]
    pub fn xrt_ip_create_interrupt_notify(this: *mut xrt_ip) -> xrt_ip_interrupt;
}
extern "C" {
    #[doc = " ip() - Constructor from a device and xclbin\n\n @param device\n  Device programmed with the IP\n @param xclbin_id\n  UUID of the xclbin with the IP\n @param name\n  Name of IP to construct\n\n The IP is opened with exclusive access meaning that no other\n xrt::ip objects can use the same IP, nor will another process be\n able to use the IP while one process has been granted access.\n\n Constructor throws on error."]
    #[link_name = "\u{1}_ZN3xrt2ipC1ERKNS_6deviceERKNS_4uuidERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_ip_ip(
        this: *mut xrt_ip,
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        name: *const std_string,
    );
}
extern "C" {
    #[doc = " @cond\n Experimental in 2022.2"]
    #[link_name = "\u{1}_ZN3xrt2ipC1ERKNS_10hw_contextERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn xrt_ip_ip1(this: *mut xrt_ip, ctx: *const xrt_hw_context, name: *const std_string);
}
impl xrt_ip {
    #[inline]
    pub unsafe fn write_register(&mut self, offset: u32, data: u32) {
        xrt_ip_write_register(self, offset, data)
    }
    #[inline]
    pub unsafe fn read_register(&self, offset: u32) -> u32 {
        xrt_ip_read_register(self, offset)
    }
    #[inline]
    pub unsafe fn create_interrupt_notify(&mut self) -> xrt_ip_interrupt {
        xrt_ip_create_interrupt_notify(self)
    }
    #[inline]
    pub unsafe fn new(
        device: *const xrt_device,
        xclbin_id: *const xrt_uuid,
        name: *const std_string,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_ip_ip(__bindgen_tmp.as_mut_ptr(), device, xclbin_id, name);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(ctx: *const xrt_hw_context, name: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xrt_ip_ip1(__bindgen_tmp.as_mut_ptr(), ctx, name);
        __bindgen_tmp.assume_init()
    }
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_hw_context_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_ip_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_xrt_detail_pimpl_open0_xrt_ip_interrupt_impl_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<xrt_detail_pimpl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xrt_detail_pimpl>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(xrt_detail_pimpl)
        )
    );
}
