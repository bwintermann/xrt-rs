/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _SYS_TIME_H: u32 = 1;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const UUID_VARIANT_NCS: u32 = 0;
pub const UUID_VARIANT_DCE: u32 = 1;
pub const UUID_VARIANT_MICROSOFT: u32 = 2;
pub const UUID_VARIANT_OTHER: u32 = 3;
pub const UUID_VARIANT_SHIFT: u32 = 5;
pub const UUID_VARIANT_MASK: u32 = 7;
pub const UUID_TYPE_DCE_NIL: u32 = 0;
pub const UUID_TYPE_DCE_TIME: u32 = 1;
pub const UUID_TYPE_DCE_SECURITY: u32 = 2;
pub const UUID_TYPE_DCE_MD5: u32 = 3;
pub const UUID_TYPE_DCE_RANDOM: u32 = 4;
pub const UUID_TYPE_DCE_SHA1: u32 = 5;
pub const UUID_TYPE_SHIFT: u32 = 4;
pub const UUID_TYPE_MASK: u32 = 15;
pub const UUID_STR_LEN: u32 = 37;
pub const XCLBIN_MAX_NUM_SECTION: u32 = 65536;
pub const IP_INT_ENABLE_MASK: u32 = 1;
pub const IP_INTERRUPT_ID_MASK: u32 = 254;
pub const IP_INTERRUPT_ID_SHIFT: u32 = 1;
pub const IP_CONTROL_MASK: u32 = 65280;
pub const IP_CONTROL_SHIFT: u32 = 8;
pub const PDI_IMAGE_MAX_SIZE: u32 = 134217728;
pub const XRT_BO_FLAGS_MEMIDX_MASK: u32 = 16777215;
pub const XCL_BO_FLAGS_NONE: u32 = 0;
pub const XCL_BO_FLAGS_CACHEABLE: u32 = 16777216;
pub const XCL_BO_FLAGS_KERNBUF: u32 = 33554432;
pub const XCL_BO_FLAGS_SGL: u32 = 67108864;
pub const XCL_BO_FLAGS_SVM: u32 = 134217728;
pub const XCL_BO_FLAGS_DEV_ONLY: u32 = 268435456;
pub const XCL_BO_FLAGS_HOST_ONLY: u32 = 536870912;
pub const XCL_BO_FLAGS_P2P: u32 = 1073741824;
pub const XCL_BO_FLAGS_EXECBUF: u32 = 2147483648;
pub const XRT_BO_FLAGS_NONE: u32 = 0;
pub const XRT_BO_FLAGS_CACHEABLE: u32 = 16777216;
pub const XRT_BO_FLAGS_DEV_ONLY: u32 = 268435456;
pub const XRT_BO_FLAGS_HOST_ONLY: u32 = 536870912;
pub const XRT_BO_FLAGS_P2P: u32 = 1073741824;
pub const XRT_BO_FLAGS_SVM: u32 = 134217728;
pub const DSA_MAJOR_VERSION: u32 = 1;
pub const DSA_MINOR_VERSION: u32 = 1;
pub const IP_LAYOUT_HOST_NAME: &[u8; 5] = b"HOST\0";
pub const IP_LAYOUT_SEP: &[u8; 2] = b"-\0";
pub const XPAR_AXI_PERF_MON_0_NUMBER_SLOTS: u32 = 2;
pub const XPAR_AXI_PERF_MON_0_SLOT0_NAME: &[u8; 11] = b"OCL Region\0";
pub const XPAR_AXI_PERF_MON_0_SLOT1_NAME: &[u8; 5] = b"Host\0";
pub const XPAR_AXI_PERF_MON_0_OCL_REGION_SLOT: u32 = 0;
pub const XPAR_AXI_PERF_MON_0_HOST_SLOT: u32 = 1;
pub const XPAR_AIM0_HOST_SLOT: u32 = 0;
pub const XPAR_AIM0_FIRST_KERNEL_SLOT: u32 = 1;
pub const XPAR_AXI_PERF_MON_0_OCL_REGION_SLOT2: u32 = 2;
pub const XPAR_AXI_PERF_MON_0_OCL_REGION_SLOT3: u32 = 3;
pub const XPAR_AXI_PERF_MON_0_OCL_REGION_SLOT4: u32 = 4;
pub const XPAR_AXI_PERF_MON_0_OCL_REGION_SLOT5: u32 = 5;
pub const XPAR_AXI_PERF_MON_0_OCL_REGION_SLOT6: u32 = 6;
pub const XPAR_AXI_PERF_MON_0_OCL_REGION_SLOT7: u32 = 7;
pub const XPAR_AXI_PERF_MON_0_SLOT2_NAME: &[u8; 20] = b"OCL Region Master 2\0";
pub const XPAR_AXI_PERF_MON_0_SLOT3_NAME: &[u8; 20] = b"OCL Region Master 3\0";
pub const XPAR_AXI_PERF_MON_0_SLOT4_NAME: &[u8; 20] = b"OCL Region Master 4\0";
pub const XPAR_AXI_PERF_MON_0_SLOT5_NAME: &[u8; 20] = b"OCL Region Master 5\0";
pub const XPAR_AXI_PERF_MON_0_SLOT6_NAME: &[u8; 20] = b"OCL Region Master 6\0";
pub const XPAR_AXI_PERF_MON_0_SLOT7_NAME: &[u8; 20] = b"OCL Region Master 7\0";
pub const XPAR_AXI_PERF_MON_0_SLOT0_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_0_SLOT1_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_0_SLOT2_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_0_SLOT3_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_0_SLOT4_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_0_SLOT5_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_0_SLOT6_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_0_SLOT7_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_0_IS_EVENT_COUNT: u32 = 1;
pub const XPAR_AXI_PERF_MON_0_HAVE_SAMPLED_COUNTERS: u32 = 1;
pub const XPAR_AXI_PERF_MON_0_IS_EVENT_LOG: u32 = 1;
pub const XPAR_AXI_PERF_MON_0_SHOW_AXI_IDS: u32 = 1;
pub const XPAR_AXI_PERF_MON_0_SHOW_AXI_LEN: u32 = 1;
pub const XPAR_AXI_PERF_MON_0_SHOW_AXI_IDS_2DDR: u32 = 0;
pub const XPAR_AXI_PERF_MON_0_SHOW_AXI_LEN_2DDR: u32 = 1;
pub const XPAR_AXI_PERF_MON_0_TRACE_NUMBER_FIFO: u32 = 3;
pub const XPAR_AXI_PERF_MON_0_TRACE_WORD_WIDTH: u32 = 64;
pub const XPAR_AXI_PERF_MON_0_TRACE_NUMBER_SAMPLES: u32 = 8192;
pub const MAX_TRACE_NUMBER_SAMPLES: u32 = 16384;
pub const XPAR_AXI_PERF_MON_0_TRACE_OFFSET_0: u32 = 65536;
pub const XPAR_AXI_PERF_MON_0_TRACE_OFFSET_1: u32 = 69632;
pub const XPAR_AXI_PERF_MON_0_TRACE_OFFSET_2: u32 = 73728;
pub const XPAR_AXI_PERF_MON_0_TRACE_OFFSET_AXI_FULL: u64 = 137438953472;
pub const XPAR_AXI_PERF_MON_0_TRACE_OFFSET_AXI_FULL2: u64 = 17179869184;
pub const XPAR_AXI_PERF_MON_1_NUMBER_SLOTS: u32 = 2;
pub const XPAR_AXI_PERF_MON_1_SLOT0_NAME: &[u8; 16] = b"DMA AXI4 Master\0";
pub const XPAR_AXI_PERF_MON_1_SLOT1_NAME: &[u8; 21] = b"DMA AXI4-Lite Master\0";
pub const XPAR_AXI_PERF_MON_1_SLOT2_NAME: &[u8; 5] = b"Null\0";
pub const XPAR_AXI_PERF_MON_1_SLOT3_NAME: &[u8; 5] = b"Null\0";
pub const XPAR_AXI_PERF_MON_1_SLOT4_NAME: &[u8; 5] = b"Null\0";
pub const XPAR_AXI_PERF_MON_1_SLOT5_NAME: &[u8; 5] = b"Null\0";
pub const XPAR_AXI_PERF_MON_1_SLOT6_NAME: &[u8; 5] = b"Null\0";
pub const XPAR_AXI_PERF_MON_1_SLOT7_NAME: &[u8; 5] = b"Null\0";
pub const XPAR_AXI_PERF_MON_1_SLOT0_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_1_SLOT1_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_1_SLOT2_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_1_SLOT3_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_1_SLOT4_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_1_SLOT5_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_1_SLOT6_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_1_SLOT7_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_1_IS_EVENT_COUNT: u32 = 1;
pub const XPAR_AXI_PERF_MON_1_HAVE_SAMPLED_COUNTERS: u32 = 1;
pub const XPAR_AXI_PERF_MON_1_SCALE_FACTOR: u32 = 1;
pub const XPAR_AXI_PERF_MON_1_IS_EVENT_LOG: u32 = 0;
pub const XPAR_AXI_PERF_MON_1_SHOW_AXI_IDS: u32 = 0;
pub const XPAR_AXI_PERF_MON_1_SHOW_AXI_LEN: u32 = 0;
pub const XPAR_AXI_PERF_MON_1_TRACE_NUMBER_FIFO: u32 = 0;
pub const XPAR_AXI_PERF_MON_1_TRACE_WORD_WIDTH: u32 = 0;
pub const XPAR_AXI_PERF_MON_1_TRACE_NUMBER_SAMPLES: u32 = 0;
pub const XPAR_AXI_PERF_MON_2_NUMBER_SLOTS: u32 = 1;
pub const XPAR_AXI_PERF_MON_2_SLOT0_NAME: &[u8; 8] = b"Kernel0\0";
pub const XPAR_AXI_PERF_MON_2_SLOT1_NAME: &[u8; 8] = b"Kernel1\0";
pub const XPAR_AXI_PERF_MON_2_SLOT2_NAME: &[u8; 8] = b"Kernel2\0";
pub const XPAR_AXI_PERF_MON_2_SLOT3_NAME: &[u8; 8] = b"Kernel3\0";
pub const XPAR_AXI_PERF_MON_2_SLOT4_NAME: &[u8; 8] = b"Kernel4\0";
pub const XPAR_AXI_PERF_MON_2_SLOT5_NAME: &[u8; 8] = b"Kernel5\0";
pub const XPAR_AXI_PERF_MON_2_SLOT6_NAME: &[u8; 8] = b"Kernel6\0";
pub const XPAR_AXI_PERF_MON_2_SLOT7_NAME: &[u8; 8] = b"Kernel7\0";
pub const XPAR_AXI_PERF_MON_2_SLOT0_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_2_SLOT1_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_2_SLOT2_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_2_SLOT3_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_2_SLOT4_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_2_SLOT5_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_2_SLOT6_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_2_SLOT7_DATA_WIDTH: u32 = 512;
pub const XPAR_AXI_PERF_MON_2_IS_EVENT_COUNT: u32 = 0;
pub const XPAR_AXI_PERF_MON_2_HAVE_SAMPLED_COUNTERS: u32 = 0;
pub const XPAR_AXI_PERF_MON_2_NUMBER_COUNTERS: u32 = 0;
pub const XPAR_AXI_PERF_MON_2_SCALE_FACTOR: u32 = 1;
pub const XPAR_AXI_PERF_MON_2_IS_EVENT_LOG: u32 = 1;
pub const XPAR_AXI_PERF_MON_2_SHOW_AXI_IDS: u32 = 0;
pub const XPAR_AXI_PERF_MON_2_SHOW_AXI_LEN: u32 = 0;
pub const XPAR_AXI_PERF_MON_2_TRACE_WORD_WIDTH: u32 = 64;
pub const XPAR_AXI_PERF_MON_2_TRACE_NUMBER_SAMPLES: u32 = 8192;
pub const XPAR_AXI_PERF_MON_2_TRACE_OFFSET_0: u32 = 4096;
pub const XPAR_AXI_PERF_MON_2_TRACE_OFFSET_1: u32 = 8192;
pub const XPAR_AXI_PERF_MON_2_TRACE_OFFSET_2: u32 = 12288;
pub const XAPM_MAX_NUMBER_SLOTS: u32 = 8;
pub const XAIM_MAX_NUMBER_SLOTS: u32 = 34;
pub const XAM_MAX_NUMBER_SLOTS: u32 = 31;
pub const XASM_MAX_NUMBER_SLOTS: u32 = 31;
pub const XAPM_METRIC_COUNTERS_PER_SLOT: u32 = 8;
pub const XAPM_METRIC_WRITE_BYTES: u32 = 0;
pub const XAPM_METRIC_WRITE_TRANX: u32 = 1;
pub const XAPM_METRIC_WRITE_LATENCY: u32 = 2;
pub const XAPM_METRIC_READ_BYTES: u32 = 3;
pub const XAPM_METRIC_READ_TRANX: u32 = 4;
pub const XAPM_METRIC_READ_LATENCY: u32 = 5;
pub const XAPM_METRIC_WRITE_MIN_MAX: u32 = 6;
pub const XAPM_METRIC_READ_MIN_MAX: u32 = 7;
pub const XAPM_METRIC_COUNT0_NAME: &[u8; 17] = b"Write Byte Count\0";
pub const XAPM_METRIC_COUNT1_NAME: &[u8; 24] = b"Write Transaction Count\0";
pub const XAPM_METRIC_COUNT2_NAME: &[u8; 20] = b"Total Write Latency\0";
pub const XAPM_METRIC_COUNT3_NAME: &[u8; 16] = b"Read Byte Count\0";
pub const XAPM_METRIC_COUNT4_NAME: &[u8; 23] = b"Read Transaction Count\0";
pub const XAPM_METRIC_COUNT5_NAME: &[u8; 19] = b"Total Read Latency\0";
pub const XAPM_METRIC_COUNT6_NAME: &[u8; 22] = b"Min/Max Write Latency\0";
pub const XAPM_METRIC_COUNT7_NAME: &[u8; 21] = b"Min/Max Read Latency\0";
pub const XAPM_DEBUG_METRIC_COUNTERS_PER_SLOT: u32 = 4;
pub const MIN_TRACE_ID_AIM: u32 = 0;
pub const MAX_TRACE_ID_AIM: u32 = 61;
pub const MIN_TRACE_ID_AM: u32 = 64;
pub const MAX_TRACE_ID_AM: u32 = 544;
pub const MAX_TRACE_ID_AM_HWEM: u32 = 94;
pub const MIN_TRACE_ID_ASM: u32 = 576;
pub const MAX_TRACE_ID_ASM: u32 = 607;
pub const XAPM_READ_LAST: u32 = 6;
pub const XAPM_READ_FIRST: u32 = 5;
pub const XAPM_READ_ADDR: u32 = 4;
pub const XAPM_RESPONSE: u32 = 3;
pub const XAPM_WRITE_LAST: u32 = 2;
pub const XAPM_WRITE_FIRST: u32 = 1;
pub const XAPM_WRITE_ADDR: u32 = 0;
pub const XAPM_EXT_START: u32 = 2;
pub const XAPM_EXT_STOP: u32 = 1;
pub const XAPM_EXT_EVENT: u32 = 0;
pub const FLAGS_PER_SLOT: u32 = 7;
pub const EXT_EVENTS_PER_SLOT: u32 = 3;
pub const LOOP_ADD_TIME: u32 = 65536;
pub const LOOP_ADD_TIME_AIM: u64 = 17592186044416;
pub const XAM_TRACE_CU_MASK: u32 = 1;
pub const XAM_TRACE_STALL_INT_MASK: u32 = 2;
pub const XAM_TRACE_STALL_STR_MASK: u32 = 4;
pub const XAM_TRACE_STALL_EXT_MASK: u32 = 8;
pub const DRIVER_NAME_ROOT: &[u8; 5] = b"/dev\0";
pub const DEVICE_PREFIX: &[u8; 13] = b"/dri/renderD\0";
pub const NIFD_PREFIX: &[u8; 6] = b"/nifd\0";
pub const SYSFS_NAME_ROOT: &[u8; 22] = b"/sys/bus/pci/devices/\0";
pub const MAX_NAME_LEN: u32 = 256;
pub const XAIM_DEBUG_SAMPLE_COUNTERS_PER_SLOT: u32 = 9;
pub const XAIM_TOTAL_DEBUG_SAMPLE_COUNTERS_PER_SLOT: u32 = 13;
pub const XAIM_WRITE_BYTES_INDEX: u32 = 0;
pub const XAIM_WRITE_TRANX_INDEX: u32 = 1;
pub const XAIM_READ_BYTES_INDEX: u32 = 2;
pub const XAIM_READ_TRANX_INDEX: u32 = 3;
pub const XAIM_OUTSTANDING_COUNT_INDEX: u32 = 4;
pub const XAIM_WRITE_LAST_ADDRESS_INDEX: u32 = 5;
pub const XAIM_WRITE_LAST_DATA_INDEX: u32 = 6;
pub const XAIM_READ_LAST_ADDRESS_INDEX: u32 = 7;
pub const XAIM_READ_LAST_DATA_INDEX: u32 = 8;
pub const XAIM_IOCTL_WRITE_BYTES_INDEX: u32 = 0;
pub const XAIM_IOCTL_WRITE_TRANX_INDEX: u32 = 1;
pub const XAIM_IOCTL_WRITE_LATENCY_INDEX: u32 = 2;
pub const XAIM_IOCTL_WRITE_BUSY_CYCLES_INDEX: u32 = 3;
pub const XAIM_IOCTL_READ_BYTES_INDEX: u32 = 4;
pub const XAIM_IOCTL_READ_TRANX_INDEX: u32 = 5;
pub const XAIM_IOCTL_READ_LATENCY_INDEX: u32 = 6;
pub const XAIM_IOCTL_READ_BUSY_CYCLES_INDEX: u32 = 7;
pub const XAIM_IOCTL_OUTSTANDING_COUNT_INDEX: u32 = 8;
pub const XAIM_IOCTL_WRITE_LAST_ADDRESS_INDEX: u32 = 9;
pub const XAIM_IOCTL_WRITE_LAST_DATA_INDEX: u32 = 10;
pub const XAIM_IOCTL_READ_LAST_ADDRESS_INDEX: u32 = 11;
pub const XAIM_IOCTL_READ_LAST_DATA_INDEX: u32 = 12;
pub const XAM_DEBUG_SAMPLE_COUNTERS_PER_SLOT: u32 = 8;
pub const XAM_TOTAL_DEBUG_COUNTERS_PER_SLOT: u32 = 10;
pub const XAM_ACCEL_EXECUTION_COUNT_INDEX: u32 = 0;
pub const XAM_ACCEL_EXECUTION_CYCLES_INDEX: u32 = 1;
pub const XAM_ACCEL_STALL_INT_INDEX: u32 = 2;
pub const XAM_ACCEL_STALL_STR_INDEX: u32 = 3;
pub const XAM_ACCEL_STALL_EXT_INDEX: u32 = 4;
pub const XAM_ACCEL_MIN_EXECUTION_CYCLES_INDEX: u32 = 5;
pub const XAM_ACCEL_MAX_EXECUTION_CYCLES_INDEX: u32 = 6;
pub const XAM_ACCEL_TOTAL_CU_START_INDEX: u32 = 7;
pub const XAM_IOCTL_EXECUTION_COUNT_INDEX: u32 = 0;
pub const XAM_IOCTL_START_COUNT_INDEX: u32 = 1;
pub const XAM_IOCTL_EXECUTION_CYCLES_INDEX: u32 = 2;
pub const XAM_IOCTL_STALL_INT_INDEX: u32 = 3;
pub const XAM_IOCTL_STALL_STR_INDEX: u32 = 4;
pub const XAM_IOCTL_STALL_EXT_INDEX: u32 = 5;
pub const XAM_IOCTL_BUSY_CYCLES_INDEX: u32 = 6;
pub const XAM_IOCTL_MAX_PARALLEL_ITR_INDEX: u32 = 7;
pub const XAM_IOCTL_MAX_EXECUTION_CYCLES_INDEX: u32 = 8;
pub const XAM_IOCTL_MIN_EXECUTION_CYCLES_INDEX: u32 = 9;
pub const XASM_DEBUG_SAMPLE_COUNTERS_PER_SLOT: u32 = 5;
pub const XASM_NUM_TRANX_INDEX: u32 = 0;
pub const XASM_DATA_BYTES_INDEX: u32 = 1;
pub const XASM_BUSY_CYCLES_INDEX: u32 = 2;
pub const XASM_STALL_CYCLES_INDEX: u32 = 3;
pub const XASM_STARVE_CYCLES_INDEX: u32 = 4;
pub const XLAPC_MAX_NUMBER_SLOTS: u32 = 31;
pub const XLAPC_STATUS_PER_SLOT: u32 = 9;
pub const XLAPC_STATUS_REG_NUM: u32 = 4;
pub const XLAPC_OVERALL_STATUS: u32 = 0;
pub const XLAPC_CUMULATIVE_STATUS_0: u32 = 1;
pub const XLAPC_CUMULATIVE_STATUS_1: u32 = 2;
pub const XLAPC_CUMULATIVE_STATUS_2: u32 = 3;
pub const XLAPC_CUMULATIVE_STATUS_3: u32 = 4;
pub const XLAPC_SNAPSHOT_STATUS_0: u32 = 5;
pub const XLAPC_SNAPSHOT_STATUS_1: u32 = 6;
pub const XLAPC_SNAPSHOT_STATUS_2: u32 = 7;
pub const XLAPC_SNAPSHOT_STATUS_3: u32 = 8;
pub const XSPC_MAX_NUMBER_SLOTS: u32 = 31;
pub const XSPC_STATUS_PER_SLOT: u32 = 3;
pub const XSPC_PC_ASSERTED: u32 = 0;
pub const XSPC_CURRENT_PC: u32 = 1;
pub const XSPC_SNAPSHOT_PC: u32 = 2;
pub const NULLBO: u32 = 4294967295;
pub const XRT_NULL_BO: u32 = 4294967295;
pub const NULLBOEXPORT: i32 = -1;
pub const XRT_NULL_BO_EXPORT: i32 = -1;
pub const XCL_DEVICE_USAGE_COUNT: u32 = 8;
pub const HOST_RW_PATTERN: u32 = 4042322160;
pub const DEVICE_RW_PATTERN: u32 = 252645135;
pub const KDMA_BLOCK_SIZE: u32 = 64;
pub const ERT_WORD_SIZE: u32 = 4;
pub const ERT_CQ_SIZE: u32 = 65536;
pub const ERT_CQ_BASE_ADDR: u32 = 1638400;
pub const ERT_CSR_ADDR: u32 = 1572864;
pub const ERT_STATUS_REGISTER_ADDR: u32 = 1572864;
pub const ERT_STATUS_REGISTER_ADDR0: u32 = 1572864;
pub const ERT_STATUS_REGISTER_ADDR1: u32 = 1572868;
pub const ERT_STATUS_REGISTER_ADDR2: u32 = 1572872;
pub const ERT_STATUS_REGISTER_ADDR3: u32 = 1572876;
pub const ERT_CU_DMA_ENABLE_ADDR: u32 = 1572888;
pub const ERT_CU_DMA_REGISTER_ADDR: u32 = 1572892;
pub const ERT_CU_DMA_REGISTER_ADDR0: u32 = 1572892;
pub const ERT_CU_DMA_REGISTER_ADDR1: u32 = 1572896;
pub const ERT_CU_DMA_REGISTER_ADDR2: u32 = 1572900;
pub const ERT_CU_DMA_REGISTER_ADDR3: u32 = 1572904;
pub const ERT_CQ_SLOT_SIZE_ADDR: u32 = 1572908;
pub const ERT_CU_OFFSET_ADDR: u32 = 1572912;
pub const ERT_CQ_NUMBER_OF_SLOTS_ADDR: u32 = 1572916;
pub const ERT_CU_BASE_ADDRESS_ADDR: u32 = 1572920;
pub const ERT_CQ_BASE_ADDRESS_ADDR: u32 = 1572924;
pub const ERT_CU_ISR_HANDLER_ENABLE_ADDR: u32 = 1572928;
pub const ERT_CU_STATUS_REGISTER_ADDR: u32 = 1572932;
pub const ERT_CU_STATUS_REGISTER_ADDR0: u32 = 1572932;
pub const ERT_CU_STATUS_REGISTER_ADDR1: u32 = 1572936;
pub const ERT_CU_STATUS_REGISTER_ADDR2: u32 = 1572940;
pub const ERT_CU_STATUS_REGISTER_ADDR3: u32 = 1572944;
pub const ERT_CQ_STATUS_ENABLE_ADDR: u32 = 1572948;
pub const ERT_CQ_STATUS_REGISTER_ADDR: u32 = 1572952;
pub const ERT_CQ_STATUS_REGISTER_ADDR0: u32 = 1572952;
pub const ERT_CQ_STATUS_REGISTER_ADDR1: u32 = 1572956;
pub const ERT_CQ_STATUS_REGISTER_ADDR2: u32 = 1572960;
pub const ERT_CQ_STATUS_REGISTER_ADDR3: u32 = 1572964;
pub const ERT_NUMBER_OF_CU_ADDR: u32 = 1572968;
pub const ERT_HOST_INTERRUPT_ENABLE_ADDR: u32 = 1573120;
pub const ERT_INTC_ADDR: u32 = 1092616192;
pub const ERT_INTC_CU_0_31_ADDR: u32 = 0;
pub const ERT_INTC_CU_32_63_ADDR: u32 = 4096;
pub const ERT_INTC_CU_64_95_ADDR: u32 = 8192;
pub const ERT_INTC_CU_96_127_ADDR: u32 = 12288;
pub const ERT_CUISR_LUT_ADDR: u32 = 1573888;
pub const ERT_HLS_MODULE_IDLE: u32 = 1;
pub const ERT_CUDMA_STATE: u32 = 1573656;
pub const ERT_CUISR_STATE: u32 = 1573672;
pub const ERT_INTC_IPR_ADDR: u32 = 1092616196;
pub const ERT_INTC_IER_ADDR: u32 = 1092616200;
pub const ERT_INTC_IAR_ADDR: u32 = 1092616204;
pub const ERT_INTC_MER_ADDR: u32 = 1092616220;
pub const ERT_INTC_CU_0_31_IPR: u32 = 4;
pub const ERT_INTC_CU_0_31_IER: u32 = 8;
pub const ERT_INTC_CU_0_31_IAR: u32 = 12;
pub const ERT_INTC_CU_0_31_MER: u32 = 28;
pub const ERT_INTC_CU_32_63_IPR: u32 = 4100;
pub const ERT_INTC_CU_32_63_IER: u32 = 4104;
pub const ERT_INTC_CU_32_63_IAR: u32 = 4108;
pub const ERT_INTC_CU_32_63_MER: u32 = 4124;
pub const ERT_INTC_CU_64_95_IPR: u32 = 8196;
pub const ERT_INTC_CU_64_95_IER: u32 = 8200;
pub const ERT_INTC_CU_64_95_IAR: u32 = 8204;
pub const ERT_INTC_CU_64_95_MER: u32 = 8220;
pub const ERT_INTC_CU_96_127_IPR: u32 = 12292;
pub const ERT_INTC_CU_96_127_IER: u32 = 12296;
pub const ERT_INTC_CU_96_127_IAR: u32 = 12300;
pub const ERT_INTC_CU_96_127_MER: u32 = 12316;
pub const ERT_CLK_COUNTER_ADDR: u32 = 0;
pub const MAX_DEPS: u32 = 8;
pub const MAX_HEADER_SIZE: u32 = 64;
pub const MAX_CONFIG_PACKET_SIZE: u32 = 512;
pub const MAX_CQ_SLOT_SIZE: u32 = 4096;
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    const UNINIT: ::std::mem::MaybeUninit<timezone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    pub fn gettimeofday(
        __tv: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    const UNINIT: ::std::mem::MaybeUninit<itimerval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type uuid_t = [::std::os::raw::c_uchar; 16usize];
extern "C" {
    pub fn uuid_clear(uu: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn uuid_compare(
        uu1: *mut ::std::os::raw::c_uchar,
        uu2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uuid_copy(dst: *mut ::std::os::raw::c_uchar, src: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn uuid_generate(out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn uuid_generate_random(out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn uuid_generate_time(out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn uuid_generate_time_safe(out: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uuid_generate_md5(
        out: *mut ::std::os::raw::c_uchar,
        ns: *mut ::std::os::raw::c_uchar,
        name: *const ::std::os::raw::c_char,
        len: usize,
    );
}
extern "C" {
    pub fn uuid_generate_sha1(
        out: *mut ::std::os::raw::c_uchar,
        ns: *mut ::std::os::raw::c_uchar,
        name: *const ::std::os::raw::c_char,
        len: usize,
    );
}
extern "C" {
    pub fn uuid_is_null(uu: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uuid_parse(
        in_: *const ::std::os::raw::c_char,
        uu: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uuid_parse_range(
        in_start: *const ::std::os::raw::c_char,
        in_end: *const ::std::os::raw::c_char,
        uu: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uuid_unparse(uu: *mut ::std::os::raw::c_uchar, out: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn uuid_unparse_lower(uu: *mut ::std::os::raw::c_uchar, out: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn uuid_unparse_upper(uu: *mut ::std::os::raw::c_uchar, out: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn uuid_time(uu: *mut ::std::os::raw::c_uchar, ret_tv: *mut timeval) -> time_t;
}
extern "C" {
    pub fn uuid_type(uu: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uuid_variant(uu: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uuid_get_template(alias: *const ::std::os::raw::c_char) -> *const uuid_t;
}
pub type xuid_t = uuid_t;
pub const XCLBIN_MODE_XCLBIN_FLAT: XCLBIN_MODE = 0;
pub const XCLBIN_MODE_XCLBIN_PR: XCLBIN_MODE = 1;
pub const XCLBIN_MODE_XCLBIN_TANDEM_STAGE2: XCLBIN_MODE = 2;
pub const XCLBIN_MODE_XCLBIN_TANDEM_STAGE2_WITH_PR: XCLBIN_MODE = 3;
pub const XCLBIN_MODE_XCLBIN_HW_EMU: XCLBIN_MODE = 4;
pub const XCLBIN_MODE_XCLBIN_SW_EMU: XCLBIN_MODE = 5;
pub const XCLBIN_MODE_XCLBIN_HW_EMU_PR: XCLBIN_MODE = 6;
pub const XCLBIN_MODE_XCLBIN_MODE_MAX: XCLBIN_MODE = 7;
#[doc = " Container format for Xilinx bitstreams, metadata and other\n binary blobs.\n Every segment must be aligned at 8 byte boundary with null byte padding\n between adjacent segments if required.\n For segements which are not present both offset and length must be 0 in\n the header.\n Currently only xclbin0\\0 is recognized as file magic. In future if/when file\n format is updated the magic string will be changed to xclbin1\\0 and so on."]
pub type XCLBIN_MODE = ::std::os::raw::c_uint;
pub const axlf_section_kind_BITSTREAM: axlf_section_kind = 0;
pub const axlf_section_kind_CLEARING_BITSTREAM: axlf_section_kind = 1;
pub const axlf_section_kind_EMBEDDED_METADATA: axlf_section_kind = 2;
pub const axlf_section_kind_FIRMWARE: axlf_section_kind = 3;
pub const axlf_section_kind_DEBUG_DATA: axlf_section_kind = 4;
pub const axlf_section_kind_SCHED_FIRMWARE: axlf_section_kind = 5;
pub const axlf_section_kind_MEM_TOPOLOGY: axlf_section_kind = 6;
pub const axlf_section_kind_CONNECTIVITY: axlf_section_kind = 7;
pub const axlf_section_kind_IP_LAYOUT: axlf_section_kind = 8;
pub const axlf_section_kind_DEBUG_IP_LAYOUT: axlf_section_kind = 9;
pub const axlf_section_kind_DESIGN_CHECK_POINT: axlf_section_kind = 10;
pub const axlf_section_kind_CLOCK_FREQ_TOPOLOGY: axlf_section_kind = 11;
pub const axlf_section_kind_MCS: axlf_section_kind = 12;
pub const axlf_section_kind_BMC: axlf_section_kind = 13;
pub const axlf_section_kind_BUILD_METADATA: axlf_section_kind = 14;
pub const axlf_section_kind_KEYVALUE_METADATA: axlf_section_kind = 15;
pub const axlf_section_kind_USER_METADATA: axlf_section_kind = 16;
pub const axlf_section_kind_DNA_CERTIFICATE: axlf_section_kind = 17;
pub const axlf_section_kind_PDI: axlf_section_kind = 18;
pub const axlf_section_kind_BITSTREAM_PARTIAL_PDI: axlf_section_kind = 19;
pub const axlf_section_kind_PARTITION_METADATA: axlf_section_kind = 20;
pub const axlf_section_kind_EMULATION_DATA: axlf_section_kind = 21;
pub const axlf_section_kind_SYSTEM_METADATA: axlf_section_kind = 22;
pub const axlf_section_kind_SOFT_KERNEL: axlf_section_kind = 23;
pub const axlf_section_kind_ASK_FLASH: axlf_section_kind = 24;
pub const axlf_section_kind_AIE_METADATA: axlf_section_kind = 25;
pub const axlf_section_kind_ASK_GROUP_TOPOLOGY: axlf_section_kind = 26;
pub const axlf_section_kind_ASK_GROUP_CONNECTIVITY: axlf_section_kind = 27;
pub const axlf_section_kind_SMARTNIC: axlf_section_kind = 28;
pub const axlf_section_kind_AIE_RESOURCES: axlf_section_kind = 29;
pub const axlf_section_kind_OVERLAY: axlf_section_kind = 30;
pub const axlf_section_kind_VENDER_METADATA: axlf_section_kind = 31;
pub const axlf_section_kind_AIE_PARTITION: axlf_section_kind = 32;
pub const axlf_section_kind_IP_METADATA: axlf_section_kind = 33;
pub type axlf_section_kind = ::std::os::raw::c_uint;
pub const MEM_TYPE_MEM_DDR3: MEM_TYPE = 0;
pub const MEM_TYPE_MEM_DDR4: MEM_TYPE = 1;
pub const MEM_TYPE_MEM_DRAM: MEM_TYPE = 2;
pub const MEM_TYPE_MEM_STREAMING: MEM_TYPE = 3;
pub const MEM_TYPE_MEM_PREALLOCATED_GLOB: MEM_TYPE = 4;
pub const MEM_TYPE_MEM_ARE: MEM_TYPE = 5;
pub const MEM_TYPE_MEM_HBM: MEM_TYPE = 6;
pub const MEM_TYPE_MEM_BRAM: MEM_TYPE = 7;
pub const MEM_TYPE_MEM_URAM: MEM_TYPE = 8;
pub const MEM_TYPE_MEM_STREAMING_CONNECTION: MEM_TYPE = 9;
pub const MEM_TYPE_MEM_HOST: MEM_TYPE = 10;
pub const MEM_TYPE_MEM_PS_KERNEL: MEM_TYPE = 11;
pub type MEM_TYPE = ::std::os::raw::c_uint;
pub const IP_TYPE_IP_MB: IP_TYPE = 0;
pub const IP_TYPE_IP_KERNEL: IP_TYPE = 1;
pub const IP_TYPE_IP_DNASC: IP_TYPE = 2;
pub const IP_TYPE_IP_DDR4_CONTROLLER: IP_TYPE = 3;
pub const IP_TYPE_IP_MEM_DDR4: IP_TYPE = 4;
pub const IP_TYPE_IP_MEM_HBM: IP_TYPE = 5;
pub const IP_TYPE_IP_MEM_HBM_ECC: IP_TYPE = 6;
pub const IP_TYPE_IP_PS_KERNEL: IP_TYPE = 7;
pub type IP_TYPE = ::std::os::raw::c_uint;
pub const ACTION_MASK_AM_LOAD_AIE: ACTION_MASK = 1;
pub type ACTION_MASK = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct axlf_section_header {
    pub m_sectionKind: u32,
    pub m_sectionName: [::std::os::raw::c_char; 16usize],
    pub m_sectionOffset: u64,
    pub m_sectionSize: u64,
}
#[test]
fn bindgen_test_layout_axlf_section_header() {
    const UNINIT: ::std::mem::MaybeUninit<axlf_section_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<axlf_section_header>(),
        40usize,
        concat!("Size of: ", stringify!(axlf_section_header))
    );
    assert_eq!(
        ::std::mem::align_of::<axlf_section_header>(),
        8usize,
        concat!("Alignment of ", stringify!(axlf_section_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sectionKind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_section_header),
            "::",
            stringify!(m_sectionKind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sectionName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_section_header),
            "::",
            stringify!(m_sectionName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sectionOffset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_section_header),
            "::",
            stringify!(m_sectionOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sectionSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_section_header),
            "::",
            stringify!(m_sectionSize)
        )
    );
}
pub const assert_line_218: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct axlf_header {
    pub m_length: u64,
    pub m_timeStamp: u64,
    pub m_featureRomTimeStamp: u64,
    pub m_versionPatch: u16,
    pub m_versionMajor: u8,
    pub m_versionMinor: u8,
    pub m_mode: u16,
    pub m_actionMask: u16,
    pub m_interface_uuid: [::std::os::raw::c_uchar; 16usize],
    pub m_platformVBNV: [::std::os::raw::c_uchar; 64usize],
    pub __bindgen_anon_1: axlf_header__bindgen_ty_1,
    pub m_debug_bin: [::std::os::raw::c_char; 16usize],
    pub m_numSections: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union axlf_header__bindgen_ty_1 {
    pub m_next_axlf: [::std::os::raw::c_char; 16usize],
    pub uuid: xuid_t,
}
#[test]
fn bindgen_test_layout_axlf_header__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<axlf_header__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<axlf_header__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(axlf_header__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<axlf_header__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(axlf_header__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_next_axlf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header__bindgen_ty_1),
            "::",
            stringify!(m_next_axlf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header__bindgen_ty_1),
            "::",
            stringify!(uuid)
        )
    );
}
#[test]
fn bindgen_test_layout_axlf_header() {
    const UNINIT: ::std::mem::MaybeUninit<axlf_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<axlf_header>(),
        152usize,
        concat!("Size of: ", stringify!(axlf_header))
    );
    assert_eq!(
        ::std::mem::align_of::<axlf_header>(),
        8usize,
        concat!("Alignment of ", stringify!(axlf_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_timeStamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_featureRomTimeStamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_featureRomTimeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_versionPatch) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_versionPatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_versionMajor) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_versionMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_versionMinor) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_versionMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mode) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_actionMask) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_actionMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_interface_uuid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_interface_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_platformVBNV) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_platformVBNV)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_debug_bin) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_debug_bin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numSections) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf_header),
            "::",
            stringify!(m_numSections)
        )
    );
}
pub const assert_line_238: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct axlf {
    pub m_magic: [::std::os::raw::c_char; 8usize],
    pub m_signature_length: i32,
    pub reserved: [::std::os::raw::c_uchar; 28usize],
    pub m_keyBlock: [::std::os::raw::c_uchar; 256usize],
    pub m_uniqueId: u64,
    pub m_header: axlf_header,
    pub m_sections: [axlf_section_header; 1usize],
}
#[test]
fn bindgen_test_layout_axlf() {
    const UNINIT: ::std::mem::MaybeUninit<axlf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<axlf>(),
        496usize,
        concat!("Size of: ", stringify!(axlf))
    );
    assert_eq!(
        ::std::mem::align_of::<axlf>(),
        8usize,
        concat!("Alignment of ", stringify!(axlf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(m_magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_signature_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(m_signature_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_keyBlock) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(m_keyBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uniqueId) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(m_uniqueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sections) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(axlf),
            "::",
            stringify!(m_sections)
        )
    );
}
pub const assert_line_251: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub type xclBin = axlf;
#[doc = " BEGIN : Xilinx internal section"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xlnx_bitstream {
    pub m_freq: [u8; 8usize],
    pub bits: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_xlnx_bitstream() {
    const UNINIT: ::std::mem::MaybeUninit<xlnx_bitstream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xlnx_bitstream>(),
        9usize,
        concat!("Size of: ", stringify!(xlnx_bitstream))
    );
    assert_eq!(
        ::std::mem::align_of::<xlnx_bitstream>(),
        1usize,
        concat!("Alignment of ", stringify!(xlnx_bitstream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_freq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xlnx_bitstream),
            "::",
            stringify!(m_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xlnx_bitstream),
            "::",
            stringify!(bits)
        )
    );
}
pub const assert_line_262: _bindgen_ty_4 = 1;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[doc = "   MEMORY TOPOLOGY SECTION"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_data {
    pub m_type: u8,
    pub m_used: u8,
    pub padding: [u8; 6usize],
    pub __bindgen_anon_1: mem_data__bindgen_ty_1,
    pub __bindgen_anon_2: mem_data__bindgen_ty_2,
    pub m_tag: [::std::os::raw::c_uchar; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mem_data__bindgen_ty_1 {
    pub m_size: u64,
    pub route_id: u64,
}
#[test]
fn bindgen_test_layout_mem_data__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<mem_data__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mem_data__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(mem_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mem_data__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_data__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_data__bindgen_ty_1),
            "::",
            stringify!(m_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).route_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_data__bindgen_ty_1),
            "::",
            stringify!(route_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mem_data__bindgen_ty_2 {
    pub m_base_address: u64,
    pub flow_id: u64,
}
#[test]
fn bindgen_test_layout_mem_data__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<mem_data__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mem_data__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(mem_data__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<mem_data__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_data__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_base_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_data__bindgen_ty_2),
            "::",
            stringify!(m_base_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flow_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_data__bindgen_ty_2),
            "::",
            stringify!(flow_id)
        )
    );
}
#[test]
fn bindgen_test_layout_mem_data() {
    const UNINIT: ::std::mem::MaybeUninit<mem_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mem_data>(),
        40usize,
        concat!("Size of: ", stringify!(mem_data))
    );
    assert_eq!(
        ::std::mem::align_of::<mem_data>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_data),
            "::",
            stringify!(m_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_used) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_data),
            "::",
            stringify!(m_used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_data),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tag) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_data),
            "::",
            stringify!(m_tag)
        )
    );
}
pub const assert_line_280: _bindgen_ty_5 = 1;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_topology {
    pub m_count: i32,
    pub m_mem_data: [mem_data; 1usize],
}
#[test]
fn bindgen_test_layout_mem_topology() {
    const UNINIT: ::std::mem::MaybeUninit<mem_topology> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mem_topology>(),
        48usize,
        concat!("Size of: ", stringify!(mem_topology))
    );
    assert_eq!(
        ::std::mem::align_of::<mem_topology>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_topology))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_topology),
            "::",
            stringify!(m_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mem_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_topology),
            "::",
            stringify!(m_mem_data)
        )
    );
}
pub const assert_line_286: _bindgen_ty_6 = 1;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[doc = "   CONNECTIVITY SECTION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct connection {
    pub arg_index: i32,
    pub m_ip_layout_index: i32,
    pub mem_data_index: i32,
}
#[test]
fn bindgen_test_layout_connection() {
    const UNINIT: ::std::mem::MaybeUninit<connection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<connection>(),
        12usize,
        concat!("Size of: ", stringify!(connection))
    );
    assert_eq!(
        ::std::mem::align_of::<connection>(),
        4usize,
        concat!("Alignment of ", stringify!(connection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(connection),
            "::",
            stringify!(arg_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ip_layout_index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(connection),
            "::",
            stringify!(m_ip_layout_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_data_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(connection),
            "::",
            stringify!(mem_data_index)
        )
    );
}
pub const assert_line_303: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct connectivity {
    pub m_count: i32,
    pub m_connection: [connection; 1usize],
}
#[test]
fn bindgen_test_layout_connectivity() {
    const UNINIT: ::std::mem::MaybeUninit<connectivity> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<connectivity>(),
        16usize,
        concat!("Size of: ", stringify!(connectivity))
    );
    assert_eq!(
        ::std::mem::align_of::<connectivity>(),
        4usize,
        concat!("Alignment of ", stringify!(connectivity))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(connectivity),
            "::",
            stringify!(m_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_connection) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(connectivity),
            "::",
            stringify!(m_connection)
        )
    );
}
pub const assert_line_309: _bindgen_ty_8 = 1;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const IP_CONTROL_AP_CTRL_HS: IP_CONTROL = 0;
pub const IP_CONTROL_AP_CTRL_CHAIN: IP_CONTROL = 1;
pub const IP_CONTROL_AP_CTRL_NONE: IP_CONTROL = 2;
pub const IP_CONTROL_AP_CTRL_ME: IP_CONTROL = 3;
pub const IP_CONTROL_ACCEL_ADAPTER: IP_CONTROL = 4;
pub const IP_CONTROL_FAST_ADAPTER: IP_CONTROL = 5;
pub type IP_CONTROL = ::std::os::raw::c_uint;
pub const PS_SUBTYPE_ST_PS: PS_SUBTYPE = 0;
pub const PS_SUBTYPE_ST_DPU: PS_SUBTYPE = 1;
pub type PS_SUBTYPE = ::std::os::raw::c_uint;
pub const PS_FUNCTIONAL_FC_DPU: PS_FUNCTIONAL = 0;
pub const PS_FUNCTIONAL_FC_PREPOST: PS_FUNCTIONAL = 1;
pub type PS_FUNCTIONAL = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_data {
    pub m_type: u32,
    pub __bindgen_anon_1: ip_data__bindgen_ty_1,
    pub m_base_address: u64,
    pub m_name: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_data__bindgen_ty_1 {
    pub properties: u32,
    pub ps_kernel: ip_data__bindgen_ty_1__bindgen_ty_1,
    pub indices: ip_data__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_data__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ip_data__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ip_data__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ip_data__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_data__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(ip_data__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl ip_data__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn m_subtype(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_m_subtype(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn m_functional(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_m_functional(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn m_kernel_id(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_m_kernel_id(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_subtype: u16,
        m_functional: u16,
        m_kernel_id: u16,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let m_subtype: u16 = unsafe { ::std::mem::transmute(m_subtype) };
            m_subtype as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let m_functional: u16 = unsafe { ::std::mem::transmute(m_functional) };
            m_functional as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let m_kernel_id: u16 = unsafe { ::std::mem::transmute(m_kernel_id) };
            m_kernel_id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_data__bindgen_ty_1__bindgen_ty_2 {
    pub m_index: u16,
    pub m_pc_index: u8,
    pub unused: u8,
}
#[test]
fn bindgen_test_layout_ip_data__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<ip_data__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_data__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(ip_data__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_data__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(ip_data__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(m_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pc_index) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(m_pc_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(unused)
        )
    );
}
#[test]
fn bindgen_test_layout_ip_data__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ip_data__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_data__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ip_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_data__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_data__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_data__bindgen_ty_1),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ps_kernel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_data__bindgen_ty_1),
            "::",
            stringify!(ps_kernel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).indices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_data__bindgen_ty_1),
            "::",
            stringify!(indices)
        )
    );
}
#[test]
fn bindgen_test_layout_ip_data() {
    const UNINIT: ::std::mem::MaybeUninit<ip_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_data>(),
        80usize,
        concat!("Size of: ", stringify!(ip_data))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_data>(),
        8usize,
        concat!("Alignment of ", stringify!(ip_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_data),
            "::",
            stringify!(m_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_base_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_data),
            "::",
            stringify!(m_base_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_data),
            "::",
            stringify!(m_name)
        )
    );
}
pub const assert_line_373: _bindgen_ty_9 = 1;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_layout {
    pub m_count: i32,
    pub m_ip_data: [ip_data; 1usize],
}
#[test]
fn bindgen_test_layout_ip_layout() {
    const UNINIT: ::std::mem::MaybeUninit<ip_layout> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_layout>(),
        88usize,
        concat!("Size of: ", stringify!(ip_layout))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_layout>(),
        8usize,
        concat!("Alignment of ", stringify!(ip_layout))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_layout),
            "::",
            stringify!(m_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ip_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_layout),
            "::",
            stringify!(m_ip_data)
        )
    );
}
pub const assert_line_379: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const DEBUG_IP_TYPE_UNDEFINED: DEBUG_IP_TYPE = 0;
pub const DEBUG_IP_TYPE_LAPC: DEBUG_IP_TYPE = 1;
pub const DEBUG_IP_TYPE_ILA: DEBUG_IP_TYPE = 2;
pub const DEBUG_IP_TYPE_AXI_MM_MONITOR: DEBUG_IP_TYPE = 3;
pub const DEBUG_IP_TYPE_AXI_TRACE_FUNNEL: DEBUG_IP_TYPE = 4;
pub const DEBUG_IP_TYPE_AXI_MONITOR_FIFO_LITE: DEBUG_IP_TYPE = 5;
pub const DEBUG_IP_TYPE_AXI_MONITOR_FIFO_FULL: DEBUG_IP_TYPE = 6;
pub const DEBUG_IP_TYPE_ACCEL_MONITOR: DEBUG_IP_TYPE = 7;
pub const DEBUG_IP_TYPE_AXI_STREAM_MONITOR: DEBUG_IP_TYPE = 8;
pub const DEBUG_IP_TYPE_AXI_STREAM_PROTOCOL_CHECKER: DEBUG_IP_TYPE = 9;
pub const DEBUG_IP_TYPE_TRACE_S2MM: DEBUG_IP_TYPE = 10;
pub const DEBUG_IP_TYPE_AXI_DMA: DEBUG_IP_TYPE = 11;
pub const DEBUG_IP_TYPE_TRACE_S2MM_FULL: DEBUG_IP_TYPE = 12;
pub const DEBUG_IP_TYPE_AXI_NOC: DEBUG_IP_TYPE = 13;
pub const DEBUG_IP_TYPE_ACCEL_DEADLOCK_DETECTOR: DEBUG_IP_TYPE = 14;
pub const DEBUG_IP_TYPE_HSDP_TRACE: DEBUG_IP_TYPE = 15;
pub const DEBUG_IP_TYPE_DEBUG_IP_TYPE_MAX: DEBUG_IP_TYPE = 16;
#[doc = " Debug IP section layout"]
pub type DEBUG_IP_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct debug_ip_data {
    pub m_type: u8,
    pub m_index_lowbyte: u8,
    pub m_properties: u8,
    pub m_major: u8,
    pub m_minor: u8,
    pub m_index_highbyte: u8,
    pub m_reserved: [u8; 2usize],
    pub m_base_address: u64,
    pub m_name: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_debug_ip_data() {
    const UNINIT: ::std::mem::MaybeUninit<debug_ip_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<debug_ip_data>(),
        144usize,
        concat!("Size of: ", stringify!(debug_ip_data))
    );
    assert_eq!(
        ::std::mem::align_of::<debug_ip_data>(),
        8usize,
        concat!("Alignment of ", stringify!(debug_ip_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_ip_data),
            "::",
            stringify!(m_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_index_lowbyte) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_ip_data),
            "::",
            stringify!(m_index_lowbyte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_properties) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_ip_data),
            "::",
            stringify!(m_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_major) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_ip_data),
            "::",
            stringify!(m_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_ip_data),
            "::",
            stringify!(m_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_index_highbyte) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_ip_data),
            "::",
            stringify!(m_index_highbyte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_ip_data),
            "::",
            stringify!(m_reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_base_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_ip_data),
            "::",
            stringify!(m_base_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_ip_data),
            "::",
            stringify!(m_name)
        )
    );
}
pub const assert_line_413: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct debug_ip_layout {
    pub m_count: u16,
    pub m_debug_ip_data: [debug_ip_data; 1usize],
}
#[test]
fn bindgen_test_layout_debug_ip_layout() {
    const UNINIT: ::std::mem::MaybeUninit<debug_ip_layout> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<debug_ip_layout>(),
        152usize,
        concat!("Size of: ", stringify!(debug_ip_layout))
    );
    assert_eq!(
        ::std::mem::align_of::<debug_ip_layout>(),
        8usize,
        concat!("Alignment of ", stringify!(debug_ip_layout))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_ip_layout),
            "::",
            stringify!(m_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_debug_ip_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_ip_layout),
            "::",
            stringify!(m_debug_ip_data)
        )
    );
}
pub const assert_line_419: _bindgen_ty_12 = 1;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const CLOCK_TYPE_CT_UNUSED: CLOCK_TYPE = 0;
pub const CLOCK_TYPE_CT_DATA: CLOCK_TYPE = 1;
pub const CLOCK_TYPE_CT_KERNEL: CLOCK_TYPE = 2;
pub const CLOCK_TYPE_CT_SYSTEM: CLOCK_TYPE = 3;
pub type CLOCK_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clock_freq {
    pub m_freq_Mhz: u16,
    pub m_type: u8,
    pub m_unused: [u8; 5usize],
    pub m_name: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_clock_freq() {
    const UNINIT: ::std::mem::MaybeUninit<clock_freq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clock_freq>(),
        136usize,
        concat!("Size of: ", stringify!(clock_freq))
    );
    assert_eq!(
        ::std::mem::align_of::<clock_freq>(),
        2usize,
        concat!("Alignment of ", stringify!(clock_freq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_freq_Mhz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clock_freq),
            "::",
            stringify!(m_freq_Mhz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_type) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(clock_freq),
            "::",
            stringify!(m_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unused) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(clock_freq),
            "::",
            stringify!(m_unused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clock_freq),
            "::",
            stringify!(m_name)
        )
    );
}
pub const assert_line_434: _bindgen_ty_13 = 1;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clock_freq_topology {
    pub m_count: i16,
    pub m_clock_freq: [clock_freq; 1usize],
}
#[test]
fn bindgen_test_layout_clock_freq_topology() {
    const UNINIT: ::std::mem::MaybeUninit<clock_freq_topology> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clock_freq_topology>(),
        138usize,
        concat!("Size of: ", stringify!(clock_freq_topology))
    );
    assert_eq!(
        ::std::mem::align_of::<clock_freq_topology>(),
        2usize,
        concat!("Alignment of ", stringify!(clock_freq_topology))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clock_freq_topology),
            "::",
            stringify!(m_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_clock_freq) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(clock_freq_topology),
            "::",
            stringify!(m_clock_freq)
        )
    );
}
pub const assert_line_440: _bindgen_ty_14 = 1;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const MCS_TYPE_MCS_UNKNOWN: MCS_TYPE = 0;
pub const MCS_TYPE_MCS_PRIMARY: MCS_TYPE = 1;
pub const MCS_TYPE_MCS_SECONDARY: MCS_TYPE = 2;
pub type MCS_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcs_chunk {
    pub m_type: u8,
    pub m_unused: [u8; 7usize],
    pub m_offset: u64,
    pub m_size: u64,
}
#[test]
fn bindgen_test_layout_mcs_chunk() {
    const UNINIT: ::std::mem::MaybeUninit<mcs_chunk> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcs_chunk>(),
        24usize,
        concat!("Size of: ", stringify!(mcs_chunk))
    );
    assert_eq!(
        ::std::mem::align_of::<mcs_chunk>(),
        8usize,
        concat!("Alignment of ", stringify!(mcs_chunk))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcs_chunk),
            "::",
            stringify!(m_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unused) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mcs_chunk),
            "::",
            stringify!(m_unused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mcs_chunk),
            "::",
            stringify!(m_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mcs_chunk),
            "::",
            stringify!(m_size)
        )
    );
}
pub const assert_line_454: _bindgen_ty_15 = 1;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcs {
    pub m_count: i8,
    pub m_unused: [i8; 7usize],
    pub m_chunk: [mcs_chunk; 1usize],
}
#[test]
fn bindgen_test_layout_mcs() {
    const UNINIT: ::std::mem::MaybeUninit<mcs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcs>(),
        32usize,
        concat!("Size of: ", stringify!(mcs))
    );
    assert_eq!(
        ::std::mem::align_of::<mcs>(),
        8usize,
        concat!("Alignment of ", stringify!(mcs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcs),
            "::",
            stringify!(m_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unused) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mcs),
            "::",
            stringify!(m_unused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_chunk) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mcs),
            "::",
            stringify!(m_chunk)
        )
    );
}
pub const assert_line_461: _bindgen_ty_16 = 1;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bmc {
    pub m_offset: u64,
    pub m_size: u64,
    pub m_image_name: [::std::os::raw::c_char; 64usize],
    pub m_device_name: [::std::os::raw::c_char; 64usize],
    pub m_version: [::std::os::raw::c_char; 64usize],
    pub m_md5value: [::std::os::raw::c_char; 33usize],
    pub m_padding: [::std::os::raw::c_char; 7usize],
}
#[test]
fn bindgen_test_layout_bmc() {
    const UNINIT: ::std::mem::MaybeUninit<bmc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bmc>(),
        248usize,
        concat!("Size of: ", stringify!(bmc))
    );
    assert_eq!(
        ::std::mem::align_of::<bmc>(),
        8usize,
        concat!("Alignment of ", stringify!(bmc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bmc),
            "::",
            stringify!(m_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bmc),
            "::",
            stringify!(m_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_image_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bmc),
            "::",
            stringify!(m_image_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_device_name) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bmc),
            "::",
            stringify!(m_device_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_version) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(bmc),
            "::",
            stringify!(m_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_md5value) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(bmc),
            "::",
            stringify!(m_md5value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_padding) as usize - ptr as usize },
        241usize,
        concat!(
            "Offset of field: ",
            stringify!(bmc),
            "::",
            stringify!(m_padding)
        )
    );
}
pub const assert_line_472: _bindgen_ty_17 = 1;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct soft_kernel {
    pub mpo_name: u32,
    pub m_image_offset: u32,
    pub m_image_size: u32,
    pub mpo_version: u32,
    pub mpo_md5_value: u32,
    pub mpo_symbol_name: u32,
    pub m_num_instances: u32,
    pub padding: [u8; 36usize],
    pub reservedExt: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_soft_kernel() {
    const UNINIT: ::std::mem::MaybeUninit<soft_kernel> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<soft_kernel>(),
        80usize,
        concat!("Size of: ", stringify!(soft_kernel))
    );
    assert_eq!(
        ::std::mem::align_of::<soft_kernel>(),
        4usize,
        concat!("Alignment of ", stringify!(soft_kernel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpo_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(soft_kernel),
            "::",
            stringify!(mpo_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_image_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(soft_kernel),
            "::",
            stringify!(m_image_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_image_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(soft_kernel),
            "::",
            stringify!(m_image_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpo_version) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(soft_kernel),
            "::",
            stringify!(mpo_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpo_md5_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(soft_kernel),
            "::",
            stringify!(mpo_md5_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpo_symbol_name) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(soft_kernel),
            "::",
            stringify!(mpo_symbol_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_num_instances) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(soft_kernel),
            "::",
            stringify!(m_num_instances)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(soft_kernel),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedExt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(soft_kernel),
            "::",
            stringify!(reservedExt)
        )
    );
}
pub const assert_line_492: _bindgen_ty_18 = 1;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const FLASH_TYPE_FLT_UNKNOWN: FLASH_TYPE = 0;
pub const FLASH_TYPE_FLT_BIN_PRIMARY: FLASH_TYPE = 1;
pub type FLASH_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flash {
    pub m_flash_type: u16,
    pub padding: [u8; 2usize],
    pub m_image_offset: u32,
    pub m_image_size: u32,
    pub mpo_name: u32,
    pub mpo_version: u32,
    pub mpo_md5_value: u32,
    pub reserved: [u8; 32usize],
    pub reservedExt: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_flash() {
    const UNINIT: ::std::mem::MaybeUninit<flash> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<flash>(),
        72usize,
        concat!("Size of: ", stringify!(flash))
    );
    assert_eq!(
        ::std::mem::align_of::<flash>(),
        4usize,
        concat!("Alignment of ", stringify!(flash))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flash_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flash),
            "::",
            stringify!(m_flash_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flash),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_image_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(flash),
            "::",
            stringify!(m_image_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_image_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flash),
            "::",
            stringify!(m_image_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpo_name) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(flash),
            "::",
            stringify!(mpo_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpo_version) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flash),
            "::",
            stringify!(mpo_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpo_md5_value) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(flash),
            "::",
            stringify!(mpo_md5_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flash),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedExt) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(flash),
            "::",
            stringify!(reservedExt)
        )
    );
}
pub const assert_line_518: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const CHECKSUM_TYPE_CST_UNKNOWN: CHECKSUM_TYPE = 0;
pub const CHECKSUM_TYPE_CST_SDBM: CHECKSUM_TYPE = 1;
pub const CHECKSUM_TYPE_CST_LAST: CHECKSUM_TYPE = 2;
pub type CHECKSUM_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vender_metadata {
    pub mpo_name: u32,
    pub m_image_offset: u32,
    pub m_image_size: u32,
    pub padding: [u8; 36usize],
}
#[test]
fn bindgen_test_layout_vender_metadata() {
    const UNINIT: ::std::mem::MaybeUninit<vender_metadata> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vender_metadata>(),
        48usize,
        concat!("Size of: ", stringify!(vender_metadata))
    );
    assert_eq!(
        ::std::mem::align_of::<vender_metadata>(),
        4usize,
        concat!("Alignment of ", stringify!(vender_metadata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpo_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vender_metadata),
            "::",
            stringify!(mpo_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_image_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vender_metadata),
            "::",
            stringify!(m_image_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_image_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vender_metadata),
            "::",
            stringify!(m_image_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vender_metadata),
            "::",
            stringify!(padding)
        )
    );
}
pub const assert_line_540: _bindgen_ty_20 = 1;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct array_offset {
    pub size: u32,
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_array_offset() {
    const UNINIT: ::std::mem::MaybeUninit<array_offset> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<array_offset>(),
        8usize,
        concat!("Size of: ", stringify!(array_offset))
    );
    assert_eq!(
        ::std::mem::align_of::<array_offset>(),
        4usize,
        concat!("Alignment of ", stringify!(array_offset))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(array_offset),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(array_offset),
            "::",
            stringify!(offset)
        )
    );
}
pub const assert_line_548: _bindgen_ty_21 = 1;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const CDO_Type_CT_UNKNOWN: CDO_Type = 0;
pub const CDO_Type_CT_PRIMARY: CDO_Type = 1;
pub const CDO_Type_CT_LITE: CDO_Type = 2;
pub const CDO_Type_CT_PREPOST: CDO_Type = 3;
pub type CDO_Type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdo_group {
    pub mpo_name: u32,
    pub cdo_type: u8,
    pub padding: [u8; 3usize],
    pub pdi_id: u64,
    pub dpu_kernel_ids: array_offset,
    pub pre_cdo_groups: array_offset,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_cdo_group() {
    const UNINIT: ::std::mem::MaybeUninit<cdo_group> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cdo_group>(),
        96usize,
        concat!("Size of: ", stringify!(cdo_group))
    );
    assert_eq!(
        ::std::mem::align_of::<cdo_group>(),
        8usize,
        concat!("Alignment of ", stringify!(cdo_group))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpo_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdo_group),
            "::",
            stringify!(mpo_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cdo_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cdo_group),
            "::",
            stringify!(cdo_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(cdo_group),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdi_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cdo_group),
            "::",
            stringify!(pdi_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dpu_kernel_ids) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cdo_group),
            "::",
            stringify!(dpu_kernel_ids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_cdo_groups) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cdo_group),
            "::",
            stringify!(pre_cdo_groups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cdo_group),
            "::",
            stringify!(reserved)
        )
    );
}
pub const assert_line_566: _bindgen_ty_22 = 1;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub const assert_line_567: _bindgen_ty_23 = 1;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aie_pdi {
    pub uuid: xuid_t,
    pub pdi_image: array_offset,
    pub cdo_groups: array_offset,
    pub reserved: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_aie_pdi() {
    const UNINIT: ::std::mem::MaybeUninit<aie_pdi> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aie_pdi>(),
        96usize,
        concat!("Size of: ", stringify!(aie_pdi))
    );
    assert_eq!(
        ::std::mem::align_of::<aie_pdi>(),
        4usize,
        concat!("Alignment of ", stringify!(aie_pdi))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_pdi),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdi_image) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_pdi),
            "::",
            stringify!(pdi_image)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cdo_groups) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_pdi),
            "::",
            stringify!(cdo_groups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_pdi),
            "::",
            stringify!(reserved)
        )
    );
}
pub const assert_line_578: _bindgen_ty_24 = 1;
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub const assert_line_579: _bindgen_ty_25 = 1;
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aie_partition_info {
    pub column_width: u16,
    pub padding: [u8; 6usize],
    pub start_columns: array_offset,
    pub reserved: [u8; 72usize],
}
#[test]
fn bindgen_test_layout_aie_partition_info() {
    const UNINIT: ::std::mem::MaybeUninit<aie_partition_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aie_partition_info>(),
        88usize,
        concat!("Size of: ", stringify!(aie_partition_info))
    );
    assert_eq!(
        ::std::mem::align_of::<aie_partition_info>(),
        4usize,
        concat!("Alignment of ", stringify!(aie_partition_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column_width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition_info),
            "::",
            stringify!(column_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition_info),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_columns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition_info),
            "::",
            stringify!(start_columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition_info),
            "::",
            stringify!(reserved)
        )
    );
}
pub const assert_line_587: _bindgen_ty_26 = 1;
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aie_partition {
    pub schema_version: u8,
    pub padding0: [u8; 3usize],
    pub mpo_name: u32,
    pub operations_per_cycle: u32,
    pub padding: [u8; 4usize],
    pub inference_fingerprint: u64,
    pub pre_post_fingerprint: u64,
    pub info: aie_partition_info,
    pub aie_pdi: array_offset,
    pub reserved: [u8; 54usize],
}
#[test]
fn bindgen_test_layout_aie_partition() {
    const UNINIT: ::std::mem::MaybeUninit<aie_partition> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aie_partition>(),
        184usize,
        concat!("Size of: ", stringify!(aie_partition))
    );
    assert_eq!(
        ::std::mem::align_of::<aie_partition>(),
        8usize,
        concat!("Alignment of ", stringify!(aie_partition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).schema_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition),
            "::",
            stringify!(schema_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition),
            "::",
            stringify!(padding0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpo_name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition),
            "::",
            stringify!(mpo_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operations_per_cycle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition),
            "::",
            stringify!(operations_per_cycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inference_fingerprint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition),
            "::",
            stringify!(inference_fingerprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_post_fingerprint) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition),
            "::",
            stringify!(pre_post_fingerprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aie_pdi) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition),
            "::",
            stringify!(aie_pdi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aie_partition),
            "::",
            stringify!(reserved)
        )
    );
}
pub const assert_line_601: _bindgen_ty_27 = 1;
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
pub const assert_line_602: _bindgen_ty_28 = 1;
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
pub const xclFirewallID_XCL_FW_MGMT_CONTROL: xclFirewallID = 0;
pub const xclFirewallID_XCL_FW_USER_CONTROL: xclFirewallID = 1;
pub const xclFirewallID_XCL_FW_DATAPATH: xclFirewallID = 2;
pub const xclFirewallID_XCL_FW_MAX_LEVEL: xclFirewallID = 3;
#[doc = " enum xclFirewallID - AXI Firewall IDs used to identify individual AXI Firewalls\n\n @XCL_FW_MGMT_CONTROL:  MGMT BAR AXI-Lite BAR access protection\n @XCL_FW_USER_CONTROL:  USER BAR AXI-Lite BAR access protection\n @XCL_FW_DATAPATH:      DMA data path protection"]
pub type xclFirewallID = ::std::os::raw::c_uint;
#[doc = " struct xclAXIErrorStatus - Record used to capture specific error\n\n @mErrFirewallTime:    Timestamp of when Firewall tripped\n @mErrFirewallStatus:  Error code obtained from the Firewall\n @mErrFirewallID:      Firewall ID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclAXIErrorStatus {
    pub mErrFirewallTime: ::std::os::raw::c_ulong,
    pub mErrFirewallStatus: ::std::os::raw::c_uint,
    pub mErrFirewallID: xclFirewallID,
}
#[test]
fn bindgen_test_layout_xclAXIErrorStatus() {
    const UNINIT: ::std::mem::MaybeUninit<xclAXIErrorStatus> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclAXIErrorStatus>(),
        16usize,
        concat!("Size of: ", stringify!(xclAXIErrorStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<xclAXIErrorStatus>(),
        8usize,
        concat!("Alignment of ", stringify!(xclAXIErrorStatus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mErrFirewallTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAXIErrorStatus),
            "::",
            stringify!(mErrFirewallTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mErrFirewallStatus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAXIErrorStatus),
            "::",
            stringify!(mErrFirewallStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mErrFirewallID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAXIErrorStatus),
            "::",
            stringify!(mErrFirewallID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclPCIErrorStatus {
    pub mDeviceStatus: ::std::os::raw::c_uint,
    pub mUncorrErrStatus: ::std::os::raw::c_uint,
    pub mCorrErrStatus: ::std::os::raw::c_uint,
    pub rsvd1: ::std::os::raw::c_uint,
    pub rsvd2: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xclPCIErrorStatus() {
    const UNINIT: ::std::mem::MaybeUninit<xclPCIErrorStatus> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclPCIErrorStatus>(),
        20usize,
        concat!("Size of: ", stringify!(xclPCIErrorStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<xclPCIErrorStatus>(),
        4usize,
        concat!("Alignment of ", stringify!(xclPCIErrorStatus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mDeviceStatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclPCIErrorStatus),
            "::",
            stringify!(mDeviceStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mUncorrErrStatus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xclPCIErrorStatus),
            "::",
            stringify!(mUncorrErrStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mCorrErrStatus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xclPCIErrorStatus),
            "::",
            stringify!(mCorrErrStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xclPCIErrorStatus),
            "::",
            stringify!(rsvd1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xclPCIErrorStatus),
            "::",
            stringify!(rsvd2)
        )
    );
}
#[doc = " struct xclErrorStatus - Container for all error records\n\n @mNumFirewalls:    Count of Firewalls in the record (max is 8)\n @mAXIErrorStatus:  Records holding Firewall information\n @mPCIErrorStatus:  Unused"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclErrorStatus {
    pub mNumFirewalls: ::std::os::raw::c_uint,
    pub mAXIErrorStatus: [xclAXIErrorStatus; 8usize],
    pub mPCIErrorStatus: xclPCIErrorStatus,
    pub mFirewallLevel: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xclErrorStatus() {
    const UNINIT: ::std::mem::MaybeUninit<xclErrorStatus> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclErrorStatus>(),
        160usize,
        concat!("Size of: ", stringify!(xclErrorStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<xclErrorStatus>(),
        8usize,
        concat!("Alignment of ", stringify!(xclErrorStatus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mNumFirewalls) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclErrorStatus),
            "::",
            stringify!(mNumFirewalls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mAXIErrorStatus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xclErrorStatus),
            "::",
            stringify!(mAXIErrorStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mPCIErrorStatus) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(xclErrorStatus),
            "::",
            stringify!(mPCIErrorStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mFirewallLevel) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(xclErrorStatus),
            "::",
            stringify!(mFirewallLevel)
        )
    );
}
#[doc = " Encoding of flags passed to xcl buffer allocation APIs"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xcl_bo_flags {
    pub __bindgen_anon_1: xcl_bo_flags__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xcl_bo_flags__bindgen_ty_1 {
    pub flags: u32,
    pub __bindgen_anon_1: xcl_bo_flags__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcl_bo_flags__bindgen_ty_1__bindgen_ty_1 {
    pub bank: u16,
    pub slot: u8,
    pub boflags: u8,
}
#[test]
fn bindgen_test_layout_xcl_bo_flags__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<xcl_bo_flags__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcl_bo_flags__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(xcl_bo_flags__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcl_bo_flags__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcl_bo_flags__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bank) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcl_bo_flags__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcl_bo_flags__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boflags) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(xcl_bo_flags__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(boflags)
        )
    );
}
#[test]
fn bindgen_test_layout_xcl_bo_flags__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<xcl_bo_flags__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcl_bo_flags__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(xcl_bo_flags__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<xcl_bo_flags__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(xcl_bo_flags__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcl_bo_flags__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
}
#[test]
fn bindgen_test_layout_xcl_bo_flags() {
    assert_eq!(
        ::std::mem::size_of::<xcl_bo_flags>(),
        4usize,
        concat!("Size of: ", stringify!(xcl_bo_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<xcl_bo_flags>(),
        4usize,
        concat!("Alignment of ", stringify!(xcl_bo_flags))
    );
}
pub const xclDDRFlags_XCL_DEVICE_RAM_BANK0: xclDDRFlags = 0;
pub const xclDDRFlags_XCL_DEVICE_RAM_BANK1: xclDDRFlags = 2;
pub const xclDDRFlags_XCL_DEVICE_RAM_BANK2: xclDDRFlags = 4;
pub const xclDDRFlags_XCL_DEVICE_RAM_BANK3: xclDDRFlags = 8;
#[doc = " This is the legacy usage of XCL DDR Flags.\n\n byte-0 lower 4 bits for DDR Flags are one-hot encoded"]
pub type xclDDRFlags = ::std::os::raw::c_uint;
pub const xclPerfMonType_XCL_PERF_MON_MEMORY: xclPerfMonType = 0;
pub const xclPerfMonType_XCL_PERF_MON_HOST: xclPerfMonType = 1;
pub const xclPerfMonType_XCL_PERF_MON_SHELL: xclPerfMonType = 2;
pub const xclPerfMonType_XCL_PERF_MON_ACCEL: xclPerfMonType = 3;
pub const xclPerfMonType_XCL_PERF_MON_STALL: xclPerfMonType = 4;
pub const xclPerfMonType_XCL_PERF_MON_STR: xclPerfMonType = 5;
pub const xclPerfMonType_XCL_PERF_MON_FIFO: xclPerfMonType = 6;
pub const xclPerfMonType_XCL_PERF_MON_NOC: xclPerfMonType = 7;
pub const xclPerfMonType_XCL_PERF_MON_TOTAL_PROFILE: xclPerfMonType = 8;
#[doc = " Definitions: Enums, Structs"]
pub type xclPerfMonType = ::std::os::raw::c_uint;
pub const xclPerfMonStartEvent_XCL_PERF_MON_START_ADDR: xclPerfMonStartEvent = 0;
pub const xclPerfMonStartEvent_XCL_PERF_MON_START_FIRST_DATA: xclPerfMonStartEvent = 1;
pub type xclPerfMonStartEvent = ::std::os::raw::c_uint;
pub const xclPerfMonEndEvent_XCL_PERF_MON_END_LAST_DATA: xclPerfMonEndEvent = 0;
pub const xclPerfMonEndEvent_XCL_PERF_MON_END_RESPONSE: xclPerfMonEndEvent = 1;
pub type xclPerfMonEndEvent = ::std::os::raw::c_uint;
pub const xclPerfMonCounterType_XCL_PERF_MON_WRITE_BYTES: xclPerfMonCounterType = 0;
pub const xclPerfMonCounterType_XCL_PERF_MON_WRITE_TRANX: xclPerfMonCounterType = 1;
pub const xclPerfMonCounterType_XCL_PERF_MON_WRITE_LATENCY: xclPerfMonCounterType = 2;
pub const xclPerfMonCounterType_XCL_PERF_MON_READ_BYTES: xclPerfMonCounterType = 3;
pub const xclPerfMonCounterType_XCL_PERF_MON_READ_TRANX: xclPerfMonCounterType = 4;
pub const xclPerfMonCounterType_XCL_PERF_MON_READ_LATENCY: xclPerfMonCounterType = 5;
pub type xclPerfMonCounterType = ::std::os::raw::c_uint;
pub const xclPerfMonEventType_XCL_PERF_MON_START_EVENT: xclPerfMonEventType = 4;
pub const xclPerfMonEventType_XCL_PERF_MON_END_EVENT: xclPerfMonEventType = 5;
pub type xclPerfMonEventType = ::std::os::raw::c_uint;
pub const xclPerfMonEventID_XCL_PERF_MON_HW_EVENT: xclPerfMonEventID = 0;
pub const xclPerfMonEventID_XCL_PERF_MON_GENERAL_ID: xclPerfMonEventID = 3000;
pub const xclPerfMonEventID_XCL_PERF_MON_QUEUE_ID: xclPerfMonEventID = 3001;
pub const xclPerfMonEventID_XCL_PERF_MON_READ_ID: xclPerfMonEventID = 3002;
pub const xclPerfMonEventID_XCL_PERF_MON_WRITE_ID: xclPerfMonEventID = 3003;
pub const xclPerfMonEventID_XCL_PERF_MON_API_GET_PLATFORM_ID: xclPerfMonEventID = 3005;
pub const xclPerfMonEventID_XCL_PERF_MON_API_GET_PLATFORM_INFO_ID: xclPerfMonEventID = 3006;
pub const xclPerfMonEventID_XCL_PERF_MON_API_GET_DEVICE_ID: xclPerfMonEventID = 3007;
pub const xclPerfMonEventID_XCL_PERF_MON_API_GET_DEVICE_INFO_ID: xclPerfMonEventID = 3008;
pub const xclPerfMonEventID_XCL_PERF_MON_API_BUILD_PROGRAM_ID: xclPerfMonEventID = 3009;
pub const xclPerfMonEventID_XCL_PERF_MON_API_CREATE_CONTEXT_ID: xclPerfMonEventID = 3010;
pub const xclPerfMonEventID_XCL_PERF_MON_API_CREATE_CONTEXT_TYPE_ID: xclPerfMonEventID = 3011;
pub const xclPerfMonEventID_XCL_PERF_MON_API_CREATE_COMMAND_QUEUE_ID: xclPerfMonEventID = 3012;
pub const xclPerfMonEventID_XCL_PERF_MON_API_CREATE_PROGRAM_BINARY_ID: xclPerfMonEventID = 3013;
pub const xclPerfMonEventID_XCL_PERF_MON_API_CREATE_BUFFER_ID: xclPerfMonEventID = 3014;
pub const xclPerfMonEventID_XCL_PERF_MON_API_CREATE_IMAGE_ID: xclPerfMonEventID = 3015;
pub const xclPerfMonEventID_XCL_PERF_MON_API_CREATE_KERNEL_ID: xclPerfMonEventID = 3016;
pub const xclPerfMonEventID_XCL_PERF_MON_API_KERNEL_ARG_ID: xclPerfMonEventID = 3017;
pub const xclPerfMonEventID_XCL_PERF_MON_API_WAIT_FOR_EVENTS_ID: xclPerfMonEventID = 3018;
pub const xclPerfMonEventID_XCL_PERF_MON_API_READ_BUFFER_ID: xclPerfMonEventID = 3019;
pub const xclPerfMonEventID_XCL_PERF_MON_API_WRITE_BUFFER_ID: xclPerfMonEventID = 3020;
pub const xclPerfMonEventID_XCL_PERF_MON_API_READ_IMAGE_ID: xclPerfMonEventID = 3021;
pub const xclPerfMonEventID_XCL_PERF_MON_API_WRITE_IMAGE_ID: xclPerfMonEventID = 3022;
pub const xclPerfMonEventID_XCL_PERF_MON_API_MIGRATE_MEM_ID: xclPerfMonEventID = 3023;
pub const xclPerfMonEventID_XCL_PERF_MON_API_MIGRATE_MEM_OBJECTS_ID: xclPerfMonEventID = 3024;
pub const xclPerfMonEventID_XCL_PERF_MON_API_MAP_BUFFER_ID: xclPerfMonEventID = 3025;
pub const xclPerfMonEventID_XCL_PERF_MON_API_UNMAP_MEM_OBJECT_ID: xclPerfMonEventID = 3026;
pub const xclPerfMonEventID_XCL_PERF_MON_API_NDRANGE_KERNEL_ID: xclPerfMonEventID = 3027;
pub const xclPerfMonEventID_XCL_PERF_MON_API_TASK_ID: xclPerfMonEventID = 3028;
pub const xclPerfMonEventID_XCL_PERF_MON_KERNEL0_ID: xclPerfMonEventID = 3100;
pub const xclPerfMonEventID_XCL_PERF_MON_KERNEL1_ID: xclPerfMonEventID = 3101;
pub const xclPerfMonEventID_XCL_PERF_MON_KERNEL2_ID: xclPerfMonEventID = 3102;
pub const xclPerfMonEventID_XCL_PERF_MON_KERNEL3_ID: xclPerfMonEventID = 3103;
pub const xclPerfMonEventID_XCL_PERF_MON_KERNEL4_ID: xclPerfMonEventID = 3104;
pub const xclPerfMonEventID_XCL_PERF_MON_KERNEL5_ID: xclPerfMonEventID = 3105;
pub const xclPerfMonEventID_XCL_PERF_MON_KERNEL6_ID: xclPerfMonEventID = 3106;
pub const xclPerfMonEventID_XCL_PERF_MON_KERNEL7_ID: xclPerfMonEventID = 3107;
pub const xclPerfMonEventID_XCL_PERF_MON_CU0_ID: xclPerfMonEventID = 3200;
pub const xclPerfMonEventID_XCL_PERF_MON_CU1_ID: xclPerfMonEventID = 3201;
pub const xclPerfMonEventID_XCL_PERF_MON_CU2_ID: xclPerfMonEventID = 3202;
pub const xclPerfMonEventID_XCL_PERF_MON_CU3_ID: xclPerfMonEventID = 3203;
pub const xclPerfMonEventID_XCL_PERF_MON_CU4_ID: xclPerfMonEventID = 3204;
pub const xclPerfMonEventID_XCL_PERF_MON_CU5_ID: xclPerfMonEventID = 3205;
pub const xclPerfMonEventID_XCL_PERF_MON_CU6_ID: xclPerfMonEventID = 3206;
pub const xclPerfMonEventID_XCL_PERF_MON_CU7_ID: xclPerfMonEventID = 3207;
pub const xclPerfMonEventID_XCL_PERF_MON_PROGRAM_END: xclPerfMonEventID = 4090;
pub const xclPerfMonEventID_XCL_PERF_MON_IGNORE_EVENT: xclPerfMonEventID = 4095;
pub type xclPerfMonEventID = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclCounterResults {
    pub SampleIntervalUsec: f32,
    pub WriteBytes: [::std::os::raw::c_ulonglong; 34usize],
    pub WriteTranx: [::std::os::raw::c_ulonglong; 34usize],
    pub WriteLatency: [::std::os::raw::c_ulonglong; 34usize],
    pub WriteMinLatency: [::std::os::raw::c_ushort; 34usize],
    pub WriteMaxLatency: [::std::os::raw::c_ushort; 34usize],
    pub ReadBytes: [::std::os::raw::c_ulonglong; 34usize],
    pub ReadTranx: [::std::os::raw::c_ulonglong; 34usize],
    pub ReadLatency: [::std::os::raw::c_ulonglong; 34usize],
    pub ReadMinLatency: [::std::os::raw::c_ushort; 34usize],
    pub ReadMaxLatency: [::std::os::raw::c_ushort; 34usize],
    pub ReadBusyCycles: [::std::os::raw::c_ulonglong; 34usize],
    pub WriteBusyCycles: [::std::os::raw::c_ulonglong; 34usize],
    pub CuExecCount: [::std::os::raw::c_ulonglong; 31usize],
    pub CuExecCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub CuBusyCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub CuMaxParallelIter: [::std::os::raw::c_ulonglong; 31usize],
    pub CuStallExtCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub CuStallIntCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub CuStallStrCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub CuMinExecCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub CuMaxExecCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub StrNumTranx: [::std::os::raw::c_ulonglong; 31usize],
    pub StrDataBytes: [::std::os::raw::c_ulonglong; 31usize],
    pub StrBusyCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub StrStallCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub StrStarveCycles: [::std::os::raw::c_ulonglong; 31usize],
}
#[test]
fn bindgen_test_layout_xclCounterResults() {
    const UNINIT: ::std::mem::MaybeUninit<xclCounterResults> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclCounterResults>(),
        5928usize,
        concat!("Size of: ", stringify!(xclCounterResults))
    );
    assert_eq!(
        ::std::mem::align_of::<xclCounterResults>(),
        8usize,
        concat!("Alignment of ", stringify!(xclCounterResults))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SampleIntervalUsec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(SampleIntervalUsec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteBytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(WriteBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteTranx) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(WriteTranx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteLatency) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(WriteLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteMinLatency) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(WriteMinLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteMaxLatency) as usize - ptr as usize },
        892usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(WriteMaxLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadBytes) as usize - ptr as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(ReadBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadTranx) as usize - ptr as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(ReadTranx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadLatency) as usize - ptr as usize },
        1504usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(ReadLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadMinLatency) as usize - ptr as usize },
        1776usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(ReadMinLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadMaxLatency) as usize - ptr as usize },
        1844usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(ReadMaxLatency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadBusyCycles) as usize - ptr as usize },
        1912usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(ReadBusyCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteBusyCycles) as usize - ptr as usize },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(WriteBusyCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuExecCount) as usize - ptr as usize },
        2456usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(CuExecCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuExecCycles) as usize - ptr as usize },
        2704usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(CuExecCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuBusyCycles) as usize - ptr as usize },
        2952usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(CuBusyCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuMaxParallelIter) as usize - ptr as usize },
        3200usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(CuMaxParallelIter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuStallExtCycles) as usize - ptr as usize },
        3448usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(CuStallExtCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuStallIntCycles) as usize - ptr as usize },
        3696usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(CuStallIntCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuStallStrCycles) as usize - ptr as usize },
        3944usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(CuStallStrCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuMinExecCycles) as usize - ptr as usize },
        4192usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(CuMinExecCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuMaxExecCycles) as usize - ptr as usize },
        4440usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(CuMaxExecCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StrNumTranx) as usize - ptr as usize },
        4688usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(StrNumTranx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StrDataBytes) as usize - ptr as usize },
        4936usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(StrDataBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StrBusyCycles) as usize - ptr as usize },
        5184usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(StrBusyCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StrStallCycles) as usize - ptr as usize },
        5432usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(StrStallCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StrStarveCycles) as usize - ptr as usize },
        5680usize,
        concat!(
            "Offset of field: ",
            stringify!(xclCounterResults),
            "::",
            stringify!(StrStarveCycles)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclTraceResults {
    pub EventID: xclPerfMonEventID,
    pub EventType: xclPerfMonEventType,
    pub Timestamp: ::std::os::raw::c_ulonglong,
    pub Overflow: ::std::os::raw::c_uchar,
    pub TraceID: ::std::os::raw::c_uint,
    pub Error: ::std::os::raw::c_uchar,
    pub Reserved: ::std::os::raw::c_uchar,
    pub isClockTrain: ::std::os::raw::c_int,
    pub HostTimestamp: ::std::os::raw::c_ulonglong,
    pub EventFlags: ::std::os::raw::c_uchar,
    pub WriteAddrLen: ::std::os::raw::c_uchar,
    pub ReadAddrLen: ::std::os::raw::c_uchar,
    pub WriteBytes: ::std::os::raw::c_ushort,
    pub ReadBytes: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_xclTraceResults() {
    const UNINIT: ::std::mem::MaybeUninit<xclTraceResults> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclTraceResults>(),
        48usize,
        concat!("Size of: ", stringify!(xclTraceResults))
    );
    assert_eq!(
        ::std::mem::align_of::<xclTraceResults>(),
        8usize,
        concat!("Alignment of ", stringify!(xclTraceResults))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EventID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(EventID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EventType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(EventType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(Timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Overflow) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(Overflow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TraceID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(TraceID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Error) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(Error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isClockTrain) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(isClockTrain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HostTimestamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(HostTimestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EventFlags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(EventFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteAddrLen) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(WriteAddrLen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadAddrLen) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(ReadAddrLen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteBytes) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(WriteBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadBytes) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResults),
            "::",
            stringify!(ReadBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclTraceResultsVector {
    pub mLength: ::std::os::raw::c_uint,
    pub mArray: [xclTraceResults; 16384usize],
}
#[test]
fn bindgen_test_layout_xclTraceResultsVector() {
    const UNINIT: ::std::mem::MaybeUninit<xclTraceResultsVector> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclTraceResultsVector>(),
        786440usize,
        concat!("Size of: ", stringify!(xclTraceResultsVector))
    );
    assert_eq!(
        ::std::mem::align_of::<xclTraceResultsVector>(),
        8usize,
        concat!("Alignment of ", stringify!(xclTraceResultsVector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResultsVector),
            "::",
            stringify!(mLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mArray) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xclTraceResultsVector),
            "::",
            stringify!(mArray)
        )
    );
}
pub const DeviceType_SW_EMU: DeviceType = 0;
pub const DeviceType_HW_EMU: DeviceType = 1;
pub const DeviceType_XBB: DeviceType = 2;
pub const DeviceType_AWS: DeviceType = 3;
pub type DeviceType = ::std::os::raw::c_uint;
#[doc = " \\brief data structure for querying device info\n\n TODO:\n all the data for nifd won't be avaiable until nifd\n driver is merged and scan.h is changed to recognize\n nifd driver."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclDebugProfileDeviceInfo {
    pub device_type: DeviceType,
    pub device_index: ::std::os::raw::c_uint,
    pub user_instance: ::std::os::raw::c_uint,
    pub nifd_instance: ::std::os::raw::c_uint,
    pub device_name: [::std::os::raw::c_char; 256usize],
    pub nifd_name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_xclDebugProfileDeviceInfo() {
    const UNINIT: ::std::mem::MaybeUninit<xclDebugProfileDeviceInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclDebugProfileDeviceInfo>(),
        528usize,
        concat!("Size of: ", stringify!(xclDebugProfileDeviceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<xclDebugProfileDeviceInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(xclDebugProfileDeviceInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugProfileDeviceInfo),
            "::",
            stringify!(device_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugProfileDeviceInfo),
            "::",
            stringify!(device_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_instance) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugProfileDeviceInfo),
            "::",
            stringify!(user_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nifd_instance) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugProfileDeviceInfo),
            "::",
            stringify!(nifd_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugProfileDeviceInfo),
            "::",
            stringify!(device_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nifd_name) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugProfileDeviceInfo),
            "::",
            stringify!(nifd_name)
        )
    );
}
#[doc = "HAL API Profiling Interface plugin types\n\nThe data structure for enabling the HAL API Profiling\nplugins that will be interpreted by both the shim and\nxdp.\n\ncustom plugin requirements:\n1. Has an exported method called hal_api_interface_cb_func\nthat takes an enum type and a void pointer payload\nwhich can be cast to one of the structs below.\n2. config through initialization by setting the\nplugin path attribute to the dynamic library"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HalPluginConfig {
    pub state: ::std::os::raw::c_int,
    #[doc = " < [unused] indicates if on or off"]
    pub plugin_path: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_HalPluginConfig() {
    const UNINIT: ::std::mem::MaybeUninit<HalPluginConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HalPluginConfig>(),
        260usize,
        concat!("Size of: ", stringify!(HalPluginConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<HalPluginConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(HalPluginConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HalPluginConfig),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plugin_path) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HalPluginConfig),
            "::",
            stringify!(plugin_path)
        )
    );
}
pub const HalInterfaceCallbackType_START_DEVICE_PROFILING: HalInterfaceCallbackType = 0;
pub const HalInterfaceCallbackType_CREATE_PROFILE_RESULTS: HalInterfaceCallbackType = 1;
pub const HalInterfaceCallbackType_GET_PROFILE_RESULTS: HalInterfaceCallbackType = 2;
pub const HalInterfaceCallbackType_DESTROY_PROFILE_RESULTS: HalInterfaceCallbackType = 3;
pub type HalInterfaceCallbackType = ::std::os::raw::c_uint;
#[doc = " This is an example of the struct that callback\n functions can take. Eventually, different API\n callbacks are likely to take different structs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBPayload {
    pub idcode: u64,
    pub deviceHandle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CBPayload() {
    const UNINIT: ::std::mem::MaybeUninit<CBPayload> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CBPayload>(),
        16usize,
        concat!("Size of: ", stringify!(CBPayload))
    );
    assert_eq!(
        ::std::mem::align_of::<CBPayload>(),
        8usize,
        concat!("Alignment of ", stringify!(CBPayload))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBPayload),
            "::",
            stringify!(idcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBPayload),
            "::",
            stringify!(deviceHandle)
        )
    );
}
#[doc = " More callback payload struct should be declared\n here for the users to include."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BOTransferCBPayload {
    pub basePayload: CBPayload,
    pub bufferTransferId: u64,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_BOTransferCBPayload() {
    const UNINIT: ::std::mem::MaybeUninit<BOTransferCBPayload> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BOTransferCBPayload>(),
        32usize,
        concat!("Size of: ", stringify!(BOTransferCBPayload))
    );
    assert_eq!(
        ::std::mem::align_of::<BOTransferCBPayload>(),
        8usize,
        concat!("Alignment of ", stringify!(BOTransferCBPayload))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basePayload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BOTransferCBPayload),
            "::",
            stringify!(basePayload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferTransferId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BOTransferCBPayload),
            "::",
            stringify!(bufferTransferId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BOTransferCBPayload),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SyncBOCBPayload {
    pub basePayload: CBPayload,
    pub bufferTransferId: u64,
    pub size: usize,
    pub isWriteToDevice: bool,
}
#[test]
fn bindgen_test_layout_SyncBOCBPayload() {
    const UNINIT: ::std::mem::MaybeUninit<SyncBOCBPayload> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SyncBOCBPayload>(),
        40usize,
        concat!("Size of: ", stringify!(SyncBOCBPayload))
    );
    assert_eq!(
        ::std::mem::align_of::<SyncBOCBPayload>(),
        8usize,
        concat!("Alignment of ", stringify!(SyncBOCBPayload))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basePayload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SyncBOCBPayload),
            "::",
            stringify!(basePayload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferTransferId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SyncBOCBPayload),
            "::",
            stringify!(bufferTransferId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SyncBOCBPayload),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isWriteToDevice) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SyncBOCBPayload),
            "::",
            stringify!(isWriteToDevice)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReadWriteCBPayload {
    pub basePayload: CBPayload,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_ReadWriteCBPayload() {
    const UNINIT: ::std::mem::MaybeUninit<ReadWriteCBPayload> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ReadWriteCBPayload>(),
        24usize,
        concat!("Size of: ", stringify!(ReadWriteCBPayload))
    );
    assert_eq!(
        ::std::mem::align_of::<ReadWriteCBPayload>(),
        8usize,
        concat!("Alignment of ", stringify!(ReadWriteCBPayload))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basePayload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ReadWriteCBPayload),
            "::",
            stringify!(basePayload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ReadWriteCBPayload),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnmgdPreadPwriteCBPayload {
    pub basePayload: CBPayload,
    pub flags: ::std::os::raw::c_uint,
    pub count: usize,
    pub offset: u64,
}
#[test]
fn bindgen_test_layout_UnmgdPreadPwriteCBPayload() {
    const UNINIT: ::std::mem::MaybeUninit<UnmgdPreadPwriteCBPayload> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UnmgdPreadPwriteCBPayload>(),
        40usize,
        concat!("Size of: ", stringify!(UnmgdPreadPwriteCBPayload))
    );
    assert_eq!(
        ::std::mem::align_of::<UnmgdPreadPwriteCBPayload>(),
        8usize,
        concat!("Alignment of ", stringify!(UnmgdPreadPwriteCBPayload))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basePayload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UnmgdPreadPwriteCBPayload),
            "::",
            stringify!(basePayload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UnmgdPreadPwriteCBPayload),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UnmgdPreadPwriteCBPayload),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UnmgdPreadPwriteCBPayload),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XclbinCBPayload {
    pub basePayload: CBPayload,
    pub binary: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_XclbinCBPayload() {
    const UNINIT: ::std::mem::MaybeUninit<XclbinCBPayload> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<XclbinCBPayload>(),
        24usize,
        concat!("Size of: ", stringify!(XclbinCBPayload))
    );
    assert_eq!(
        ::std::mem::align_of::<XclbinCBPayload>(),
        8usize,
        concat!("Alignment of ", stringify!(XclbinCBPayload))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basePayload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XclbinCBPayload),
            "::",
            stringify!(basePayload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binary) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XclbinCBPayload),
            "::",
            stringify!(binary)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProfileResultsCBPayload {
    pub basePayload: CBPayload,
    pub results: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ProfileResultsCBPayload() {
    const UNINIT: ::std::mem::MaybeUninit<ProfileResultsCBPayload> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ProfileResultsCBPayload>(),
        24usize,
        concat!("Size of: ", stringify!(ProfileResultsCBPayload))
    );
    assert_eq!(
        ::std::mem::align_of::<ProfileResultsCBPayload>(),
        8usize,
        concat!("Alignment of ", stringify!(ProfileResultsCBPayload))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basePayload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProfileResultsCBPayload),
            "::",
            stringify!(basePayload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).results) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ProfileResultsCBPayload),
            "::",
            stringify!(results)
        )
    );
}
pub const xclDebugReadType_XCL_DEBUG_READ_TYPE_APM: xclDebugReadType = 0;
pub const xclDebugReadType_XCL_DEBUG_READ_TYPE_LAPC: xclDebugReadType = 1;
pub const xclDebugReadType_XCL_DEBUG_READ_TYPE_AIM: xclDebugReadType = 2;
pub const xclDebugReadType_XCL_DEBUG_READ_TYPE_ASM: xclDebugReadType = 3;
pub const xclDebugReadType_XCL_DEBUG_READ_TYPE_AM: xclDebugReadType = 4;
pub const xclDebugReadType_XCL_DEBUG_READ_TYPE_SPC: xclDebugReadType = 5;
pub const xclDebugReadType_XCL_DEBUG_READ_TYPE_ADD: xclDebugReadType = 6;
#[doc = " Definitions: Enums, Structs"]
pub type xclDebugReadType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclDebugCountersResults {
    pub WriteBytes: [::std::os::raw::c_ulonglong; 34usize],
    pub WriteTranx: [::std::os::raw::c_ulonglong; 34usize],
    pub ReadBytes: [::std::os::raw::c_ulonglong; 34usize],
    pub ReadTranx: [::std::os::raw::c_ulonglong; 34usize],
    pub OutStandCnts: [::std::os::raw::c_ulonglong; 34usize],
    pub LastWriteAddr: [::std::os::raw::c_ulonglong; 34usize],
    pub LastWriteData: [::std::os::raw::c_ulonglong; 34usize],
    pub LastReadAddr: [::std::os::raw::c_ulonglong; 34usize],
    pub LastReadData: [::std::os::raw::c_ulonglong; 34usize],
    pub NumSlots: ::std::os::raw::c_uint,
    pub DevUserName: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_xclDebugCountersResults() {
    const UNINIT: ::std::mem::MaybeUninit<xclDebugCountersResults> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclDebugCountersResults>(),
        2712usize,
        concat!("Size of: ", stringify!(xclDebugCountersResults))
    );
    assert_eq!(
        ::std::mem::align_of::<xclDebugCountersResults>(),
        8usize,
        concat!("Alignment of ", stringify!(xclDebugCountersResults))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCountersResults),
            "::",
            stringify!(WriteBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteTranx) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCountersResults),
            "::",
            stringify!(WriteTranx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadBytes) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCountersResults),
            "::",
            stringify!(ReadBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadTranx) as usize - ptr as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCountersResults),
            "::",
            stringify!(ReadTranx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutStandCnts) as usize - ptr as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCountersResults),
            "::",
            stringify!(OutStandCnts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastWriteAddr) as usize - ptr as usize },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCountersResults),
            "::",
            stringify!(LastWriteAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastWriteData) as usize - ptr as usize },
        1632usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCountersResults),
            "::",
            stringify!(LastWriteData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastReadAddr) as usize - ptr as usize },
        1904usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCountersResults),
            "::",
            stringify!(LastReadAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastReadData) as usize - ptr as usize },
        2176usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCountersResults),
            "::",
            stringify!(LastReadData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumSlots) as usize - ptr as usize },
        2448usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCountersResults),
            "::",
            stringify!(NumSlots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DevUserName) as usize - ptr as usize },
        2452usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCountersResults),
            "::",
            stringify!(DevUserName)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclStreamingDebugCountersResults {
    pub NumSlots: ::std::os::raw::c_uint,
    pub DevUserName: [::std::os::raw::c_char; 256usize],
    pub StrNumTranx: [::std::os::raw::c_ulonglong; 31usize],
    pub StrDataBytes: [::std::os::raw::c_ulonglong; 31usize],
    pub StrBusyCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub StrStallCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub StrStarveCycles: [::std::os::raw::c_ulonglong; 31usize],
}
#[test]
fn bindgen_test_layout_xclStreamingDebugCountersResults() {
    const UNINIT: ::std::mem::MaybeUninit<xclStreamingDebugCountersResults> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclStreamingDebugCountersResults>(),
        1504usize,
        concat!("Size of: ", stringify!(xclStreamingDebugCountersResults))
    );
    assert_eq!(
        ::std::mem::align_of::<xclStreamingDebugCountersResults>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(xclStreamingDebugCountersResults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumSlots) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclStreamingDebugCountersResults),
            "::",
            stringify!(NumSlots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DevUserName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xclStreamingDebugCountersResults),
            "::",
            stringify!(DevUserName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StrNumTranx) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(xclStreamingDebugCountersResults),
            "::",
            stringify!(StrNumTranx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StrDataBytes) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(xclStreamingDebugCountersResults),
            "::",
            stringify!(StrDataBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StrBusyCycles) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(xclStreamingDebugCountersResults),
            "::",
            stringify!(StrBusyCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StrStallCycles) as usize - ptr as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(xclStreamingDebugCountersResults),
            "::",
            stringify!(StrStallCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StrStarveCycles) as usize - ptr as usize },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(xclStreamingDebugCountersResults),
            "::",
            stringify!(StrStarveCycles)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclAccelMonitorCounterResults {
    pub NumSlots: ::std::os::raw::c_uint,
    pub DevUserName: [::std::os::raw::c_char; 256usize],
    pub CuExecCount: [::std::os::raw::c_ulonglong; 31usize],
    pub CuExecCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub CuBusyCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub CuMaxParallelIter: [::std::os::raw::c_ulonglong; 31usize],
    pub CuStallExtCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub CuStallIntCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub CuStallStrCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub CuMinExecCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub CuMaxExecCycles: [::std::os::raw::c_ulonglong; 31usize],
    pub CuStartCount: [::std::os::raw::c_ulonglong; 31usize],
}
#[test]
fn bindgen_test_layout_xclAccelMonitorCounterResults() {
    const UNINIT: ::std::mem::MaybeUninit<xclAccelMonitorCounterResults> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclAccelMonitorCounterResults>(),
        2744usize,
        concat!("Size of: ", stringify!(xclAccelMonitorCounterResults))
    );
    assert_eq!(
        ::std::mem::align_of::<xclAccelMonitorCounterResults>(),
        8usize,
        concat!("Alignment of ", stringify!(xclAccelMonitorCounterResults))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumSlots) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelMonitorCounterResults),
            "::",
            stringify!(NumSlots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DevUserName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelMonitorCounterResults),
            "::",
            stringify!(DevUserName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuExecCount) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelMonitorCounterResults),
            "::",
            stringify!(CuExecCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuExecCycles) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelMonitorCounterResults),
            "::",
            stringify!(CuExecCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuBusyCycles) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelMonitorCounterResults),
            "::",
            stringify!(CuBusyCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuMaxParallelIter) as usize - ptr as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelMonitorCounterResults),
            "::",
            stringify!(CuMaxParallelIter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuStallExtCycles) as usize - ptr as usize },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelMonitorCounterResults),
            "::",
            stringify!(CuStallExtCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuStallIntCycles) as usize - ptr as usize },
        1504usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelMonitorCounterResults),
            "::",
            stringify!(CuStallIntCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuStallStrCycles) as usize - ptr as usize },
        1752usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelMonitorCounterResults),
            "::",
            stringify!(CuStallStrCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuMinExecCycles) as usize - ptr as usize },
        2000usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelMonitorCounterResults),
            "::",
            stringify!(CuMinExecCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuMaxExecCycles) as usize - ptr as usize },
        2248usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelMonitorCounterResults),
            "::",
            stringify!(CuMaxExecCycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CuStartCount) as usize - ptr as usize },
        2496usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelMonitorCounterResults),
            "::",
            stringify!(CuStartCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclAccelDeadlockDetectorResults {
    pub Num: ::std::os::raw::c_uint,
    pub DeadlockStatus: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xclAccelDeadlockDetectorResults() {
    const UNINIT: ::std::mem::MaybeUninit<xclAccelDeadlockDetectorResults> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclAccelDeadlockDetectorResults>(),
        8usize,
        concat!("Size of: ", stringify!(xclAccelDeadlockDetectorResults))
    );
    assert_eq!(
        ::std::mem::align_of::<xclAccelDeadlockDetectorResults>(),
        4usize,
        concat!("Alignment of ", stringify!(xclAccelDeadlockDetectorResults))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelDeadlockDetectorResults),
            "::",
            stringify!(Num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeadlockStatus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xclAccelDeadlockDetectorResults),
            "::",
            stringify!(DeadlockStatus)
        )
    );
}
pub const xclCheckerType_XCL_CHECKER_MEMORY: xclCheckerType = 0;
pub const xclCheckerType_XCL_CHECKER_STREAM: xclCheckerType = 1;
pub type xclCheckerType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclDebugCheckersResults {
    pub OverallStatus: [::std::os::raw::c_uint; 31usize],
    pub CumulativeStatus: [[::std::os::raw::c_uint; 4usize]; 31usize],
    pub SnapshotStatus: [[::std::os::raw::c_uint; 4usize]; 31usize],
    pub NumSlots: ::std::os::raw::c_uint,
    pub DevUserName: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_xclDebugCheckersResults() {
    const UNINIT: ::std::mem::MaybeUninit<xclDebugCheckersResults> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclDebugCheckersResults>(),
        1376usize,
        concat!("Size of: ", stringify!(xclDebugCheckersResults))
    );
    assert_eq!(
        ::std::mem::align_of::<xclDebugCheckersResults>(),
        4usize,
        concat!("Alignment of ", stringify!(xclDebugCheckersResults))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OverallStatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCheckersResults),
            "::",
            stringify!(OverallStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CumulativeStatus) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCheckersResults),
            "::",
            stringify!(CumulativeStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SnapshotStatus) as usize - ptr as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCheckersResults),
            "::",
            stringify!(SnapshotStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumSlots) as usize - ptr as usize },
        1116usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCheckersResults),
            "::",
            stringify!(NumSlots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DevUserName) as usize - ptr as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugCheckersResults),
            "::",
            stringify!(DevUserName)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclDebugStreamingCheckersResults {
    pub PCAsserted: [::std::os::raw::c_uint; 31usize],
    pub CurrentPC: [::std::os::raw::c_uint; 31usize],
    pub SnapshotPC: [::std::os::raw::c_uint; 31usize],
    pub NumSlots: ::std::os::raw::c_uint,
    pub DevUserName: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_xclDebugStreamingCheckersResults() {
    const UNINIT: ::std::mem::MaybeUninit<xclDebugStreamingCheckersResults> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclDebugStreamingCheckersResults>(),
        632usize,
        concat!("Size of: ", stringify!(xclDebugStreamingCheckersResults))
    );
    assert_eq!(
        ::std::mem::align_of::<xclDebugStreamingCheckersResults>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xclDebugStreamingCheckersResults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PCAsserted) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugStreamingCheckersResults),
            "::",
            stringify!(PCAsserted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentPC) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugStreamingCheckersResults),
            "::",
            stringify!(CurrentPC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SnapshotPC) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugStreamingCheckersResults),
            "::",
            stringify!(SnapshotPC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumSlots) as usize - ptr as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugStreamingCheckersResults),
            "::",
            stringify!(NumSlots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DevUserName) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDebugStreamingCheckersResults),
            "::",
            stringify!(DevUserName)
        )
    );
}
pub type xclDeviceHandle = *mut ::std::os::raw::c_void;
pub type xclBufferHandle = ::std::os::raw::c_uint;
pub type xrt_buffer_handle = *mut ::std::os::raw::c_void;
pub type xclBufferExportHandle = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclDeviceInfo2 {
    pub mMagic: ::std::os::raw::c_uint,
    pub mName: [::std::os::raw::c_char; 256usize],
    pub mHALMajorVersion: ::std::os::raw::c_ushort,
    pub mHALMinorVersion: ::std::os::raw::c_ushort,
    pub mVendorId: ::std::os::raw::c_ushort,
    pub mDeviceId: ::std::os::raw::c_ushort,
    pub mSubsystemId: ::std::os::raw::c_ushort,
    pub mSubsystemVendorId: ::std::os::raw::c_ushort,
    pub mDeviceVersion: ::std::os::raw::c_ushort,
    pub mDDRSize: usize,
    pub mDataAlignment: usize,
    pub mDDRFreeSize: usize,
    pub mMinTransferSize: usize,
    pub mDDRBankCount: ::std::os::raw::c_ushort,
    pub mOCLFrequency: [::std::os::raw::c_ushort; 4usize],
    pub mPCIeLinkWidth: ::std::os::raw::c_ushort,
    pub mPCIeLinkSpeed: ::std::os::raw::c_ushort,
    pub mDMAThreads: ::std::os::raw::c_ushort,
    pub mOnChipTemp: ::std::os::raw::c_ushort,
    pub mFanTemp: ::std::os::raw::c_ushort,
    pub mVInt: ::std::os::raw::c_ushort,
    pub mVAux: ::std::os::raw::c_ushort,
    pub mVBram: ::std::os::raw::c_ushort,
    pub mCurrent: f32,
    pub mNumClocks: ::std::os::raw::c_ushort,
    pub mFanSpeed: ::std::os::raw::c_ushort,
    pub mMigCalib: bool,
    pub mXMCVersion: ::std::os::raw::c_ulonglong,
    pub mMBVersion: ::std::os::raw::c_ulonglong,
    pub m12VPex: ::std::os::raw::c_ushort,
    pub m12VAux: ::std::os::raw::c_ushort,
    pub mPexCurr: ::std::os::raw::c_ulonglong,
    pub mAuxCurr: ::std::os::raw::c_ulonglong,
    pub mFanRpm: ::std::os::raw::c_ushort,
    pub mDimmTemp: [::std::os::raw::c_ushort; 4usize],
    pub mSE98Temp: [::std::os::raw::c_ushort; 4usize],
    pub m3v3Pex: ::std::os::raw::c_ushort,
    pub m3v3Aux: ::std::os::raw::c_ushort,
    pub mDDRVppBottom: ::std::os::raw::c_ushort,
    pub mDDRVppTop: ::std::os::raw::c_ushort,
    pub mSys5v5: ::std::os::raw::c_ushort,
    pub m1v2Top: ::std::os::raw::c_ushort,
    pub m1v8Top: ::std::os::raw::c_ushort,
    pub m0v85: ::std::os::raw::c_ushort,
    pub mMgt0v9: ::std::os::raw::c_ushort,
    pub m12vSW: ::std::os::raw::c_ushort,
    pub mMgtVtt: ::std::os::raw::c_ushort,
    pub m1v2Bottom: ::std::os::raw::c_ushort,
    pub mDriverVersion: ::std::os::raw::c_ulonglong,
    pub mPciSlot: ::std::os::raw::c_uint,
    pub mIsXPR: bool,
    pub mTimeStamp: ::std::os::raw::c_ulonglong,
    pub mFpga: [::std::os::raw::c_char; 256usize],
    pub mPCIeLinkWidthMax: ::std::os::raw::c_ushort,
    pub mPCIeLinkSpeedMax: ::std::os::raw::c_ushort,
    pub mVccIntVol: ::std::os::raw::c_ushort,
    pub mVccIntCurr: ::std::os::raw::c_ushort,
    pub mNumCDMA: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_xclDeviceInfo2() {
    const UNINIT: ::std::mem::MaybeUninit<xclDeviceInfo2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclDeviceInfo2>(),
        736usize,
        concat!("Size of: ", stringify!(xclDeviceInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<xclDeviceInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(xclDeviceInfo2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mMagic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mMagic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mHALMajorVersion) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mHALMajorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mHALMinorVersion) as usize - ptr as usize },
        262usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mHALMinorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mVendorId) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mVendorId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mDeviceId) as usize - ptr as usize },
        266usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mDeviceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mSubsystemId) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mSubsystemId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mSubsystemVendorId) as usize - ptr as usize },
        270usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mSubsystemVendorId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mDeviceVersion) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mDeviceVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mDDRSize) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mDDRSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mDataAlignment) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mDataAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mDDRFreeSize) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mDDRFreeSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mMinTransferSize) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mMinTransferSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mDDRBankCount) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mDDRBankCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mOCLFrequency) as usize - ptr as usize },
        314usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mOCLFrequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mPCIeLinkWidth) as usize - ptr as usize },
        322usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mPCIeLinkWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mPCIeLinkSpeed) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mPCIeLinkSpeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mDMAThreads) as usize - ptr as usize },
        326usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mDMAThreads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mOnChipTemp) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mOnChipTemp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mFanTemp) as usize - ptr as usize },
        330usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mFanTemp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mVInt) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mVInt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mVAux) as usize - ptr as usize },
        334usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mVAux)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mVBram) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mVBram)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mCurrent) as usize - ptr as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mCurrent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mNumClocks) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mNumClocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mFanSpeed) as usize - ptr as usize },
        346usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mFanSpeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mMigCalib) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mMigCalib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mXMCVersion) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mXMCVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mMBVersion) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mMBVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m12VPex) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(m12VPex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m12VAux) as usize - ptr as usize },
        370usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(m12VAux)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mPexCurr) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mPexCurr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mAuxCurr) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mAuxCurr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mFanRpm) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mFanRpm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mDimmTemp) as usize - ptr as usize },
        394usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mDimmTemp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mSE98Temp) as usize - ptr as usize },
        402usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mSE98Temp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m3v3Pex) as usize - ptr as usize },
        410usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(m3v3Pex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m3v3Aux) as usize - ptr as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(m3v3Aux)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mDDRVppBottom) as usize - ptr as usize },
        414usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mDDRVppBottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mDDRVppTop) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mDDRVppTop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mSys5v5) as usize - ptr as usize },
        418usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mSys5v5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m1v2Top) as usize - ptr as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(m1v2Top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m1v8Top) as usize - ptr as usize },
        422usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(m1v8Top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m0v85) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(m0v85)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mMgt0v9) as usize - ptr as usize },
        426usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mMgt0v9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m12vSW) as usize - ptr as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(m12vSW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mMgtVtt) as usize - ptr as usize },
        430usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mMgtVtt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m1v2Bottom) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(m1v2Bottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mDriverVersion) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mDriverVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mPciSlot) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mPciSlot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mIsXPR) as usize - ptr as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mIsXPR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mTimeStamp) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mTimeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mFpga) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mFpga)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mPCIeLinkWidthMax) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mPCIeLinkWidthMax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mPCIeLinkSpeedMax) as usize - ptr as usize },
        722usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mPCIeLinkSpeedMax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mVccIntVol) as usize - ptr as usize },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mVccIntVol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mVccIntCurr) as usize - ptr as usize },
        726usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mVccIntCurr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mNumCDMA) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceInfo2),
            "::",
            stringify!(mNumCDMA)
        )
    );
}
pub const xclBOKind_XCL_BO_SHARED_VIRTUAL: xclBOKind = 0;
pub const xclBOKind_XCL_BO_SHARED_PHYSICAL: xclBOKind = 1;
pub const xclBOKind_XCL_BO_MIRRORED_VIRTUAL: xclBOKind = 2;
pub const xclBOKind_XCL_BO_DEVICE_RAM: xclBOKind = 3;
pub const xclBOKind_XCL_BO_DEVICE_BRAM: xclBOKind = 4;
pub const xclBOKind_XCL_BO_DEVICE_PREALLOCATED_BRAM: xclBOKind = 5;
pub type xclBOKind = ::std::os::raw::c_uint;
pub const xclBOSyncDirection_XCL_BO_SYNC_BO_TO_DEVICE: xclBOSyncDirection = 0;
pub const xclBOSyncDirection_XCL_BO_SYNC_BO_FROM_DEVICE: xclBOSyncDirection = 1;
pub const xclBOSyncDirection_XCL_BO_SYNC_BO_GMIO_TO_AIE: xclBOSyncDirection = 2;
pub const xclBOSyncDirection_XCL_BO_SYNC_BO_AIE_TO_GMIO: xclBOSyncDirection = 3;
pub type xclBOSyncDirection = ::std::os::raw::c_uint;
pub const xclAddressSpace_XCL_ADDR_SPACE_DEVICE_FLAT: xclAddressSpace = 0;
pub const xclAddressSpace_XCL_ADDR_SPACE_DEVICE_RAM: xclAddressSpace = 1;
pub const xclAddressSpace_XCL_ADDR_KERNEL_CTRL: xclAddressSpace = 2;
pub const xclAddressSpace_XCL_ADDR_SPACE_DEVICE_PERFMON: xclAddressSpace = 3;
pub const xclAddressSpace_XCL_ADDR_SPACE_DEVICE_REG: xclAddressSpace = 4;
pub const xclAddressSpace_XCL_ADDR_SPACE_DEVICE_CHECKER: xclAddressSpace = 5;
pub const xclAddressSpace_XCL_ADDR_SPACE_MAX: xclAddressSpace = 8;
pub type xclAddressSpace = ::std::os::raw::c_uint;
pub const xrtLogMsgLevel_XRT_EMERGENCY: xrtLogMsgLevel = 0;
pub const xrtLogMsgLevel_XRT_ALERT: xrtLogMsgLevel = 1;
pub const xrtLogMsgLevel_XRT_CRITICAL: xrtLogMsgLevel = 2;
pub const xrtLogMsgLevel_XRT_ERROR: xrtLogMsgLevel = 3;
pub const xrtLogMsgLevel_XRT_WARNING: xrtLogMsgLevel = 4;
pub const xrtLogMsgLevel_XRT_NOTICE: xrtLogMsgLevel = 5;
pub const xrtLogMsgLevel_XRT_INFO: xrtLogMsgLevel = 6;
pub const xrtLogMsgLevel_XRT_DEBUG: xrtLogMsgLevel = 7;
pub type xrtLogMsgLevel = ::std::os::raw::c_uint;
pub const xclVerbosityLevel_XCL_QUIET: xclVerbosityLevel = 0;
pub const xclVerbosityLevel_XCL_INFO: xclVerbosityLevel = 1;
pub const xclVerbosityLevel_XCL_WARN: xclVerbosityLevel = 2;
pub const xclVerbosityLevel_XCL_ERROR: xclVerbosityLevel = 3;
pub type xclVerbosityLevel = ::std::os::raw::c_uint;
pub const xclResetKind_XCL_RESET_KERNEL: xclResetKind = 0;
pub const xclResetKind_XCL_RESET_FULL: xclResetKind = 1;
pub const xclResetKind_XCL_USER_RESET: xclResetKind = 2;
pub type xclResetKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclDeviceUsage {
    pub h2c: [usize; 8usize],
    pub c2h: [usize; 8usize],
    pub ddrMemUsed: [usize; 8usize],
    pub ddrBOAllocated: [::std::os::raw::c_uint; 8usize],
    pub totalContexts: ::std::os::raw::c_uint,
    pub xclbinId: [u64; 4usize],
    pub dma_channel_cnt: ::std::os::raw::c_uint,
    pub mm_channel_cnt: ::std::os::raw::c_uint,
    pub memSize: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_xclDeviceUsage() {
    const UNINIT: ::std::mem::MaybeUninit<xclDeviceUsage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclDeviceUsage>(),
        336usize,
        concat!("Size of: ", stringify!(xclDeviceUsage))
    );
    assert_eq!(
        ::std::mem::align_of::<xclDeviceUsage>(),
        8usize,
        concat!("Alignment of ", stringify!(xclDeviceUsage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h2c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceUsage),
            "::",
            stringify!(h2c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c2h) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceUsage),
            "::",
            stringify!(c2h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ddrMemUsed) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceUsage),
            "::",
            stringify!(ddrMemUsed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ddrBOAllocated) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceUsage),
            "::",
            stringify!(ddrBOAllocated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalContexts) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceUsage),
            "::",
            stringify!(totalContexts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xclbinId) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceUsage),
            "::",
            stringify!(xclbinId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dma_channel_cnt) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceUsage),
            "::",
            stringify!(dma_channel_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mm_channel_cnt) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceUsage),
            "::",
            stringify!(mm_channel_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memSize) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(xclDeviceUsage),
            "::",
            stringify!(memSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclBOProperties {
    pub handle: u32,
    pub flags: u32,
    pub size: u64,
    pub paddr: u64,
    pub reserved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xclBOProperties() {
    const UNINIT: ::std::mem::MaybeUninit<xclBOProperties> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclBOProperties>(),
        32usize,
        concat!("Size of: ", stringify!(xclBOProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<xclBOProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(xclBOProperties))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclBOProperties),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xclBOProperties),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xclBOProperties),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paddr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xclBOProperties),
            "::",
            stringify!(paddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xclBOProperties),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn xclProbe() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xclOpen(
        deviceIndex: ::std::os::raw::c_uint,
        unused1: *const ::std::os::raw::c_char,
        unused2: xclVerbosityLevel,
    ) -> xclDeviceHandle;
}
extern "C" {
    pub fn xclClose(handle: xclDeviceHandle);
}
extern "C" {
    pub fn xclGetDeviceInfo2(
        handle: xclDeviceHandle,
        info: *mut xclDeviceInfo2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclGetUsageInfo(
        handle: xclDeviceHandle,
        info: *mut xclDeviceUsage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclGetErrorStatus(
        handle: xclDeviceHandle,
        info: *mut xclErrorStatus,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclLoadXclBin(handle: xclDeviceHandle, buffer: *const axlf) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclGetSectionInfo(
        handle: xclDeviceHandle,
        info: *mut ::std::os::raw::c_void,
        size: *mut usize,
        kind: axlf_section_kind,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclReClock2(
        handle: xclDeviceHandle,
        region: ::std::os::raw::c_ushort,
        targetFreqMHz: *const ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclOpenContext(
        handle: xclDeviceHandle,
        xclbinId: *mut ::std::os::raw::c_uchar,
        ipIndex: ::std::os::raw::c_uint,
        shared: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclCloseContext(
        handle: xclDeviceHandle,
        xclbinId: *mut ::std::os::raw::c_uchar,
        ipIndex: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclVersion() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xclLogMsg(
        handle: xclDeviceHandle,
        level: xrtLogMsgLevel,
        tag: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclAllocBO(
        handle: xclDeviceHandle,
        size: usize,
        unused: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> xclBufferHandle;
}
extern "C" {
    pub fn xclAllocUserPtrBO(
        handle: xclDeviceHandle,
        userptr: *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> xclBufferHandle;
}
extern "C" {
    pub fn xclFreeBO(handle: xclDeviceHandle, boHandle: xclBufferHandle);
}
extern "C" {
    pub fn xclWriteBO(
        handle: xclDeviceHandle,
        boHandle: xclBufferHandle,
        src: *const ::std::os::raw::c_void,
        size: usize,
        seek: usize,
    ) -> usize;
}
extern "C" {
    pub fn xclReadBO(
        handle: xclDeviceHandle,
        boHandle: xclBufferHandle,
        dst: *mut ::std::os::raw::c_void,
        size: usize,
        skip: usize,
    ) -> usize;
}
extern "C" {
    pub fn xclMapBO(
        handle: xclDeviceHandle,
        boHandle: xclBufferHandle,
        write: bool,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xclUnmapBO(
        handle: xclDeviceHandle,
        boHandle: xclBufferHandle,
        addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclSyncBO(
        handle: xclDeviceHandle,
        boHandle: xclBufferHandle,
        dir: xclBOSyncDirection,
        size: usize,
        offset: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclCopyBO(
        handle: xclDeviceHandle,
        dstBoHandle: xclBufferHandle,
        srcBoHandle: xclBufferHandle,
        size: usize,
        dst_offset: usize,
        src_offset: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclExportBO(handle: xclDeviceHandle, boHandle: xclBufferHandle)
        -> xclBufferExportHandle;
}
extern "C" {
    pub fn xclImportBO(
        handle: xclDeviceHandle,
        fd: xclBufferExportHandle,
        flags: ::std::os::raw::c_uint,
    ) -> xclBufferHandle;
}
extern "C" {
    pub fn xclGetBOProperties(
        handle: xclDeviceHandle,
        boHandle: xclBufferHandle,
        properties: *mut xclBOProperties,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclIPName2Index(
        handle: xclDeviceHandle,
        ipName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclUnmgdPread(
        handle: xclDeviceHandle,
        flags: ::std::os::raw::c_uint,
        buf: *mut ::std::os::raw::c_void,
        size: usize,
        offset: u64,
    ) -> isize;
}
extern "C" {
    pub fn xclUnmgdPwrite(
        handle: xclDeviceHandle,
        flags: ::std::os::raw::c_uint,
        buf: *const ::std::os::raw::c_void,
        size: usize,
        offset: u64,
    ) -> isize;
}
extern "C" {
    pub fn xclExecBuf(handle: xclDeviceHandle, cmdBO: xclBufferHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclExecWait(
        handle: xclDeviceHandle,
        timeoutMilliSec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrap_get_axlf_section(
        top: *const axlf,
        kind: axlf_section_kind,
    ) -> *const axlf_section_header;
}
extern "C" {
    pub fn xclResetDevice(handle: xclDeviceHandle, kind: xclResetKind) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclLockDevice(handle: xclDeviceHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclUnlockDevice(handle: xclDeviceHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclUpgradeFirmware(
        handle: xclDeviceHandle,
        fileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclUpgradeFirmware2(
        handle: xclDeviceHandle,
        file1: *const ::std::os::raw::c_char,
        file2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclUpgradeFirmwareXSpi(
        handle: xclDeviceHandle,
        fileName: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclBootFPGA(handle: xclDeviceHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclRemoveAndScanFPGA() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclWrite(
        handle: xclDeviceHandle,
        space: xclAddressSpace,
        offset: u64,
        hostBuf: *const ::std::os::raw::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    pub fn xclRead(
        handle: xclDeviceHandle,
        space: xclAddressSpace,
        offset: u64,
        hostbuf: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    pub fn xclRegisterInterruptNotify(
        handle: xclDeviceHandle,
        userInterrupt: ::std::os::raw::c_uint,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const xclStreamContextFlags_XRT_QUEUE_FLAG_POLLING: xclStreamContextFlags = 4;
pub type xclStreamContextFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclQueueContext {
    pub type_: u32,
    pub state: u32,
    pub route: u64,
    pub flow: u64,
    pub qsize: u32,
    pub desc_size: u32,
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_xclQueueContext() {
    const UNINIT: ::std::mem::MaybeUninit<xclQueueContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclQueueContext>(),
        40usize,
        concat!("Size of: ", stringify!(xclQueueContext))
    );
    assert_eq!(
        ::std::mem::align_of::<xclQueueContext>(),
        8usize,
        concat!("Alignment of ", stringify!(xclQueueContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueContext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueContext),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).route) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueContext),
            "::",
            stringify!(route)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flow) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueContext),
            "::",
            stringify!(flow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueContext),
            "::",
            stringify!(qsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc_size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueContext),
            "::",
            stringify!(desc_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueContext),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xclReqBuffer {
    pub __bindgen_anon_1: xclReqBuffer__bindgen_ty_1,
    pub len: u64,
    pub buf_hdl: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xclReqBuffer__bindgen_ty_1 {
    pub buf: *mut ::std::os::raw::c_char,
    pub va: u64,
}
#[test]
fn bindgen_test_layout_xclReqBuffer__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<xclReqBuffer__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclReqBuffer__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(xclReqBuffer__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<xclReqBuffer__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(xclReqBuffer__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclReqBuffer__bindgen_ty_1),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclReqBuffer__bindgen_ty_1),
            "::",
            stringify!(va)
        )
    );
}
#[test]
fn bindgen_test_layout_xclReqBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<xclReqBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclReqBuffer>(),
        24usize,
        concat!("Size of: ", stringify!(xclReqBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<xclReqBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(xclReqBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xclReqBuffer),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_hdl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xclReqBuffer),
            "::",
            stringify!(buf_hdl)
        )
    );
}
pub const xclQueueRequestKind_XCL_QUEUE_WRITE: xclQueueRequestKind = 0;
pub const xclQueueRequestKind_XCL_QUEUE_READ: xclQueueRequestKind = 1;
pub type xclQueueRequestKind = ::std::os::raw::c_uint;
pub const xclQueueRequestFlag_XCL_QUEUE_REQ_EOT: xclQueueRequestFlag = 1;
pub const xclQueueRequestFlag_XCL_QUEUE_REQ_CDH: xclQueueRequestFlag = 2;
pub const xclQueueRequestFlag_XCL_QUEUE_REQ_NONBLOCKING: xclQueueRequestFlag = 4;
pub const xclQueueRequestFlag_XCL_QUEUE_REQ_SILENT: xclQueueRequestFlag = 8;
pub type xclQueueRequestFlag = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclQueueRequest {
    pub op_code: xclQueueRequestKind,
    pub bufs: *mut xclReqBuffer,
    pub buf_num: u32,
    pub cdh: *mut ::std::os::raw::c_char,
    pub cdh_len: u32,
    pub flag: u32,
    pub priv_data: *mut ::std::os::raw::c_void,
    pub timeout: u32,
}
#[test]
fn bindgen_test_layout_xclQueueRequest() {
    const UNINIT: ::std::mem::MaybeUninit<xclQueueRequest> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclQueueRequest>(),
        56usize,
        concat!("Size of: ", stringify!(xclQueueRequest))
    );
    assert_eq!(
        ::std::mem::align_of::<xclQueueRequest>(),
        8usize,
        concat!("Alignment of ", stringify!(xclQueueRequest))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueRequest),
            "::",
            stringify!(op_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueRequest),
            "::",
            stringify!(bufs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_num) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueRequest),
            "::",
            stringify!(buf_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cdh) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueRequest),
            "::",
            stringify!(cdh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cdh_len) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueRequest),
            "::",
            stringify!(cdh_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueRequest),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueRequest),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xclQueueRequest),
            "::",
            stringify!(timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xclReqCompletion {
    pub resv: [::std::os::raw::c_char; 64usize],
    pub priv_data: *mut ::std::os::raw::c_void,
    pub nbytes: usize,
    pub err_code: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xclReqCompletion() {
    const UNINIT: ::std::mem::MaybeUninit<xclReqCompletion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xclReqCompletion>(),
        88usize,
        concat!("Size of: ", stringify!(xclReqCompletion))
    );
    assert_eq!(
        ::std::mem::align_of::<xclReqCompletion>(),
        8usize,
        concat!("Alignment of ", stringify!(xclReqCompletion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xclReqCompletion),
            "::",
            stringify!(resv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_data) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xclReqCompletion),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbytes) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(xclReqCompletion),
            "::",
            stringify!(nbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_code) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xclReqCompletion),
            "::",
            stringify!(err_code)
        )
    );
}
extern "C" {
    pub fn xclExecBufWithWaitList(
        handle: xclDeviceHandle,
        cmdBO: xclBufferHandle,
        num_bo_in_wait_list: usize,
        bo_wait_list: *mut xclBufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xclDebugReadIPStatus(
        handle: xclDeviceHandle,
        type_: xclDebugReadType,
        debugResults: *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    pub fn xclIPSetReadRange(
        handle: xclDeviceHandle,
        ipIndex: u32,
        start: u32,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " typedef xrtXclbinHandle - opaque xclbin handle"]
pub type xrtXclbinHandle = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " xrtXclbinAllocFilename() - Allocate a xclbin using xclbin filename\n\n @filename:      path to the xclbin file\n Return:         xrtXclbinHandle on success or NULL with errno set"]
    pub fn xrtXclbinAllocFilename(filename: *const ::std::os::raw::c_char) -> xrtXclbinHandle;
}
extern "C" {
    #[doc = " xrtXclbinAllocAxlf() - Allocate a xclbin using an axlf\n\n @top_axlf:      an axlf\n Return:         xrtXclbinHandle on success or NULL with errno set"]
    pub fn xrtXclbinAllocAxlf(top_axlf: *const axlf) -> xrtXclbinHandle;
}
extern "C" {
    #[doc = " xrtXclbinAllocRawData() - Allocate a xclbin using raw data\n\n @data:          raw data buffer of xclbin\n @size:          size (in bytes) of raw data buffer of xclbin\n Return:         xrtXclbinHandle on success or NULL with errno set"]
    pub fn xrtXclbinAllocRawData(
        data: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> xrtXclbinHandle;
}
extern "C" {
    #[doc = " xrtXclbinFreeHandle() - Deallocate the xclbin handle\n\n @xhdl:          xclbin handle\n Return:         0 on success, -1 on error"]
    pub fn xrtXclbinFreeHandle(xhdl: xrtXclbinHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtXclbinGetXSAName() - Get Xilinx Support Archive (XSA) Name of xclbin handle\n\n @xhdl:       Xclbin handle\n @name:       Return name of XSA.\n              If the value is nullptr, the content of this value will not be populated.\n              Otherwise, the the content of this value will be populated.\n @size:       size (in bytes) of @name.\n @ret_size:   Return size (in bytes) of XSA name.\n              If the value is nullptr, the content of this value will not be populated.\n              Otherwise, the the content of this value will be populated.\n Return:  0 on success or appropriate error number"]
    pub fn xrtXclbinGetXSAName(
        xhdl: xrtXclbinHandle,
        name: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        ret_size: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtXclbinGetUUID() - Get UUID of xclbin handle\n\n @xhdl:     Xclbin handle\n @ret_uuid: Return xclbin id in this uuid_t struct\n Return:    0 on success or appropriate error number"]
    pub fn xrtXclbinGetUUID(
        xhdl: xrtXclbinHandle,
        ret_uuid: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtXclbinGetNumKernels() - Get number of PL kernels in xclbin\n\n @xhdl:   Xclbin handle obtained from an xrtXclbinAlloc function\n Return:  The number of PL kernels in the xclbin\n\n Kernels are extracted from embedded XML metadata in the xclbin.\n A kernel groups one or more compute units. A kernel has arguments\n from which offset, type, etc can be retrived."]
    pub fn xrtXclbinGetNumKernels(xhdl: xrtXclbinHandle) -> usize;
}
extern "C" {
    #[doc = " xrtXclbinGetNumKernelComputeUnits() - Get number of CUs in xclbin\n\n @xhdl:   Xclbin handle obtained from an xrtXclbinAlloc function\n Return:  The number of compute units\n\n Compute units are associated with kernels.  This function returns\n the total number of compute units as the sum of compute units over\n all kernels."]
    pub fn xrtXclbinGetNumKernelComputeUnits(xhdl: xrtXclbinHandle) -> usize;
}
extern "C" {
    #[doc = " xrtXclbinGetData() - Get the raw data of the xclbin handle\n\n @xhdl:       Xclbin handle\n @data:       Return raw data.\n              If the value is nullptr, the content of this value will not be populated.\n              Otherwise, the the content of this value will be populated.\n @size:       Size (in bytes) of @data\n @ret_size:   Return size (in bytes) of XSA name.\n              If the value is nullptr, the content of this value will not be populated.\n              Otherwise, the the content of this value will be populated.\n Return:  0 on success or appropriate error number"]
    pub fn xrtXclbinGetData(
        xhdl: xrtXclbinHandle,
        data: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        ret_size: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xrtXclbinUUID(
        dhdl: xclDeviceHandle,
        out: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[doc = " typedef xrtDeviceHandle - opaque device handle"]
pub type xrtDeviceHandle = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " xrtDeviceOpen() - Open a device and obtain its handle\n\n @index:         Device index\n Return:         Handle representing the opened device, or nullptr on error"]
    pub fn xrtDeviceOpen(index: ::std::os::raw::c_uint) -> xrtDeviceHandle;
}
extern "C" {
    #[doc = " xrtDeviceOpenByBDF() - Open a device and obtain its handle\n\n @bdf:           PCIe BDF identifying the device to open\n Return:         Handle representing the opened device, or nullptr on error"]
    pub fn xrtDeviceOpenByBDF(bdf: *const ::std::os::raw::c_char) -> xrtDeviceHandle;
}
extern "C" {
    #[doc = " xrtDeviceOpenFromXcl() - Open a device from a shim xclDeviceHandle\n\n @xhdl:         Shim xclDeviceHandle\n Return:        Handle representing the opened device, or nullptr on error\n\n The returned XRT device handle must be explicitly closed when\n nolonger needed."]
    pub fn xrtDeviceOpenFromXcl(xhdl: xclDeviceHandle) -> xrtDeviceHandle;
}
extern "C" {
    #[doc = " xrtDeviceClose() - Close an opened device\n\n @dhdl:       Handle to device previously opened with xrtDeviceOpen\n Return:      0 on success, error otherwise"]
    pub fn xrtDeviceClose(dhdl: xrtDeviceHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtDeviceLoadXclbin() - Load an xclbin image\n\n @dhdl:       Handle to device previously opened with xrtDeviceOpen\n @xclbin:     Pointer to complete axlf in memory image\n Return:      0 on success, error otherwise\n\n The xclbin image can safely be deleted after calling\n this funciton."]
    pub fn xrtDeviceLoadXclbin(dhdl: xrtDeviceHandle, xclbin: *const axlf)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtDeviceLoadXclbinFile() - Read and load an xclbin file\n\n @dhdl:       Handle to device previously opened with xrtDeviceOpen\n @xclbin_fnm: Full path to xclbin file\n Return:      0 on success, error otherwise\n\n This function read the file from disk and loads\n the xclbin.   Using this function allows one time\n allocation of data that needs to be kept in memory."]
    pub fn xrtDeviceLoadXclbinFile(
        dhdl: xrtDeviceHandle,
        xclbin_fnm: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtDeviceLoadXclbinHandle() - load an xclbin from an xrt::xclbin handle\n\n @dhdl:       Handle to device previously opened with xrtDeviceOpen\n @xhdl:       xrt::xclbin handle\n Return:      0 on success, error otherwise\n\n This function uses the specified xrt::xclbin object created by\n caller.  The xrt::xclbin object must contain the complete axlf\n structure."]
    pub fn xrtDeviceLoadXclbinHandle(
        dhdl: xrtDeviceHandle,
        xhdl: xrtXclbinHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtDeviceLoadXclbinHandle() - load an xclbin from an xrt::xclbin handle\n\n @dhdl:       Handle to device previously opened with xrtDeviceOpen\n @uuid:       uuid_t struct of xclbin id\n Return:      0 on success, error otherwise\n\n This function reads the xclbin id already loaded in the system and\n comapres it with the input uuid. If they match, load the cached\n xclbin metadata into caller's process. Otherwise returns error."]
    pub fn xrtDeviceLoadXclbinUUID(
        dhdl: xrtDeviceHandle,
        uuid: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtDeviceGetXclbinUUID() - Get UUID of xclbin image loaded on device\n\n @dhdl:   Handle to device previously opened with xrtDeviceOpen\n @out:    Return xclbin id in this uuid_t struct\n Return:  0 on success or appropriate error number\n\n Note that current UUID can be different from the UUID of\n the xclbin loaded by this process using @load_xclbin()"]
    pub fn xrtDeviceGetXclbinUUID(
        dhdl: xrtDeviceHandle,
        out: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xrtDeviceToXclDevice(dhdl: xrtDeviceHandle) -> xclDeviceHandle;
}
#[doc = " typedef xrtBufferHandle - opaque buffer handle"]
pub type xrtBufferHandle = *mut ::std::os::raw::c_void;
#[doc = " typedef xrtBufferFlags - flags for BO\n\n See ``xrt_mem.h`` for available flags"]
pub type xrtBufferFlags = u64;
#[doc = " typedef xrtMemoryGroup - Memory bank group for buffer"]
pub type xrtMemoryGroup = u32;
#[doc = " @struct xcl_buffer_handle\n\n @brief\n Typed xclBufferHandle used to prevent ambiguity\n\n @details\n Use when constructing xrt::bo from xclBufferHandle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcl_buffer_handle {
    pub bhdl: xclBufferHandle,
}
#[test]
fn bindgen_test_layout_xcl_buffer_handle() {
    const UNINIT: ::std::mem::MaybeUninit<xcl_buffer_handle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<xcl_buffer_handle>(),
        4usize,
        concat!("Size of: ", stringify!(xcl_buffer_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<xcl_buffer_handle>(),
        4usize,
        concat!("Alignment of ", stringify!(xcl_buffer_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bhdl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcl_buffer_handle),
            "::",
            stringify!(bhdl)
        )
    );
}
extern "C" {
    #[doc = " xrtBOAllocUserPtr() - Allocate a BO using userptr provided by the user\n\n @dhdl:          Device handle\n @userptr:       Pointer to 4K aligned user memory\n @size:          Size of buffer\n @flags:         Specify type of buffer\n @grp:           Specify bank information\n Return:         xrtBufferHandle on success or NULL"]
    pub fn xrtBOAllocUserPtr(
        dhdl: xrtDeviceHandle,
        userptr: *mut ::std::os::raw::c_void,
        size: usize,
        flags: xrtBufferFlags,
        grp: xrtMemoryGroup,
    ) -> xrtBufferHandle;
}
extern "C" {
    #[doc = " xrtBOAlloc() - Allocate a BO of requested size with appropriate flags\n\n @dhdl:          Device handle\n @size:          Size of buffer\n @flags:         Specify type of buffer\n @grp:           Specify bank information\n Return:         xrtBufferHandle on success or NULL"]
    pub fn xrtBOAlloc(
        dhdl: xrtDeviceHandle,
        size: usize,
        flags: xrtBufferFlags,
        grp: xrtMemoryGroup,
    ) -> xrtBufferHandle;
}
extern "C" {
    #[doc = " xrtBOImport() - Allocate a BO imported from another device\n\n @dhdl:     Device that imports the exported buffer\n @ehdl:     Exported buffer handle, implementation specific type\n\n The exported buffer handle is acquired by using the export() method\n and can be passed to another process."]
    pub fn xrtBOImport(dhdl: xrtDeviceHandle, ehdl: xclBufferExportHandle) -> xrtBufferHandle;
}
extern "C" {
    #[doc = " xrtBOExport() - Export this buffer\n\n @bhdl:   Buffer handle\n Return:  Exported buffer handle\n\n An exported buffer can be imported on another device by this\n process or another process."]
    pub fn xrtBOExport(bhdl: xrtBufferHandle) -> xclBufferExportHandle;
}
extern "C" {
    #[doc = " xrtBOSubAlloc() - Allocate a sub buffer from a parent buffer\n\n @parent:        Parent buffer handle\n @size:          Size of sub buffer\n @offset:        Offset into parent buffer\n Return:         xrtBufferHandle on success or NULL"]
    pub fn xrtBOSubAlloc(parent: xrtBufferHandle, size: usize, offset: usize) -> xrtBufferHandle;
}
extern "C" {
    pub fn xrtBOAllocFromXcl(dhdl: xrtDeviceHandle, xhdl: xclBufferHandle) -> xrtBufferHandle;
}
extern "C" {
    #[doc = " xrtBOFree() - Free a previously allocated BO\n\n @bhdl:         Buffer handle\n Return:        0 on success, or err code on error"]
    pub fn xrtBOFree(bhdl: xrtBufferHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtBOSize() - Get the size of this buffer\n\n @bhdl:         Buffer handle\n Return:        Size of buffer in bytes"]
    pub fn xrtBOSize(bhdl: xrtBufferHandle) -> usize;
}
extern "C" {
    #[doc = " xrtBOAddr() - Get the physical address of this buffer\n\n @bhdl:         Buffer handle\n Return:        Device address of this BO, or LLONG_MAX on error"]
    pub fn xrtBOAddress(bhdl: xrtBufferHandle) -> u64;
}
extern "C" {
    #[doc = " xrtBOSync() - Synchronize buffer contents in requested direction\n\n @bhdl:          Bufferhandle\n @dir:           To device or from device\n @size:          Size of data to synchronize\n @offset:        Offset within the BO\n Return:         0 on success or error\n\n Synchronize the buffer contents between host and device. Depending\n on the memory model this may require DMA to/from device or CPU\n cache flushing/invalidation"]
    pub fn xrtBOSync(
        bhdl: xrtBufferHandle,
        dir: xclBOSyncDirection,
        size: usize,
        offset: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtBOMap() - Memory map BO into user's address space\n\n @bhdl:       Buffer handle\n Return:      Memory mapped buffer, or NULL on error\n\n Map the contents of the buffer object into host memory.  The buffer\n object is unmapped when freed."]
    pub fn xrtBOMap(bhdl: xrtBufferHandle) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " xrtBOWrite() - Copy-in user data to host backing storage of BO\n\n @bhdl:          Buffer handle\n @src:           Source data pointer\n @size:          Size of data to copy\n @seek:          Offset within the BO\n Return:         0 on success or appropriate error number\n\n Copy host buffer contents to previously allocated device\n memory. ``seek`` specifies how many bytes to skip at the beginning\n of the BO before copying-in ``size`` bytes of host buffer."]
    pub fn xrtBOWrite(
        bhdl: xrtBufferHandle,
        src: *const ::std::os::raw::c_void,
        size: usize,
        seek: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtBORead() - Copy-out user data from host backing storage of BO\n\n @bhdl:          Buffer handle\n @dst:           Destination data pointer\n @size:          Size of data to copy\n @skip:          Offset within the BO\n Return:         0 on success or appropriate error number\n\n Copy contents of previously allocated device memory to host\n buffer. ``skip`` specifies how many bytes to skip from the\n beginning of the BO before copying-out ``size`` bytes of device\n buffer."]
    pub fn xrtBORead(
        bhdl: xrtBufferHandle,
        dst: *mut ::std::os::raw::c_void,
        size: usize,
        skip: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtBOCopy() - Deep copy BO content from another buffer\n\n @dst:          Destination BO to copy to\n @src:          Source BO to copy from\n @sz:           Size of data to copy\n @dst_offset:   Offset into destination buffer to copy to\n @src_offset:   Offset into src buffer to copy from\n Return:        0 on success or appropriate error number\n\n It is an error if sz is 0 bytes or sz + src/dst_offset is out of bounds."]
    pub fn xrtBOCopy(
        dst: xrtBufferHandle,
        src: xrtBufferHandle,
        sz: usize,
        dst_offset: usize,
        src_offset: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " struct ert_packet: ERT generic packet format\n\n @state:   [3-0] current state of a command\n @custom:  [11-4] custom per specific commands\n @count:   [22-12] number of words in payload (data)\n @opcode:  [27-23] opcode identifying specific command\n @type:    [31-28] type of command (currently 0)\n @data:    count number of words representing packet payload"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ert_packet {
    pub __bindgen_anon_1: ert_packet__bindgen_ty_1,
    pub data: [u32; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ert_packet__bindgen_ty_1 {
    pub __bindgen_anon_1: ert_packet__bindgen_ty_1__bindgen_ty_1,
    pub header: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ert_packet__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ert_packet__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ert_packet__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ert_packet__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ert_packet__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_packet__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl ert_packet__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn custom(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_custom(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn opcode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: u32,
        custom: u32,
        count: u32,
        opcode: u32,
        type_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let custom: u32 = unsafe { ::std::mem::transmute(custom) };
            custom as u64
        });
        __bindgen_bitfield_unit.set(12usize, 11u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let opcode: u32 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ert_packet__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ert_packet__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_packet__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ert_packet__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_packet__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_packet__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_packet__bindgen_ty_1),
            "::",
            stringify!(header)
        )
    );
}
#[test]
fn bindgen_test_layout_ert_packet() {
    const UNINIT: ::std::mem::MaybeUninit<ert_packet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_packet>(),
        8usize,
        concat!("Size of: ", stringify!(ert_packet))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_packet>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_packet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_packet),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ert_start_kernel_cmd: ERT start kernel command format\n\n @state:           [3-0]   current state of a command\n @stat_enabled:    [4]     enabled driver to record timestamp for various\n                           states cmd has gone through. The stat data\n                           is appended after cmd data.\n @extra_cu_masks:  [11-10] extra CU masks in addition to mandatory mask\n @count:           [22-12] number of words following header for cmd data. Not\n                           include stat data.\n @opcode:          [27-23] 0, opcode for start_kernel\n @type:            [31-27] 0, type of start_kernel\n\n @cu_mask:         first mandatory CU mask\n @data:            count-1 number of words representing interpreted payload\n\n The packet payload is comprised of reserved id field, a mandatory CU mask,\n and extra_cu_masks per header field, followed by a CU register map of size\n (count - (1 + extra_cu_masks)) uint32_t words."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ert_start_kernel_cmd {
    pub __bindgen_anon_1: ert_start_kernel_cmd__bindgen_ty_1,
    pub cu_mask: u32,
    pub data: [u32; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ert_start_kernel_cmd__bindgen_ty_1 {
    pub __bindgen_anon_1: ert_start_kernel_cmd__bindgen_ty_1__bindgen_ty_1,
    pub header: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ert_start_kernel_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ert_start_kernel_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ert_start_kernel_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ert_start_kernel_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ert_start_kernel_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_start_kernel_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl ert_start_kernel_cmd__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn stat_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stat_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn extra_cu_masks(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_extra_cu_masks(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn opcode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: u32,
        stat_enabled: u32,
        unused: u32,
        extra_cu_masks: u32,
        count: u32,
        opcode: u32,
        type_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let stat_enabled: u32 = unsafe { ::std::mem::transmute(stat_enabled) };
            stat_enabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let unused: u32 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let extra_cu_masks: u32 = unsafe { ::std::mem::transmute(extra_cu_masks) };
            extra_cu_masks as u64
        });
        __bindgen_bitfield_unit.set(12usize, 11u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let opcode: u32 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ert_start_kernel_cmd__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ert_start_kernel_cmd__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_start_kernel_cmd__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ert_start_kernel_cmd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_start_kernel_cmd__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_start_kernel_cmd__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_kernel_cmd__bindgen_ty_1),
            "::",
            stringify!(header)
        )
    );
}
#[test]
fn bindgen_test_layout_ert_start_kernel_cmd() {
    const UNINIT: ::std::mem::MaybeUninit<ert_start_kernel_cmd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_start_kernel_cmd>(),
        12usize,
        concat!("Size of: ", stringify!(ert_start_kernel_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_start_kernel_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_start_kernel_cmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cu_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_kernel_cmd),
            "::",
            stringify!(cu_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_kernel_cmd),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ert_init_kernel_cmd: ERT initialize kernel command format\n this command initializes CUs by writing CU registers. CUs are\n represented by cu_mask and extra_cu_masks.\n\n @state:           [3-0]   current state of a command\n @update_rtp:      [4]     command is for runtime update of cu argument\n @extra_cu_masks:  [11-10] extra CU masks in addition to mandatory mask\n @count:           [22-12] number of words following header\n @opcode:          [27-23] 0, opcode for init_kernel\n @type:            [31-27] 0, type of init_kernel\n\n @cu_run_timeout   the configured CU timeout value in Microseconds\n                   setting to 0 means CU should not timeout\n @cu_reset_timeout the configured CU reset timeout value in Microseconds\n                   when CU timeout, CU will be reset. this indicates\n                   CU reset should be completed within the timeout value.\n                   if cu_run_timeout is set to 0, this field is undefined.\n\n @cu_mask:         first mandatory CU mask\n @data:            count-9 number of words representing interpreted payload\n\n The packet payload is comprised of reserved id field, 8 reserved fields,\n a mandatory CU mask, and extra_cu_masks per header field, followed by a\n CU register map of size (count - (9 + extra_cu_masks)) uint32_t words."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ert_init_kernel_cmd {
    pub __bindgen_anon_1: ert_init_kernel_cmd__bindgen_ty_1,
    pub cu_run_timeout: u32,
    pub cu_reset_timeout: u32,
    pub reserved: [u32; 6usize],
    pub cu_mask: u32,
    pub data: [u32; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ert_init_kernel_cmd__bindgen_ty_1 {
    pub __bindgen_anon_1: ert_init_kernel_cmd__bindgen_ty_1__bindgen_ty_1,
    pub header: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ert_init_kernel_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ert_init_kernel_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ert_init_kernel_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ert_init_kernel_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ert_init_kernel_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_init_kernel_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl ert_init_kernel_cmd__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn update_rtp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_rtp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn extra_cu_masks(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_extra_cu_masks(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn opcode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: u32,
        update_rtp: u32,
        unused: u32,
        extra_cu_masks: u32,
        count: u32,
        opcode: u32,
        type_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let update_rtp: u32 = unsafe { ::std::mem::transmute(update_rtp) };
            update_rtp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let unused: u32 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let extra_cu_masks: u32 = unsafe { ::std::mem::transmute(extra_cu_masks) };
            extra_cu_masks as u64
        });
        __bindgen_bitfield_unit.set(12usize, 11u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let opcode: u32 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ert_init_kernel_cmd__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ert_init_kernel_cmd__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_init_kernel_cmd__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ert_init_kernel_cmd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_init_kernel_cmd__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_init_kernel_cmd__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_init_kernel_cmd__bindgen_ty_1),
            "::",
            stringify!(header)
        )
    );
}
#[test]
fn bindgen_test_layout_ert_init_kernel_cmd() {
    const UNINIT: ::std::mem::MaybeUninit<ert_init_kernel_cmd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_init_kernel_cmd>(),
        44usize,
        concat!("Size of: ", stringify!(ert_init_kernel_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_init_kernel_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_init_kernel_cmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cu_run_timeout) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_init_kernel_cmd),
            "::",
            stringify!(cu_run_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cu_reset_timeout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_init_kernel_cmd),
            "::",
            stringify!(cu_reset_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_init_kernel_cmd),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cu_mask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_init_kernel_cmd),
            "::",
            stringify!(cu_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_init_kernel_cmd),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ert_start_copybo_cmd {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub cu_mask: [u32; 4usize],
    pub reserved: [u32; 4usize],
    pub src_addr_lo: u32,
    pub src_addr_hi: u32,
    pub src_bo_hdl: u32,
    pub dst_addr_lo: u32,
    pub dst_addr_hi: u32,
    pub dst_bo_hdl: u32,
    pub size: u32,
    pub size_hi: u32,
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ert_start_copybo_cmd() {
    const UNINIT: ::std::mem::MaybeUninit<ert_start_copybo_cmd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_start_copybo_cmd>(),
        80usize,
        concat!("Size of: ", stringify!(ert_start_copybo_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_start_copybo_cmd>(),
        8usize,
        concat!("Alignment of ", stringify!(ert_start_copybo_cmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cu_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_copybo_cmd),
            "::",
            stringify!(cu_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_copybo_cmd),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_addr_lo) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_copybo_cmd),
            "::",
            stringify!(src_addr_lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_addr_hi) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_copybo_cmd),
            "::",
            stringify!(src_addr_hi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_bo_hdl) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_copybo_cmd),
            "::",
            stringify!(src_bo_hdl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_addr_lo) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_copybo_cmd),
            "::",
            stringify!(dst_addr_lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_addr_hi) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_copybo_cmd),
            "::",
            stringify!(dst_addr_hi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_bo_hdl) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_copybo_cmd),
            "::",
            stringify!(dst_bo_hdl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_copybo_cmd),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_hi) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_copybo_cmd),
            "::",
            stringify!(size_hi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_start_copybo_cmd),
            "::",
            stringify!(arg)
        )
    );
}
impl ert_start_copybo_cmd {
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn extra_cu_masks(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_extra_cu_masks(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn opcode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: u32,
        unused: u32,
        extra_cu_masks: u32,
        count: u32,
        opcode: u32,
        type_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 6u8, {
            let unused: u32 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let extra_cu_masks: u32 = unsafe { ::std::mem::transmute(extra_cu_masks) };
            extra_cu_masks as u64
        });
        __bindgen_bitfield_unit.set(12usize, 11u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let opcode: u32 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " struct ert_configure_cmd: ERT configure command format\n\n @state:           [3-0] current state of a command\n @count:           [22-12] number of words in payload (5 + num_cus)\n @opcode:          [27-23] 1, opcode for configure\n @type:            [31-27] 0, type of configure\n\n @slot_size:       command queue slot size\n @num_cus:         number of compute units in program\n @cu_shift:        shift value to convert CU idx to CU addr\n @cu_base_addr:    base address to add to CU addr for actual physical address\n\n @ert:1            enable embedded HW scheduler\n @polling:1        poll for command completion\n @cu_dma:1         enable CUDMA custom module for HW scheduler\n @cu_isr:1         enable CUISR custom module for HW scheduler\n @cq_int:1         enable interrupt from host to HW scheduler\n @cdma:1           enable CDMA kernel\n @unused:25\n @dsa52:1          reserved for internal use\n\n @data:            addresses of @num_cus CUs"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ert_configure_cmd {
    pub __bindgen_anon_1: ert_configure_cmd__bindgen_ty_1,
    pub slot_size: u32,
    pub num_cus: u32,
    pub cu_shift: u32,
    pub cu_base_addr: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub data: [u32; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ert_configure_cmd__bindgen_ty_1 {
    pub __bindgen_anon_1: ert_configure_cmd__bindgen_ty_1__bindgen_ty_1,
    pub header: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ert_configure_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ert_configure_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ert_configure_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ert_configure_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ert_configure_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_configure_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl ert_configure_cmd__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn opcode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: u32,
        unused: u32,
        count: u32,
        opcode: u32,
        type_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let unused: u32 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(12usize, 11u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let opcode: u32 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ert_configure_cmd__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ert_configure_cmd__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_configure_cmd__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ert_configure_cmd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_configure_cmd__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_configure_cmd__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_configure_cmd__bindgen_ty_1),
            "::",
            stringify!(header)
        )
    );
}
#[test]
fn bindgen_test_layout_ert_configure_cmd() {
    const UNINIT: ::std::mem::MaybeUninit<ert_configure_cmd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_configure_cmd>(),
        28usize,
        concat!("Size of: ", stringify!(ert_configure_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_configure_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_configure_cmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slot_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_configure_cmd),
            "::",
            stringify!(slot_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_cus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_configure_cmd),
            "::",
            stringify!(num_cus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cu_shift) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_configure_cmd),
            "::",
            stringify!(cu_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cu_base_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_configure_cmd),
            "::",
            stringify!(cu_base_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_configure_cmd),
            "::",
            stringify!(data)
        )
    );
}
impl ert_configure_cmd {
    #[inline]
    pub fn ert(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ert(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn polling(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_polling(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cu_dma(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cu_dma(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cu_isr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cu_isr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cq_int(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cq_int(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cdma(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cdma(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dataflow(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dataflow(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rw_shared(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rw_shared(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn kds_30(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_kds_30(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmsg(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmsg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn echo(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_echo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unusedf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_unusedf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn dsa52(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsa52(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ert: u32,
        polling: u32,
        cu_dma: u32,
        cu_isr: u32,
        cq_int: u32,
        cdma: u32,
        dataflow: u32,
        rw_shared: u32,
        kds_30: u32,
        dmsg: u32,
        echo: u32,
        intr: u32,
        unusedf: u32,
        dsa52: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ert: u32 = unsafe { ::std::mem::transmute(ert) };
            ert as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let polling: u32 = unsafe { ::std::mem::transmute(polling) };
            polling as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cu_dma: u32 = unsafe { ::std::mem::transmute(cu_dma) };
            cu_dma as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cu_isr: u32 = unsafe { ::std::mem::transmute(cu_isr) };
            cu_isr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cq_int: u32 = unsafe { ::std::mem::transmute(cq_int) };
            cq_int as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cdma: u32 = unsafe { ::std::mem::transmute(cdma) };
            cdma as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let dataflow: u32 = unsafe { ::std::mem::transmute(dataflow) };
            dataflow as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rw_shared: u32 = unsafe { ::std::mem::transmute(rw_shared) };
            rw_shared as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let kds_30: u32 = unsafe { ::std::mem::transmute(kds_30) };
            kds_30 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dmsg: u32 = unsafe { ::std::mem::transmute(dmsg) };
            dmsg as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let echo: u32 = unsafe { ::std::mem::transmute(echo) };
            echo as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let intr: u32 = unsafe { ::std::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(12usize, 19u8, {
            let unusedf: u32 = unsafe { ::std::mem::transmute(unusedf) };
            unusedf as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let dsa52: u32 = unsafe { ::std::mem::transmute(dsa52) };
            dsa52 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct config_sk_image {
    pub start_cuidx: u32,
    pub num_cus: u32,
    pub sk_name: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_config_sk_image() {
    const UNINIT: ::std::mem::MaybeUninit<config_sk_image> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<config_sk_image>(),
        28usize,
        concat!("Size of: ", stringify!(config_sk_image))
    );
    assert_eq!(
        ::std::mem::align_of::<config_sk_image>(),
        4usize,
        concat!("Alignment of ", stringify!(config_sk_image))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_cuidx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(config_sk_image),
            "::",
            stringify!(start_cuidx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_cus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(config_sk_image),
            "::",
            stringify!(num_cus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sk_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(config_sk_image),
            "::",
            stringify!(sk_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct config_sk_image_uuid {
    pub start_cuidx: u32,
    pub num_cus: u32,
    pub sk_name: [u32; 5usize],
    pub sk_uuid: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_config_sk_image_uuid() {
    const UNINIT: ::std::mem::MaybeUninit<config_sk_image_uuid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<config_sk_image_uuid>(),
        44usize,
        concat!("Size of: ", stringify!(config_sk_image_uuid))
    );
    assert_eq!(
        ::std::mem::align_of::<config_sk_image_uuid>(),
        4usize,
        concat!("Alignment of ", stringify!(config_sk_image_uuid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_cuidx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(config_sk_image_uuid),
            "::",
            stringify!(start_cuidx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_cus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(config_sk_image_uuid),
            "::",
            stringify!(num_cus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sk_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(config_sk_image_uuid),
            "::",
            stringify!(sk_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sk_uuid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(config_sk_image_uuid),
            "::",
            stringify!(sk_uuid)
        )
    );
}
#[doc = " struct ert_configure_sk_cmd: ERT configure soft kernel command format\n\n @state:           [3-0] current state of a command\n @count:           [22-12] number of words in payload\n @opcode:          [27-23] 1, opcode for configure\n @type:            [31-27] 0, type of configure\n\n @num_image:       number of images"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ert_configure_sk_cmd {
    pub __bindgen_anon_1: ert_configure_sk_cmd__bindgen_ty_1,
    pub num_image: u32,
    pub image: [config_sk_image; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ert_configure_sk_cmd__bindgen_ty_1 {
    pub __bindgen_anon_1: ert_configure_sk_cmd__bindgen_ty_1__bindgen_ty_1,
    pub header: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ert_configure_sk_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ert_configure_sk_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ert_configure_sk_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ert_configure_sk_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ert_configure_sk_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_configure_sk_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl ert_configure_sk_cmd__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn opcode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: u32,
        unused: u32,
        count: u32,
        opcode: u32,
        type_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let unused: u32 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(12usize, 11u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let opcode: u32 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ert_configure_sk_cmd__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ert_configure_sk_cmd__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_configure_sk_cmd__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ert_configure_sk_cmd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_configure_sk_cmd__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_configure_sk_cmd__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_configure_sk_cmd__bindgen_ty_1),
            "::",
            stringify!(header)
        )
    );
}
#[test]
fn bindgen_test_layout_ert_configure_sk_cmd() {
    const UNINIT: ::std::mem::MaybeUninit<ert_configure_sk_cmd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_configure_sk_cmd>(),
        36usize,
        concat!("Size of: ", stringify!(ert_configure_sk_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_configure_sk_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_configure_sk_cmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_image) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_configure_sk_cmd),
            "::",
            stringify!(num_image)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_configure_sk_cmd),
            "::",
            stringify!(image)
        )
    );
}
#[doc = " struct ert_unconfigure_sk_cmd: ERT unconfigure soft kernel command format\n\n @state:           [3-0] current state of a command\n @count:           [22-12] number of words in payload\n @opcode:          [27-23] 1, opcode for configure\n @type:            [31-27] 0, type of configure\n\n @start_cuidx:     start index of compute units\n @num_cus:         number of compute units in program"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ert_unconfigure_sk_cmd {
    pub __bindgen_anon_1: ert_unconfigure_sk_cmd__bindgen_ty_1,
    pub start_cuidx: u32,
    pub num_cus: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ert_unconfigure_sk_cmd__bindgen_ty_1 {
    pub __bindgen_anon_1: ert_unconfigure_sk_cmd__bindgen_ty_1__bindgen_ty_1,
    pub header: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ert_unconfigure_sk_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ert_unconfigure_sk_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ert_unconfigure_sk_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ert_unconfigure_sk_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ert_unconfigure_sk_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_unconfigure_sk_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl ert_unconfigure_sk_cmd__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn opcode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: u32,
        unused: u32,
        count: u32,
        opcode: u32,
        type_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let unused: u32 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(12usize, 11u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let opcode: u32 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ert_unconfigure_sk_cmd__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ert_unconfigure_sk_cmd__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_unconfigure_sk_cmd__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ert_unconfigure_sk_cmd__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ert_unconfigure_sk_cmd__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_unconfigure_sk_cmd__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_unconfigure_sk_cmd__bindgen_ty_1),
            "::",
            stringify!(header)
        )
    );
}
#[test]
fn bindgen_test_layout_ert_unconfigure_sk_cmd() {
    const UNINIT: ::std::mem::MaybeUninit<ert_unconfigure_sk_cmd> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_unconfigure_sk_cmd>(),
        12usize,
        concat!("Size of: ", stringify!(ert_unconfigure_sk_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_unconfigure_sk_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_unconfigure_sk_cmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_cuidx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_unconfigure_sk_cmd),
            "::",
            stringify!(start_cuidx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_cus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_unconfigure_sk_cmd),
            "::",
            stringify!(num_cus)
        )
    );
}
#[doc = " struct ert_abort_cmd: ERT abort command format.\n\n @exec_bo_handle: The bo handle of execbuf command to abort"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ert_abort_cmd {
    pub __bindgen_anon_1: ert_abort_cmd__bindgen_ty_1,
    pub exec_bo_handle: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ert_abort_cmd__bindgen_ty_1 {
    pub __bindgen_anon_1: ert_abort_cmd__bindgen_ty_1__bindgen_ty_1,
    pub header: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ert_abort_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ert_abort_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ert_abort_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ert_abort_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ert_abort_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_abort_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl ert_abort_cmd__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn custom(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_custom(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn opcode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: u32,
        custom: u32,
        count: u32,
        opcode: u32,
        type_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let custom: u32 = unsafe { ::std::mem::transmute(custom) };
            custom as u64
        });
        __bindgen_bitfield_unit.set(12usize, 11u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let opcode: u32 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ert_abort_cmd__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ert_abort_cmd__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_abort_cmd__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ert_abort_cmd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_abort_cmd__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_abort_cmd__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_abort_cmd__bindgen_ty_1),
            "::",
            stringify!(header)
        )
    );
}
#[test]
fn bindgen_test_layout_ert_abort_cmd() {
    const UNINIT: ::std::mem::MaybeUninit<ert_abort_cmd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_abort_cmd>(),
        16usize,
        concat!("Size of: ", stringify!(ert_abort_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_abort_cmd>(),
        8usize,
        concat!("Alignment of ", stringify!(ert_abort_cmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exec_bo_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_abort_cmd),
            "::",
            stringify!(exec_bo_handle)
        )
    );
}
#[doc = " struct ert_validate_cmd: ERT BIST command format.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ert_validate_cmd {
    pub __bindgen_anon_1: ert_validate_cmd__bindgen_ty_1,
    pub timestamp: u32,
    pub cq_read_single: u32,
    pub cq_write_single: u32,
    pub cu_read_single: u32,
    pub cu_write_single: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ert_validate_cmd__bindgen_ty_1 {
    pub __bindgen_anon_1: ert_validate_cmd__bindgen_ty_1__bindgen_ty_1,
    pub header: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ert_validate_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ert_validate_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ert_validate_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ert_validate_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ert_validate_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_validate_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl ert_validate_cmd__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn custom(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_custom(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn opcode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: u32,
        custom: u32,
        count: u32,
        opcode: u32,
        type_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let custom: u32 = unsafe { ::std::mem::transmute(custom) };
            custom as u64
        });
        __bindgen_bitfield_unit.set(12usize, 11u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let opcode: u32 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ert_validate_cmd__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ert_validate_cmd__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_validate_cmd__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ert_validate_cmd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_validate_cmd__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_validate_cmd__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_validate_cmd__bindgen_ty_1),
            "::",
            stringify!(header)
        )
    );
}
#[test]
fn bindgen_test_layout_ert_validate_cmd() {
    const UNINIT: ::std::mem::MaybeUninit<ert_validate_cmd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_validate_cmd>(),
        24usize,
        concat!("Size of: ", stringify!(ert_validate_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_validate_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_validate_cmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_validate_cmd),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cq_read_single) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_validate_cmd),
            "::",
            stringify!(cq_read_single)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cq_write_single) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_validate_cmd),
            "::",
            stringify!(cq_write_single)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cu_read_single) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_validate_cmd),
            "::",
            stringify!(cu_read_single)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cu_write_single) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_validate_cmd),
            "::",
            stringify!(cu_write_single)
        )
    );
}
#[doc = " struct ert_validate_cmd: ERT BIST command format.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ert_access_valid_cmd {
    pub __bindgen_anon_1: ert_access_valid_cmd__bindgen_ty_1,
    pub h2h_access: u32,
    pub h2d_access: u32,
    pub d2h_access: u32,
    pub d2d_access: u32,
    pub d2cu_access: u32,
    pub wr_count: u32,
    pub wr_test: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ert_access_valid_cmd__bindgen_ty_1 {
    pub __bindgen_anon_1: ert_access_valid_cmd__bindgen_ty_1__bindgen_ty_1,
    pub header: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ert_access_valid_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ert_access_valid_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ert_access_valid_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ert_access_valid_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ert_access_valid_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_access_valid_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl ert_access_valid_cmd__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn state(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn custom(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_custom(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn opcode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: u32,
        custom: u32,
        count: u32,
        opcode: u32,
        type_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let state: u32 = unsafe { ::std::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let custom: u32 = unsafe { ::std::mem::transmute(custom) };
            custom as u64
        });
        __bindgen_bitfield_unit.set(12usize, 11u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let opcode: u32 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ert_access_valid_cmd__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ert_access_valid_cmd__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_access_valid_cmd__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ert_access_valid_cmd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_access_valid_cmd__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ert_access_valid_cmd__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_access_valid_cmd__bindgen_ty_1),
            "::",
            stringify!(header)
        )
    );
}
#[test]
fn bindgen_test_layout_ert_access_valid_cmd() {
    const UNINIT: ::std::mem::MaybeUninit<ert_access_valid_cmd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ert_access_valid_cmd>(),
        32usize,
        concat!("Size of: ", stringify!(ert_access_valid_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<ert_access_valid_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(ert_access_valid_cmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h2h_access) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_access_valid_cmd),
            "::",
            stringify!(h2h_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h2d_access) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_access_valid_cmd),
            "::",
            stringify!(h2d_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d2h_access) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_access_valid_cmd),
            "::",
            stringify!(d2h_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d2d_access) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_access_valid_cmd),
            "::",
            stringify!(d2d_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d2cu_access) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_access_valid_cmd),
            "::",
            stringify!(d2cu_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wr_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_access_valid_cmd),
            "::",
            stringify!(wr_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wr_test) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ert_access_valid_cmd),
            "::",
            stringify!(wr_test)
        )
    );
}
pub const ert_cmd_state_ERT_CMD_STATE_NEW: ert_cmd_state = 1;
pub const ert_cmd_state_ERT_CMD_STATE_QUEUED: ert_cmd_state = 2;
pub const ert_cmd_state_ERT_CMD_STATE_RUNNING: ert_cmd_state = 3;
pub const ert_cmd_state_ERT_CMD_STATE_COMPLETED: ert_cmd_state = 4;
pub const ert_cmd_state_ERT_CMD_STATE_ERROR: ert_cmd_state = 5;
pub const ert_cmd_state_ERT_CMD_STATE_ABORT: ert_cmd_state = 6;
pub const ert_cmd_state_ERT_CMD_STATE_SUBMITTED: ert_cmd_state = 7;
pub const ert_cmd_state_ERT_CMD_STATE_TIMEOUT: ert_cmd_state = 8;
pub const ert_cmd_state_ERT_CMD_STATE_NORESPONSE: ert_cmd_state = 9;
pub const ert_cmd_state_ERT_CMD_STATE_SKERROR: ert_cmd_state = 10;
pub const ert_cmd_state_ERT_CMD_STATE_SKCRASHED: ert_cmd_state = 11;
pub const ert_cmd_state_ERT_CMD_STATE_MAX: ert_cmd_state = 12;
#[doc = " ERT command state\n\n @ERT_CMD_STATE_NEW:         Set by host before submitting a command to\n                             scheduler\n @ERT_CMD_STATE_QUEUED:      Internal scheduler state\n @ERT_CMD_STATE_SUBMITTED:   Internal scheduler state\n @ERT_CMD_STATE_RUNNING:     Internal scheduler state\n @ERT_CMD_STATE_COMPLETED:   Set by scheduler when command completes\n @ERT_CMD_STATE_ERROR:       Set by scheduler if command failed\n @ERT_CMD_STATE_ABORT:       Set by scheduler if command abort\n @ERT_CMD_STATE_TIMEOUT:     Set by scheduler if command timeout and reset\n @ERT_CMD_STATE_NORESPONSE:  Set by scheduler if command timeout and fail to\n                             reset"]
pub type ert_cmd_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cu_cmd_state_timestamps {
    pub skc_timestamps: [u64; 12usize],
}
#[test]
fn bindgen_test_layout_cu_cmd_state_timestamps() {
    const UNINIT: ::std::mem::MaybeUninit<cu_cmd_state_timestamps> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cu_cmd_state_timestamps>(),
        96usize,
        concat!("Size of: ", stringify!(cu_cmd_state_timestamps))
    );
    assert_eq!(
        ::std::mem::align_of::<cu_cmd_state_timestamps>(),
        8usize,
        concat!("Alignment of ", stringify!(cu_cmd_state_timestamps))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skc_timestamps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cu_cmd_state_timestamps),
            "::",
            stringify!(skc_timestamps)
        )
    );
}
pub const ert_cmd_opcode_ERT_START_CU: ert_cmd_opcode = 0;
pub const ert_cmd_opcode_ERT_START_KERNEL: ert_cmd_opcode = 0;
pub const ert_cmd_opcode_ERT_CONFIGURE: ert_cmd_opcode = 2;
pub const ert_cmd_opcode_ERT_EXIT: ert_cmd_opcode = 3;
pub const ert_cmd_opcode_ERT_ABORT: ert_cmd_opcode = 4;
pub const ert_cmd_opcode_ERT_EXEC_WRITE: ert_cmd_opcode = 5;
pub const ert_cmd_opcode_ERT_CU_STAT: ert_cmd_opcode = 6;
pub const ert_cmd_opcode_ERT_START_COPYBO: ert_cmd_opcode = 7;
pub const ert_cmd_opcode_ERT_SK_CONFIG: ert_cmd_opcode = 8;
pub const ert_cmd_opcode_ERT_SK_START: ert_cmd_opcode = 9;
pub const ert_cmd_opcode_ERT_SK_UNCONFIG: ert_cmd_opcode = 10;
pub const ert_cmd_opcode_ERT_INIT_CU: ert_cmd_opcode = 11;
pub const ert_cmd_opcode_ERT_START_FA: ert_cmd_opcode = 12;
pub const ert_cmd_opcode_ERT_CLK_CALIB: ert_cmd_opcode = 13;
pub const ert_cmd_opcode_ERT_MB_VALIDATE: ert_cmd_opcode = 14;
pub const ert_cmd_opcode_ERT_START_KEY_VAL: ert_cmd_opcode = 15;
pub const ert_cmd_opcode_ERT_ACCESS_TEST_C: ert_cmd_opcode = 16;
pub const ert_cmd_opcode_ERT_ACCESS_TEST: ert_cmd_opcode = 17;
#[doc = " Opcode types for commands\n\n @ERT_START_CU:       start a workgroup on a CU\n @ERT_START_KERNEL:   currently aliased to ERT_START_CU\n @ERT_CONFIGURE:      configure command scheduler\n @ERT_EXEC_WRITE:     execute a specified CU after writing\n @ERT_CU_STAT:        get stats about CU execution\n @ERT_START_COPYBO:   start KDMA CU or P2P, may be converted to ERT_START_CU\n                      before cmd reach to scheduler, short-term hack\n @ERT_SK_CONFIG:      configure soft kernel\n @ERT_SK_START:       start a soft kernel\n @ERT_SK_UNCONFIG:    unconfigure a soft kernel\n @ERT_START_KEY_VAL:  same as ERT_START_CU but with key-value pair flavor"]
pub type ert_cmd_opcode = ::std::os::raw::c_uint;
pub const ert_cmd_type_ERT_DEFAULT: ert_cmd_type = 0;
pub const ert_cmd_type_ERT_KDS_LOCAL: ert_cmd_type = 1;
pub const ert_cmd_type_ERT_CTRL: ert_cmd_type = 2;
pub const ert_cmd_type_ERT_CU: ert_cmd_type = 3;
pub const ert_cmd_type_ERT_SCU: ert_cmd_type = 4;
#[doc = " Command types\n\n @ERT_DEFAULT:        default command type\n @ERT_KDS_LOCAL:      command processed by KDS locally\n @ERT_CTRL:           control command uses reserved command queue slot\n @ERT_CU:             compute unit command"]
pub type ert_cmd_type = ::std::os::raw::c_uint;
pub const softkernel_type_SOFTKERNEL_TYPE_EXEC: softkernel_type = 0;
#[doc = " Soft kernel types\n\n @SOFTKERNEL_TYPE_EXEC:       executable"]
pub type softkernel_type = ::std::os::raw::c_uint;
#[doc = " typedef xrtKernelHandle - opaque kernel handle\n\n A kernel handle is obtained by opening a kernel.  Clients\n pass this kernel handle to APIs that operate on a kernel."]
pub type xrtKernelHandle = *mut ::std::os::raw::c_void;
#[doc = " typedef xrtRunHandle - opaque handle to a specific kernel run\n\n A run handle is obtained by running a kernel.  Clients\n use a run handle to check or wait for kernel completion."]
pub type xrtRunHandle = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " xrtPLKernelOpen() - Open a PL kernel and obtain its handle.\n\n @deviceHandle:  Handle to the device with the kernel\n @xclbinId:      The uuid of the xclbin with the specified kernel.\n @name:          Name of kernel to open.\n Return:         Handle representing the opened kernel.\n\n The kernel name must uniquely identify compatible kernel instances\n (compute units).  Optionally specify which kernel instance(s) to\n open using \"kernelname:{instancename1,instancename2,...}\" syntax.\n The compute units are opened with shared access, meaning that\n other kernels and other process will have shared access to same\n compute units.  If exclusive access is needed then open the\n kernel using @xrtPLKernelOpenExclusve().\n\n An xclbin with the specified kernel must have been loaded prior\n to calling this function. An XRT_NULL_HANDLE is returned on error\n and errno is set accordingly.\n\n A kernel handle is thread safe and can be shared between threads."]
    pub fn xrtPLKernelOpen(
        deviceHandle: xrtDeviceHandle,
        xclbinId: *mut ::std::os::raw::c_uchar,
        name: *const ::std::os::raw::c_char,
    ) -> xrtKernelHandle;
}
extern "C" {
    #[doc = " xrtPLKernelOpenExclusive() - Open a PL kernel and obtain its handle.\n\n @deviceHandle:  Handle to the device with the kernel\n @xclbinId:      The uuid of the xclbin with the specified kernel.\n @name:          Name of kernel to open.\n Return:         Handle representing the opened kernel.\n\n Same as @xrtPLKernelOpen(), but opens compute units with exclusive\n access.  Fails if any compute unit is already opened with either\n exclusive or shared access."]
    pub fn xrtPLKernelOpenExclusive(
        deviceHandle: xrtDeviceHandle,
        xclbinId: *mut ::std::os::raw::c_uchar,
        name: *const ::std::os::raw::c_char,
    ) -> xrtKernelHandle;
}
extern "C" {
    #[doc = " xrtKernelClose() - Close an opened kernel\n\n @kernelHandle: Handle to kernel previously opened with xrtKernelOpen\n Return:        0 on success, -1 on error"]
    pub fn xrtKernelClose(kernelHandle: xrtKernelHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtKernelArgGroupId() - Acquire bank group id for kernel argument\n\n @kernelHandle: Handle to kernel previously opened with xrtKernelOpen\n @argno:        Index of kernel argument\n Return:        Group id or negative error code on error\n\n A valid group id is a non-negative integer.  The group id is required\n when constructing a buffer object.\n\n The kernel argument group id is ambigious if kernel has multiple kernel\n with different connectivity for specified argument.  In this case the\n API returns error."]
    pub fn xrtKernelArgGroupId(
        kernelHandle: xrtKernelHandle,
        argno: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtKernelArgOffset() - Get the offset of kernel argument\n\n @khdl:   Handle to kernel previously opened with xrtKernelOpen\n @argno:  Index of kernel argument\n Return:  The kernel register offset of the argument with specified index\n\n Use with ``xrtKernelReadRegister()`` and ``xrtKernelWriteRegister()``\n if manually reading or writing kernel registers for explicit arguments."]
    pub fn xrtKernelArgOffset(khdl: xrtKernelHandle, argno: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    #[doc = " xrtKernelReadRegister() - Read data from kernel address range\n\n @kernelHandle: Handle to kernel previously opened with xrtKernelOpen\n @offset:       Offset in register space to read from\n @datap:        Pointer to location where to write data\n Return:        0 on success, errcode otherwise\n\n The kernel must be associated with exactly one kernel instance\n (compute unit), which must be opened for exclusive access."]
    pub fn xrtKernelReadRegister(
        kernelHandle: xrtKernelHandle,
        offset: u32,
        datap: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtKernelWriteRegister() - Write to the address range of a kernel\n\n @kernelHandle: Handle to kernel previously opened with xrtKernelOpen\n @offset:       Offset in register space to write to\n @data:         Data to write\n Return:        0 on success, errcode otherwise\n\n The kernel must be associated with exactly one kernel instance\n (compute unit), which must be opened for exclusive access."]
    pub fn xrtKernelWriteRegister(
        kernelHandle: xrtKernelHandle,
        offset: u32,
        data: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtKernelRun() - Start a kernel execution\n\n @kernelHandle: Handle to the kernel to run\n @...:          Kernel arguments\n Return:        Run handle which must be closed with xrtRunClose()\n\n A run handle is specific to one execution of a kernel.  Once\n execution completes, the run handle can be re-used to execute the\n same kernel again.  When no longer needed, then run handle must be\n closed with xrtRunClose()."]
    pub fn xrtKernelRun(kernelHandle: xrtKernelHandle, ...) -> xrtRunHandle;
}
extern "C" {
    #[doc = " xrtRunOpen() - Open a new run handle for a kernel without starting kernel\n\n @kernelHandle: Handle to the kernel to associate the run handle with\n Return:        Run handle which must be closed with xrtRunClose()\n\n The handle can be used repeatedly to start an execution of the\n associated kernel.  This API allows application to manage run\n handles without maintaining corresponding kernel handle."]
    pub fn xrtRunOpen(kernelHandle: xrtKernelHandle) -> xrtRunHandle;
}
extern "C" {
    #[doc = " xrtRunSetArg() - Set a specific kernel argument for this run\n\n @rhdl:       Handle to the run object to modify\n @index:      Index of kernel argument to set\n @...:        The argument value to set.\n Return:      0 on success, -1 on error\n\n Use this API to explicitly set specific kernel arguments prior\n to starting kernel execution.  After setting all arguments, the\n kernel execution can be start with xrtRunStart()"]
    pub fn xrtRunSetArg(
        rhdl: xrtRunHandle,
        index: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtRunUpdateArg() - Asynchronous update of kernel argument\n\n @rhdl:       Handle to the run object to modify\n @index:      Index of kernel argument to update\n @...:        The argument value to update.\n Return:      0 on success, -1 on error\n\n Use this API to asynchronously update a specific kernel\n argument of an existing run.\n\n This API is only supported on Edge."]
    pub fn xrtRunUpdateArg(
        rhdl: xrtRunHandle,
        index: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtRunStart() - Start existing run handle\n\n @rhdl:       Handle to the run object to start\n Return:      0 on success, -1 on error\n\n Use this API when re-using a run handle for more than one execution\n of the kernel associated with the run handle."]
    pub fn xrtRunStart(rhdl: xrtRunHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtRunWait() - Wait for a run to complete\n\n @rhdl:       Handle to the run object to start\n Return:      Run command state for completed run,\n              or ERT_CMD_STATE_ABORT on error\n\n Blocks current thread until job has completed"]
    pub fn xrtRunWait(rhdl: xrtRunHandle) -> ert_cmd_state;
}
extern "C" {
    #[doc = " xrtRunWait() - Wait for a run to complete\n\n @rhdl:       Handle to the run object to start\n @timeout_ms: Timeout in millisecond\n Return:      Run command state for completed run, or\n              current status if timeout.\n\n Blocks current thread until job has completed"]
    pub fn xrtRunWaitFor(rhdl: xrtRunHandle, timeout_ms: ::std::os::raw::c_uint) -> ert_cmd_state;
}
extern "C" {
    #[doc = " xrtRunState() - Check the current state of a run\n\n @rhdl:       Handle to check\n Return:      The underlying command execution state per ert.h"]
    pub fn xrtRunState(rhdl: xrtRunHandle) -> ert_cmd_state;
}
extern "C" {
    #[doc = " xrtRunSetCallback() - Set a callback function\n\n @rhdl:        Handle to set callback on\n @state:       State to invoke callback on\n @callback:    Callback function\n @data:        User data to pass to callback function\n\n Register a run callback function that is invoked when the\n run changes underlying execution state to specified state.\n Support states are: ERT_CMD_STATE_COMPLETED (to be extended)"]
    pub fn xrtRunSetCallback(
        rhdl: xrtRunHandle,
        state: ert_cmd_state,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: xrtRunHandle,
                arg2: ert_cmd_state,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " xrtRunClose() - Close a run handle\n\n @rhdl:  Handle to close\n Return:      0 on success, -1 on error"]
    pub fn xrtRunClose(rhdl: xrtRunHandle) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
